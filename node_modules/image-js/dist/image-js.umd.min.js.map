{"version":3,"file":"image-js.umd.min.js","sources":["../node_modules/is-any-array/lib-esm/index.js","../node_modules/ml-array-max/lib-es6/index.js","../node_modules/ml-array-min/lib-es6/index.js","../node_modules/ml-array-rescale/lib-es6/index.js","../node_modules/ml-matrix/matrix.js","../node_modules/ml-matrix/matrix.mjs","../node_modules/ml-affine-transform/lib-esm/getCentroid.js","../node_modules/ml-affine-transform/lib-esm/getAffineTransform.js","../node_modules/median-quickselect/lib/median-quickselect.min.js","../node_modules/ml-array-median/lib-es6/index.js","../node_modules/ml-xsadd/lib-es6/xsadd.js","../node_modules/ml-random/lib-es6/choice.js","../node_modules/ml-random/lib-es6/index.js","../node_modules/ml-ransac/lib-esm/utils/getNbIterations.js","../node_modules/ml-ransac/lib-esm/index.js","../lib/featureMatching/keypoints/utils/getDistanceMatrix.js","../lib/featureMatching/keypoints/utils/getKeypointsInRadius.js","../lib/featureMatching/keypoints/getBestKeypointsInRadius.js","../lib/utils/geometry/points.js","../lib/maskAnalysis/utils/getAngle.js","../lib/utils/geometry/angles.js","../lib/utils/getRadius.js","../lib/featureMatching/utils/checkBorderDistance.js","../node_modules/ts-pattern/dist/index.js","../node_modules/bresenham-zingl/dist/index.umd.js","../lib/draw/utils/deleteDuplicates.js","../lib/utils/geometry/getCirclePoints.js","../lib/utils/getIndex.js","../lib/utils/surroundingPixels.js","../lib/utils/validators/checkProcessable.js","../lib/featureMatching/keypoints/getFastScore.js","../lib/utils/constants/kernels.js","../lib/featureMatching/keypoints/getHarrisScore.js","../lib/featureMatching/keypoints/isFastKeypoint.js","../lib/featureMatching/keypoints/getFastKeypoints.js","../lib/featureMatching/keypoints/getPatchIntensityMoment.js","../lib/featureMatching/keypoints/getPatchIntensityCentroid.js","../lib/featureMatching/keypoints/getOrientedFastKeypoints.js","../lib/featureMatching/utils/compareIntensity.js","../node_modules/ml-spectra-processing/lib/x/xMedian.js","../node_modules/ml-spectra-processing/lib/x/xCheck.js","../node_modules/ml-spectra-processing/lib/x/xFindClosestIndex.js","../node_modules/ml-spectra-processing/lib/x/xGetFromToIndex.js","../node_modules/ml-spectra-processing/lib/x/xMean.js","../node_modules/ml-spectra-processing/lib/x/xVariance.js","../node_modules/fft.js/lib/fft.js","../node_modules/ml-spectra-processing/node_modules/ml-xsadd/lib-esm/XSadd.js","../node_modules/ml-spectra-processing/lib/utils/createRandomArray.js","../node_modules/ml-spectra-processing/lib/xy/xyCovariance.js","../lib/utils/validators/assert.js","../lib/utils/clamp.js","../lib/featureMatching/utils/getGaussianPoints.js","../lib/featureMatching/utils/extractSquareImage.js","../lib/featureMatching/descriptors/utils/getKeypointPatch.js","../lib/featureMatching/descriptors/getBriefDescriptors.js","../lib/featureMatching/descriptors/getBrief.js","../lib/featureMatching/keypoints/getIntensityMoment.js","../lib/featureMatching/keypoints/getIntensityCentroid.js","../lib/featureMatching/matching/getHammingDistance.js","../lib/featureMatching/matching/bruteForceMatch.js","../lib/featureMatching/utils/sortBySourceDest.js","../lib/featureMatching/matching/getCrosscheckMatches.js","../lib/utils/validators/validators.js","../lib/compare/divide.js","../lib/compare/computeRmse.js","../lib/compare/computePsnr.js","../lib/utils/getDefaultColor.js","../lib/utils/setBlendedPixel.js","../lib/utils/setBlendedVisiblePixel.js","../lib/draw/utils/roundPoint.js","../lib/draw/drawCircleOnImage.js","../lib/draw/drawLineOnImage.js","../lib/draw/drawLineOnMask.js","../lib/draw/drawPolylineOnImage.js","../lib/draw/drawPolylineOnMask.js","../node_modules/two-product/two-product.js","../node_modules/robust-sum/robust-sum.js","../node_modules/two-sum/two-sum.js","../node_modules/robust-scale/robust-scale.js","../node_modules/robust-subtract/robust-diff.js","../node_modules/robust-orientation/orientation.js","../node_modules/robust-point-in-polygon/robust-pnp.js","../lib/utils/arrayPointsToObjects.js","../lib/draw/drawPolygonOnImage.js","../lib/draw/drawPolygonOnMask.js","../lib/draw/drawRectangle.js","../lib/draw/drawPoints.js","../lib/draw/drawMarker.js","../lib/draw/drawMarkers.js","../lib/filters/and.js","../node_modules/ml-convolution/src/utils.js","../node_modules/ml-convolution/src/directConvolution.js","../node_modules/ml-convolution/src/index.js","../lib/utils/interpolateBorder.js","../lib/operations/extendBorders.js","../lib/utils/round.js","../lib/filters/convolution.js","../lib/filters/blur.js","../lib/filters/derivativeFilter.js","../lib/utils/constants/colorModels.js","../lib/filters/increaseContrast.js","../lib/filters/gaussianBlur.js","../lib/filters/gradientFilter.js","../lib/filters/hypotenuse.js","../lib/operations/convertColor.js","../lib/operations/convertBitDepth.js","../lib/utils/validators/checkPointIsInteger.js","../lib/operations/extract.js","../lib/operations/merge.js","../lib/operations/split.js","../lib/operations/thresholds/huang.js","../lib/operations/thresholds/intermodes.js","../lib/operations/thresholds/isodata.js","../lib/operations/thresholds/li.js","../lib/operations/thresholds/maxEntropy.js","../lib/operations/thresholds/mean.js","../lib/operations/thresholds/minError.js","../lib/operations/thresholds/minimum.js","../lib/operations/thresholds/moments.js","../lib/operations/thresholds/otsu.js","../lib/operations/thresholds/percentile.js","../lib/operations/thresholds/renyiEntropy.js","../lib/operations/thresholds/shanbhag.js","../lib/operations/thresholds/triangle.js","../lib/operations/thresholds/yen.js","../lib/operations/threshold.js","../lib/operations/greyAlgorithms.js","../lib/operations/grey.js","../lib/operations/copyTo.js","../lib/operations/crop.js","../lib/operations/cropAlpha.js","../lib/utils/interpolatePixel.js","../lib/geometry/transform.js","../lib/geometry/resize.js","../lib/geometry/rotate.js","../lib/geometry/transformRotate.js","../lib/geometry/getPerspectiveWarp.js","../lib/point/operations.js","../lib/operations/cropRectangle.js","../lib/operations/paintMaskOnImage.js","../lib/operations/paintMaskOnMask.js","../node_modules/ml-regression-base/lib-esm/maybeToPrecision.js","../node_modules/ml-regression-polynomial-2d/lib-esm/checkArrayLength.js","../node_modules/ml-regression-polynomial-2d/lib-esm/BaseRegression2D.js","../node_modules/ml-regression-polynomial-2d/lib-esm/PolynomialRegression2D.js","../lib/operations/correctBackground.js","../lib/filters/invert.js","../lib/filters/level.js","../lib/filters/or.js","../lib/filters/flipX.js","../lib/filters/flipY.js","../lib/filters/flip.js","../lib/filters/medianFilter.js","../lib/filters/pixelate.js","../lib/maskAnalysis/getBorderPoints.js","../lib/utils/geometry/lines.js","../lib/utils/geometry/polygons.js","../lib/maskAnalysis/utils/getExtendedBorderPoints.js","../lib/maskAnalysis/utils/monotoneChainConvexHull.js","../lib/maskAnalysis/getConvexHull.js","../lib/maskAnalysis/getFeret.js","../lib/maskAnalysis/utils/getMbrAngle.js","../lib/maskAnalysis/utils/getMbrFromPoints.js","../lib/maskAnalysis/getMbr.js","../lib/utils/validators/checkKernel.js","../lib/morphology/erode.js","../lib/morphology/dilate.js","../lib/morphology/open.js","../lib/morphology/close.js","../lib/morphology/topHat.js","../lib/morphology/bottomHat.js","../lib/morphology/morphologicalGradient.js","../lib/utils/borderIterator.js","../lib/morphology/multipleFloodFill.js","../lib/morphology/clearBorder.js","../lib/morphology/cannyEdgeDetector.js","../lib/morphology/floodFill.js","../lib/morphology/solidFill.js","../lib/utils/boolToNumber.js","../lib/Mask.js","../lib/compare/subtract.js","../lib/compare/add.js","../lib/compare/multiply.js","../lib/compute/mean.js","../lib/compute/histogram.js","../lib/compute/median.js","../lib/compute/getExtrema.js","../lib/compute/variance.js","../node_modules/ml-regression-multivariate-linear/src/index.js","../node_modules/colord/index.mjs","../node_modules/colord/plugins/lab.mjs","../lib/correctColor/utils/formatData.js","../lib/correctColor/correctColor.js","../lib/utils/getMinMax.js","../lib/Image.js","../lib/utils/copyData.js","../lib/utils/getOutputImage.js","../lib/featureMatching/utils/getColors.js","../lib/featureMatching/utils/getKeypointColor.js","../lib/featureMatching/visualize/drawKeypoints.js","../lib/featureMatching/utils/getMatchColor.js","../lib/featureMatching/utils/sortByDistance.js","../lib/featureMatching/visualize/scaleKeypoints.js","../lib/featureMatching/visualize/drawMatches.js","../lib/featureMatching/visualize/Montage.js","../lib/featureMatching/visualize/overlapImages.js","../lib/featureMatching/matching/filterEuclideanDistance.js","../node_modules/iobuffer/lib/text.js","../node_modules/iobuffer/lib/iobuffer.js","../node_modules/fast-bmp/lib/bmp_decoder.js","../node_modules/fast-bmp/lib/constants.js","../node_modules/fast-bmp/lib/bmp_encoder.js","../node_modules/fast-bmp/lib/index.js","../lib/save/encodeBmp.js","../node_modules/jpeg-js/lib/encoder.js","../node_modules/jpeg-js/lib/decoder.js","../node_modules/jpeg-js/index.js","../lib/save/encodeJpeg.js","../node_modules/pako/dist/pako.esm.mjs","../node_modules/fast-png/lib/helpers/crc.js","../node_modules/fast-png/lib/helpers/unfilter.js","../node_modules/fast-png/lib/helpers/apply_unfilter.js","../node_modules/fast-png/lib/helpers/decode_interlace_adam7.js","../node_modules/fast-png/lib/helpers/decode_interlace_null.js","../node_modules/fast-png/lib/helpers/signature.js","../node_modules/fast-png/lib/helpers/text.js","../node_modules/fast-png/lib/internal_types.js","../node_modules/fast-png/lib/png_decoder.js","../node_modules/fast-png/lib/png_encoder.js","../node_modules/fast-png/lib/index.js","../lib/save/encodePng.js","../lib/save/encode.js","../lib/utils/cross_platform.js","../lib/save/write.js","../lib/save/writeCanvas.js","../node_modules/uint8-base64/lib-esm/decode.js","../node_modules/uint8-base64/lib-esm/base64codes.js","../node_modules/uint8-base64/lib-esm/encodeFast.js","../lib/save/encodeDataURL.js","../lib/align/affineTransfrom/getMatrixFromPoints.js","../lib/align/affineTransfrom/affineFitFunction.js","../lib/align/affineTransfrom/createAffineTransformModel.js","../lib/align/affineTransfrom/getEuclideanDistance.js","../lib/align/affineTransfrom/utils/getSourceWithoutMargins.js","../lib/align/affineTransfrom/getAffineTransform.js","../lib/align/alignMinDifference.js","../lib/utils/geometry/removeClosePoints.js","../node_modules/file-type/index.js","../node_modules/image-type/index.js","../lib/load/decodeBmp.js","../node_modules/tiff/lib/tags/exif.js","../node_modules/tiff/lib/tags/gps.js","../node_modules/tiff/lib/tags/standard.js","../node_modules/tiff/lib/hacks.js","../node_modules/tiff/lib/horizontal_differencing.js","../node_modules/tiff/lib/ifd.js","../node_modules/tiff/lib/ifd_value.js","../node_modules/tiff/lib/lzw.js","../node_modules/tiff/lib/tiff_ifd.js","../node_modules/tiff/lib/zlib.js","../node_modules/tiff/lib/tiff_decoder.js","../node_modules/tiff/lib/index.js","../node_modules/fast-jpeg/lib/decode.js","../lib/load/getMetadata.js","../lib/load/decodeJpeg.js","../lib/load/decodePng.js","../lib/load/decodeTiff.js","../lib/load/decode.js","../lib/load/read.js","../lib/load/readCanvas.js","../lib/load/readImg.js","../lib/load/fetchURL.js","../lib/roi/utils/hsvToRgb.js","../lib/roi/utils/rgbToNumber.js","../lib/roi/utils/colorMaps/getBinaryMap.js","../lib/roi/utils/colorMaps/getRainbowMap.js","../lib/roi/utils/colorMaps/getSaturationMap.js","../lib/roi/utils/getColorMap.js","../lib/roi/colorRois.js","../lib/roi/getBorderPoints.js","../lib/roi/getMask.js","../lib/roi/properties/getEllipse.js","../lib/roi/Roi.js","../lib/roi/computeRois.js","../lib/roi/getRois.js","../lib/roi/RoiMapManager.js","../lib/roi/fromMask.js","../node_modules/js-priority-queue/priority-queue.js","../lib/roi/waterShed.js","../lib/stack/utils/checkProcessable.js","../lib/stack/compute/histogram.js","../lib/stack/compute/maxImage.js","../lib/stack/compute/meanImage.js","../lib/stack/compute/medianImage.js","../lib/stack/load/decodeApng.js","../lib/stack/load/decodeTiff.js","../lib/stack/load/decodeStack.js","../lib/stack/compute/minImage.js","../lib/stack/compute/sum.js","../lib/stack/utils/checkImagesValid.js","../lib/Stack.js","../lib/utils/constants/channelLabels.js","../lib/extra/draw/draw_text.js"],"sourcesContent":["// eslint-disable-next-line @typescript-eslint/unbound-method\nconst toString = Object.prototype.toString;\n/**\n * Checks if an object is an instance of an Array (array or typed array, except those that contain bigint values).\n *\n * @param value - Object to check.\n * @returns True if the object is an array or a typed array.\n */\nexport function isAnyArray(value) {\n    const tag = toString.call(value);\n    return tag.endsWith('Array]') && !tag.includes('Big');\n}\n//# sourceMappingURL=index.js.map","import { isAnyArray } from 'is-any-array';\n\nfunction max(input) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!isAnyArray(input)) {\n    throw new TypeError('input must be an array');\n  }\n\n  if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var _options$fromIndex = options.fromIndex,\n      fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex,\n      _options$toIndex = options.toIndex,\n      toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;\n\n  if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {\n    throw new Error('fromIndex must be a positive integer smaller than length');\n  }\n\n  if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {\n    throw new Error('toIndex must be an integer greater than fromIndex and at most equal to length');\n  }\n\n  var maxValue = input[fromIndex];\n\n  for (var i = fromIndex + 1; i < toIndex; i++) {\n    if (input[i] > maxValue) maxValue = input[i];\n  }\n\n  return maxValue;\n}\n\nexport { max as default };\n","import { isAnyArray } from 'is-any-array';\n\nfunction min(input) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!isAnyArray(input)) {\n    throw new TypeError('input must be an array');\n  }\n\n  if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var _options$fromIndex = options.fromIndex,\n      fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex,\n      _options$toIndex = options.toIndex,\n      toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;\n\n  if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {\n    throw new Error('fromIndex must be a positive integer smaller than length');\n  }\n\n  if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {\n    throw new Error('toIndex must be an integer greater than fromIndex and at most equal to length');\n  }\n\n  var minValue = input[fromIndex];\n\n  for (var i = fromIndex + 1; i < toIndex; i++) {\n    if (input[i] < minValue) minValue = input[i];\n  }\n\n  return minValue;\n}\n\nexport { min as default };\n","import { isAnyArray } from 'is-any-array';\nimport max from 'ml-array-max';\nimport min from 'ml-array-min';\n\nfunction rescale(input) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!isAnyArray(input)) {\n    throw new TypeError('input must be an array');\n  } else if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var output;\n\n  if (options.output !== undefined) {\n    if (!isAnyArray(options.output)) {\n      throw new TypeError('output option must be an array if specified');\n    }\n\n    output = options.output;\n  } else {\n    output = new Array(input.length);\n  }\n\n  var currentMin = min(input);\n  var currentMax = max(input);\n\n  if (currentMin === currentMax) {\n    throw new RangeError('minimum and maximum input values are equal. Cannot rescale a constant array');\n  }\n\n  var _options$min = options.min,\n      minValue = _options$min === void 0 ? options.autoMinMax ? currentMin : 0 : _options$min,\n      _options$max = options.max,\n      maxValue = _options$max === void 0 ? options.autoMinMax ? currentMax : 1 : _options$max;\n\n  if (minValue >= maxValue) {\n    throw new RangeError('min option must be smaller than max option');\n  }\n\n  var factor = (maxValue - minValue) / (currentMax - currentMin);\n\n  for (var i = 0; i < input.length; i++) {\n    output[i] = (input[i] - currentMin) * factor + minValue;\n  }\n\n  return output;\n}\n\nexport { rescale as default };\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar isAnyArray = require('is-any-array');\nvar rescale = require('ml-array-rescale');\n\nconst indent = ' '.repeat(2);\nconst indentData = ' '.repeat(4);\n\n/**\n * @this {Matrix}\n * @returns {string}\n */\nfunction inspectMatrix() {\n  return inspectMatrixWithOptions(this);\n}\n\nfunction inspectMatrixWithOptions(matrix, options = {}) {\n  const {\n    maxRows = 15,\n    maxColumns = 10,\n    maxNumSize = 8,\n    padMinus = 'auto',\n  } = options;\n  return `${matrix.constructor.name} {\n${indent}[\n${indentData}${inspectData(matrix, maxRows, maxColumns, maxNumSize, padMinus)}\n${indent}]\n${indent}rows: ${matrix.rows}\n${indent}columns: ${matrix.columns}\n}`;\n}\n\nfunction inspectData(matrix, maxRows, maxColumns, maxNumSize, padMinus) {\n  const { rows, columns } = matrix;\n  const maxI = Math.min(rows, maxRows);\n  const maxJ = Math.min(columns, maxColumns);\n  const result = [];\n\n  if (padMinus === 'auto') {\n    padMinus = false;\n    loop: for (let i = 0; i < maxI; i++) {\n      for (let j = 0; j < maxJ; j++) {\n        if (matrix.get(i, j) < 0) {\n          padMinus = true;\n          break loop;\n        }\n      }\n    }\n  }\n\n  for (let i = 0; i < maxI; i++) {\n    let line = [];\n    for (let j = 0; j < maxJ; j++) {\n      line.push(formatNumber(matrix.get(i, j), maxNumSize, padMinus));\n    }\n    result.push(`${line.join(' ')}`);\n  }\n  if (maxJ !== columns) {\n    result[result.length - 1] += ` ... ${columns - maxColumns} more columns`;\n  }\n  if (maxI !== rows) {\n    result.push(`... ${rows - maxRows} more rows`);\n  }\n  return result.join(`\\n${indentData}`);\n}\n\nfunction formatNumber(num, maxNumSize, padMinus) {\n  return (\n    num >= 0 && padMinus\n      ? ` ${formatNumber2(num, maxNumSize - 1)}`\n      : formatNumber2(num, maxNumSize)\n  ).padEnd(maxNumSize);\n}\n\nfunction formatNumber2(num, len) {\n  // small.length numbers should be as is\n  let str = num.toString();\n  if (str.length <= len) return str;\n\n  // (7)'0.00123' is better then (7)'1.23e-2'\n  // (8)'0.000123' is worse then (7)'1.23e-3',\n  let fix = num.toFixed(len);\n  if (fix.length > len) {\n    fix = num.toFixed(Math.max(0, len - (fix.length - len)));\n  }\n  if (\n    fix.length <= len &&\n    !fix.startsWith('0.000') &&\n    !fix.startsWith('-0.000')\n  ) {\n    return fix;\n  }\n\n  // well, if it's still too long the user should've used longer numbers\n  let exp = num.toExponential(len);\n  if (exp.length > len) {\n    exp = num.toExponential(Math.max(0, len - (exp.length - len)));\n  }\n  return exp.slice(0);\n}\n\nfunction installMathOperations(AbstractMatrix, Matrix) {\n  AbstractMatrix.prototype.add = function add(value) {\n    if (typeof value === 'number') return this.addS(value);\n    return this.addM(value);\n  };\n\n  AbstractMatrix.prototype.addS = function addS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) + value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.addM = function addM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) + matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.add = function add(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.add(value);\n  };\n\n  AbstractMatrix.prototype.sub = function sub(value) {\n    if (typeof value === 'number') return this.subS(value);\n    return this.subM(value);\n  };\n\n  AbstractMatrix.prototype.subS = function subS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) - value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.subM = function subM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) - matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sub = function sub(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sub(value);\n  };\n  AbstractMatrix.prototype.subtract = AbstractMatrix.prototype.sub;\n  AbstractMatrix.prototype.subtractS = AbstractMatrix.prototype.subS;\n  AbstractMatrix.prototype.subtractM = AbstractMatrix.prototype.subM;\n  AbstractMatrix.subtract = AbstractMatrix.sub;\n\n  AbstractMatrix.prototype.mul = function mul(value) {\n    if (typeof value === 'number') return this.mulS(value);\n    return this.mulM(value);\n  };\n\n  AbstractMatrix.prototype.mulS = function mulS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) * value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.mulM = function mulM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) * matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.mul = function mul(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.mul(value);\n  };\n  AbstractMatrix.prototype.multiply = AbstractMatrix.prototype.mul;\n  AbstractMatrix.prototype.multiplyS = AbstractMatrix.prototype.mulS;\n  AbstractMatrix.prototype.multiplyM = AbstractMatrix.prototype.mulM;\n  AbstractMatrix.multiply = AbstractMatrix.mul;\n\n  AbstractMatrix.prototype.div = function div(value) {\n    if (typeof value === 'number') return this.divS(value);\n    return this.divM(value);\n  };\n\n  AbstractMatrix.prototype.divS = function divS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) / value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.divM = function divM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) / matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.div = function div(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.div(value);\n  };\n  AbstractMatrix.prototype.divide = AbstractMatrix.prototype.div;\n  AbstractMatrix.prototype.divideS = AbstractMatrix.prototype.divS;\n  AbstractMatrix.prototype.divideM = AbstractMatrix.prototype.divM;\n  AbstractMatrix.divide = AbstractMatrix.div;\n\n  AbstractMatrix.prototype.mod = function mod(value) {\n    if (typeof value === 'number') return this.modS(value);\n    return this.modM(value);\n  };\n\n  AbstractMatrix.prototype.modS = function modS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) % value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.modM = function modM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) % matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.mod = function mod(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.mod(value);\n  };\n  AbstractMatrix.prototype.modulus = AbstractMatrix.prototype.mod;\n  AbstractMatrix.prototype.modulusS = AbstractMatrix.prototype.modS;\n  AbstractMatrix.prototype.modulusM = AbstractMatrix.prototype.modM;\n  AbstractMatrix.modulus = AbstractMatrix.mod;\n\n  AbstractMatrix.prototype.and = function and(value) {\n    if (typeof value === 'number') return this.andS(value);\n    return this.andM(value);\n  };\n\n  AbstractMatrix.prototype.andS = function andS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) & value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.andM = function andM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) & matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.and = function and(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.and(value);\n  };\n\n  AbstractMatrix.prototype.or = function or(value) {\n    if (typeof value === 'number') return this.orS(value);\n    return this.orM(value);\n  };\n\n  AbstractMatrix.prototype.orS = function orS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) | value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.orM = function orM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) | matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.or = function or(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.or(value);\n  };\n\n  AbstractMatrix.prototype.xor = function xor(value) {\n    if (typeof value === 'number') return this.xorS(value);\n    return this.xorM(value);\n  };\n\n  AbstractMatrix.prototype.xorS = function xorS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) ^ value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.xorM = function xorM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) ^ matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.xor = function xor(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.xor(value);\n  };\n\n  AbstractMatrix.prototype.leftShift = function leftShift(value) {\n    if (typeof value === 'number') return this.leftShiftS(value);\n    return this.leftShiftM(value);\n  };\n\n  AbstractMatrix.prototype.leftShiftS = function leftShiftS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) << value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.leftShiftM = function leftShiftM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) << matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.leftShift = function leftShift(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.leftShift(value);\n  };\n\n  AbstractMatrix.prototype.signPropagatingRightShift = function signPropagatingRightShift(value) {\n    if (typeof value === 'number') return this.signPropagatingRightShiftS(value);\n    return this.signPropagatingRightShiftM(value);\n  };\n\n  AbstractMatrix.prototype.signPropagatingRightShiftS = function signPropagatingRightShiftS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) >> value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.signPropagatingRightShiftM = function signPropagatingRightShiftM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) >> matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.signPropagatingRightShift = function signPropagatingRightShift(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.signPropagatingRightShift(value);\n  };\n\n  AbstractMatrix.prototype.rightShift = function rightShift(value) {\n    if (typeof value === 'number') return this.rightShiftS(value);\n    return this.rightShiftM(value);\n  };\n\n  AbstractMatrix.prototype.rightShiftS = function rightShiftS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) >>> value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.rightShiftM = function rightShiftM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) >>> matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.rightShift = function rightShift(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.rightShift(value);\n  };\n  AbstractMatrix.prototype.zeroFillRightShift = AbstractMatrix.prototype.rightShift;\n  AbstractMatrix.prototype.zeroFillRightShiftS = AbstractMatrix.prototype.rightShiftS;\n  AbstractMatrix.prototype.zeroFillRightShiftM = AbstractMatrix.prototype.rightShiftM;\n  AbstractMatrix.zeroFillRightShift = AbstractMatrix.rightShift;\n\n  AbstractMatrix.prototype.not = function not() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, ~(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.not = function not(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.not();\n  };\n\n  AbstractMatrix.prototype.abs = function abs() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.abs(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.abs = function abs(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.abs();\n  };\n\n  AbstractMatrix.prototype.acos = function acos() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.acos(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.acos = function acos(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.acos();\n  };\n\n  AbstractMatrix.prototype.acosh = function acosh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.acosh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.acosh = function acosh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.acosh();\n  };\n\n  AbstractMatrix.prototype.asin = function asin() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.asin(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.asin = function asin(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.asin();\n  };\n\n  AbstractMatrix.prototype.asinh = function asinh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.asinh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.asinh = function asinh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.asinh();\n  };\n\n  AbstractMatrix.prototype.atan = function atan() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.atan(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.atan = function atan(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.atan();\n  };\n\n  AbstractMatrix.prototype.atanh = function atanh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.atanh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.atanh = function atanh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.atanh();\n  };\n\n  AbstractMatrix.prototype.cbrt = function cbrt() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.cbrt(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.cbrt = function cbrt(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.cbrt();\n  };\n\n  AbstractMatrix.prototype.ceil = function ceil() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.ceil(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.ceil = function ceil(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.ceil();\n  };\n\n  AbstractMatrix.prototype.clz32 = function clz32() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.clz32(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.clz32 = function clz32(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.clz32();\n  };\n\n  AbstractMatrix.prototype.cos = function cos() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.cos(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.cos = function cos(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.cos();\n  };\n\n  AbstractMatrix.prototype.cosh = function cosh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.cosh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.cosh = function cosh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.cosh();\n  };\n\n  AbstractMatrix.prototype.exp = function exp() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.exp(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.exp = function exp(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.exp();\n  };\n\n  AbstractMatrix.prototype.expm1 = function expm1() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.expm1(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.expm1 = function expm1(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.expm1();\n  };\n\n  AbstractMatrix.prototype.floor = function floor() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.floor(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.floor = function floor(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.floor();\n  };\n\n  AbstractMatrix.prototype.fround = function fround() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.fround(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.fround = function fround(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.fround();\n  };\n\n  AbstractMatrix.prototype.log = function log() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.log(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.log = function log(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.log();\n  };\n\n  AbstractMatrix.prototype.log1p = function log1p() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.log1p(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.log1p = function log1p(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.log1p();\n  };\n\n  AbstractMatrix.prototype.log10 = function log10() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.log10(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.log10 = function log10(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.log10();\n  };\n\n  AbstractMatrix.prototype.log2 = function log2() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.log2(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.log2 = function log2(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.log2();\n  };\n\n  AbstractMatrix.prototype.round = function round() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.round(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.round = function round(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.round();\n  };\n\n  AbstractMatrix.prototype.sign = function sign() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.sign(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sign = function sign(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sign();\n  };\n\n  AbstractMatrix.prototype.sin = function sin() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.sin(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sin = function sin(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sin();\n  };\n\n  AbstractMatrix.prototype.sinh = function sinh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.sinh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sinh = function sinh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sinh();\n  };\n\n  AbstractMatrix.prototype.sqrt = function sqrt() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.sqrt(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sqrt = function sqrt(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sqrt();\n  };\n\n  AbstractMatrix.prototype.tan = function tan() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.tan(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.tan = function tan(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.tan();\n  };\n\n  AbstractMatrix.prototype.tanh = function tanh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.tanh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.tanh = function tanh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.tanh();\n  };\n\n  AbstractMatrix.prototype.trunc = function trunc() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.trunc(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.trunc = function trunc(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.trunc();\n  };\n\n  AbstractMatrix.pow = function pow(matrix, arg0) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.pow(arg0);\n  };\n\n  AbstractMatrix.prototype.pow = function pow(value) {\n    if (typeof value === 'number') return this.powS(value);\n    return this.powM(value);\n  };\n\n  AbstractMatrix.prototype.powS = function powS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) ** value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.powM = function powM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) ** matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n}\n\n/**\n * @private\n * Check that a row index is not out of bounds\n * @param {Matrix} matrix\n * @param {number} index\n * @param {boolean} [outer]\n */\nfunction checkRowIndex(matrix, index, outer) {\n  let max = outer ? matrix.rows : matrix.rows - 1;\n  if (index < 0 || index > max) {\n    throw new RangeError('Row index out of range');\n  }\n}\n\n/**\n * @private\n * Check that a column index is not out of bounds\n * @param {Matrix} matrix\n * @param {number} index\n * @param {boolean} [outer]\n */\nfunction checkColumnIndex(matrix, index, outer) {\n  let max = outer ? matrix.columns : matrix.columns - 1;\n  if (index < 0 || index > max) {\n    throw new RangeError('Column index out of range');\n  }\n}\n\n/**\n * @private\n * Check that the provided vector is an array with the right length\n * @param {Matrix} matrix\n * @param {Array|Matrix} vector\n * @return {Array}\n * @throws {RangeError}\n */\nfunction checkRowVector(matrix, vector) {\n  if (vector.to1DArray) {\n    vector = vector.to1DArray();\n  }\n  if (vector.length !== matrix.columns) {\n    throw new RangeError(\n      'vector size must be the same as the number of columns',\n    );\n  }\n  return vector;\n}\n\n/**\n * @private\n * Check that the provided vector is an array with the right length\n * @param {Matrix} matrix\n * @param {Array|Matrix} vector\n * @return {Array}\n * @throws {RangeError}\n */\nfunction checkColumnVector(matrix, vector) {\n  if (vector.to1DArray) {\n    vector = vector.to1DArray();\n  }\n  if (vector.length !== matrix.rows) {\n    throw new RangeError('vector size must be the same as the number of rows');\n  }\n  return vector;\n}\n\nfunction checkRowIndices(matrix, rowIndices) {\n  if (!isAnyArray.isAnyArray(rowIndices)) {\n    throw new TypeError('row indices must be an array');\n  }\n\n  for (let i = 0; i < rowIndices.length; i++) {\n    if (rowIndices[i] < 0 || rowIndices[i] >= matrix.rows) {\n      throw new RangeError('row indices are out of range');\n    }\n  }\n}\n\nfunction checkColumnIndices(matrix, columnIndices) {\n  if (!isAnyArray.isAnyArray(columnIndices)) {\n    throw new TypeError('column indices must be an array');\n  }\n\n  for (let i = 0; i < columnIndices.length; i++) {\n    if (columnIndices[i] < 0 || columnIndices[i] >= matrix.columns) {\n      throw new RangeError('column indices are out of range');\n    }\n  }\n}\n\nfunction checkRange(matrix, startRow, endRow, startColumn, endColumn) {\n  if (arguments.length !== 5) {\n    throw new RangeError('expected 4 arguments');\n  }\n  checkNumber('startRow', startRow);\n  checkNumber('endRow', endRow);\n  checkNumber('startColumn', startColumn);\n  checkNumber('endColumn', endColumn);\n  if (\n    startRow > endRow ||\n    startColumn > endColumn ||\n    startRow < 0 ||\n    startRow >= matrix.rows ||\n    endRow < 0 ||\n    endRow >= matrix.rows ||\n    startColumn < 0 ||\n    startColumn >= matrix.columns ||\n    endColumn < 0 ||\n    endColumn >= matrix.columns\n  ) {\n    throw new RangeError('Submatrix indices are out of range');\n  }\n}\n\nfunction newArray(length, value = 0) {\n  let array = [];\n  for (let i = 0; i < length; i++) {\n    array.push(value);\n  }\n  return array;\n}\n\nfunction checkNumber(name, value) {\n  if (typeof value !== 'number') {\n    throw new TypeError(`${name} must be a number`);\n  }\n}\n\nfunction checkNonEmpty(matrix) {\n  if (matrix.isEmpty()) {\n    throw new Error('Empty matrix has no elements to index');\n  }\n}\n\nfunction sumByRow(matrix) {\n  let sum = newArray(matrix.rows);\n  for (let i = 0; i < matrix.rows; ++i) {\n    for (let j = 0; j < matrix.columns; ++j) {\n      sum[i] += matrix.get(i, j);\n    }\n  }\n  return sum;\n}\n\nfunction sumByColumn(matrix) {\n  let sum = newArray(matrix.columns);\n  for (let i = 0; i < matrix.rows; ++i) {\n    for (let j = 0; j < matrix.columns; ++j) {\n      sum[j] += matrix.get(i, j);\n    }\n  }\n  return sum;\n}\n\nfunction sumAll(matrix) {\n  let v = 0;\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      v += matrix.get(i, j);\n    }\n  }\n  return v;\n}\n\nfunction productByRow(matrix) {\n  let sum = newArray(matrix.rows, 1);\n  for (let i = 0; i < matrix.rows; ++i) {\n    for (let j = 0; j < matrix.columns; ++j) {\n      sum[i] *= matrix.get(i, j);\n    }\n  }\n  return sum;\n}\n\nfunction productByColumn(matrix) {\n  let sum = newArray(matrix.columns, 1);\n  for (let i = 0; i < matrix.rows; ++i) {\n    for (let j = 0; j < matrix.columns; ++j) {\n      sum[j] *= matrix.get(i, j);\n    }\n  }\n  return sum;\n}\n\nfunction productAll(matrix) {\n  let v = 1;\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      v *= matrix.get(i, j);\n    }\n  }\n  return v;\n}\n\nfunction varianceByRow(matrix, unbiased, mean) {\n  const rows = matrix.rows;\n  const cols = matrix.columns;\n  const variance = [];\n\n  for (let i = 0; i < rows; i++) {\n    let sum1 = 0;\n    let sum2 = 0;\n    let x = 0;\n    for (let j = 0; j < cols; j++) {\n      x = matrix.get(i, j) - mean[i];\n      sum1 += x;\n      sum2 += x * x;\n    }\n    if (unbiased) {\n      variance.push((sum2 - (sum1 * sum1) / cols) / (cols - 1));\n    } else {\n      variance.push((sum2 - (sum1 * sum1) / cols) / cols);\n    }\n  }\n  return variance;\n}\n\nfunction varianceByColumn(matrix, unbiased, mean) {\n  const rows = matrix.rows;\n  const cols = matrix.columns;\n  const variance = [];\n\n  for (let j = 0; j < cols; j++) {\n    let sum1 = 0;\n    let sum2 = 0;\n    let x = 0;\n    for (let i = 0; i < rows; i++) {\n      x = matrix.get(i, j) - mean[j];\n      sum1 += x;\n      sum2 += x * x;\n    }\n    if (unbiased) {\n      variance.push((sum2 - (sum1 * sum1) / rows) / (rows - 1));\n    } else {\n      variance.push((sum2 - (sum1 * sum1) / rows) / rows);\n    }\n  }\n  return variance;\n}\n\nfunction varianceAll(matrix, unbiased, mean) {\n  const rows = matrix.rows;\n  const cols = matrix.columns;\n  const size = rows * cols;\n\n  let sum1 = 0;\n  let sum2 = 0;\n  let x = 0;\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      x = matrix.get(i, j) - mean;\n      sum1 += x;\n      sum2 += x * x;\n    }\n  }\n  if (unbiased) {\n    return (sum2 - (sum1 * sum1) / size) / (size - 1);\n  } else {\n    return (sum2 - (sum1 * sum1) / size) / size;\n  }\n}\n\nfunction centerByRow(matrix, mean) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) - mean[i]);\n    }\n  }\n}\n\nfunction centerByColumn(matrix, mean) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) - mean[j]);\n    }\n  }\n}\n\nfunction centerAll(matrix, mean) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) - mean);\n    }\n  }\n}\n\nfunction getScaleByRow(matrix) {\n  const scale = [];\n  for (let i = 0; i < matrix.rows; i++) {\n    let sum = 0;\n    for (let j = 0; j < matrix.columns; j++) {\n      sum += matrix.get(i, j) ** 2 / (matrix.columns - 1);\n    }\n    scale.push(Math.sqrt(sum));\n  }\n  return scale;\n}\n\nfunction scaleByRow(matrix, scale) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) / scale[i]);\n    }\n  }\n}\n\nfunction getScaleByColumn(matrix) {\n  const scale = [];\n  for (let j = 0; j < matrix.columns; j++) {\n    let sum = 0;\n    for (let i = 0; i < matrix.rows; i++) {\n      sum += matrix.get(i, j) ** 2 / (matrix.rows - 1);\n    }\n    scale.push(Math.sqrt(sum));\n  }\n  return scale;\n}\n\nfunction scaleByColumn(matrix, scale) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) / scale[j]);\n    }\n  }\n}\n\nfunction getScaleAll(matrix) {\n  const divider = matrix.size - 1;\n  let sum = 0;\n  for (let j = 0; j < matrix.columns; j++) {\n    for (let i = 0; i < matrix.rows; i++) {\n      sum += matrix.get(i, j) ** 2 / divider;\n    }\n  }\n  return Math.sqrt(sum);\n}\n\nfunction scaleAll(matrix, scale) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) / scale);\n    }\n  }\n}\n\nclass AbstractMatrix {\n  static from1DArray(newRows, newColumns, newData) {\n    let length = newRows * newColumns;\n    if (length !== newData.length) {\n      throw new RangeError('data length does not match given dimensions');\n    }\n    let newMatrix = new Matrix(newRows, newColumns);\n    for (let row = 0; row < newRows; row++) {\n      for (let column = 0; column < newColumns; column++) {\n        newMatrix.set(row, column, newData[row * newColumns + column]);\n      }\n    }\n    return newMatrix;\n  }\n\n  static rowVector(newData) {\n    let vector = new Matrix(1, newData.length);\n    for (let i = 0; i < newData.length; i++) {\n      vector.set(0, i, newData[i]);\n    }\n    return vector;\n  }\n\n  static columnVector(newData) {\n    let vector = new Matrix(newData.length, 1);\n    for (let i = 0; i < newData.length; i++) {\n      vector.set(i, 0, newData[i]);\n    }\n    return vector;\n  }\n\n  static zeros(rows, columns) {\n    return new Matrix(rows, columns);\n  }\n\n  static ones(rows, columns) {\n    return new Matrix(rows, columns).fill(1);\n  }\n\n  static rand(rows, columns, options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { random = Math.random } = options;\n    let matrix = new Matrix(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        matrix.set(i, j, random());\n      }\n    }\n    return matrix;\n  }\n\n  static randInt(rows, columns, options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { min = 0, max = 1000, random = Math.random } = options;\n    if (!Number.isInteger(min)) throw new TypeError('min must be an integer');\n    if (!Number.isInteger(max)) throw new TypeError('max must be an integer');\n    if (min >= max) throw new RangeError('min must be smaller than max');\n    let interval = max - min;\n    let matrix = new Matrix(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        let value = min + Math.round(random() * interval);\n        matrix.set(i, j, value);\n      }\n    }\n    return matrix;\n  }\n\n  static eye(rows, columns, value) {\n    if (columns === undefined) columns = rows;\n    if (value === undefined) value = 1;\n    let min = Math.min(rows, columns);\n    let matrix = this.zeros(rows, columns);\n    for (let i = 0; i < min; i++) {\n      matrix.set(i, i, value);\n    }\n    return matrix;\n  }\n\n  static diag(data, rows, columns) {\n    let l = data.length;\n    if (rows === undefined) rows = l;\n    if (columns === undefined) columns = rows;\n    let min = Math.min(l, rows, columns);\n    let matrix = this.zeros(rows, columns);\n    for (let i = 0; i < min; i++) {\n      matrix.set(i, i, data[i]);\n    }\n    return matrix;\n  }\n\n  static min(matrix1, matrix2) {\n    matrix1 = this.checkMatrix(matrix1);\n    matrix2 = this.checkMatrix(matrix2);\n    let rows = matrix1.rows;\n    let columns = matrix1.columns;\n    let result = new Matrix(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        result.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));\n      }\n    }\n    return result;\n  }\n\n  static max(matrix1, matrix2) {\n    matrix1 = this.checkMatrix(matrix1);\n    matrix2 = this.checkMatrix(matrix2);\n    let rows = matrix1.rows;\n    let columns = matrix1.columns;\n    let result = new this(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        result.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));\n      }\n    }\n    return result;\n  }\n\n  static checkMatrix(value) {\n    return AbstractMatrix.isMatrix(value) ? value : new Matrix(value);\n  }\n\n  static isMatrix(value) {\n    return value != null && value.klass === 'Matrix';\n  }\n\n  get size() {\n    return this.rows * this.columns;\n  }\n\n  apply(callback) {\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        callback.call(this, i, j);\n      }\n    }\n    return this;\n  }\n\n  to1DArray() {\n    let array = [];\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        array.push(this.get(i, j));\n      }\n    }\n    return array;\n  }\n\n  to2DArray() {\n    let copy = [];\n    for (let i = 0; i < this.rows; i++) {\n      copy.push([]);\n      for (let j = 0; j < this.columns; j++) {\n        copy[i].push(this.get(i, j));\n      }\n    }\n    return copy;\n  }\n\n  toJSON() {\n    return this.to2DArray();\n  }\n\n  isRowVector() {\n    return this.rows === 1;\n  }\n\n  isColumnVector() {\n    return this.columns === 1;\n  }\n\n  isVector() {\n    return this.rows === 1 || this.columns === 1;\n  }\n\n  isSquare() {\n    return this.rows === this.columns;\n  }\n\n  isEmpty() {\n    return this.rows === 0 || this.columns === 0;\n  }\n\n  isSymmetric() {\n    if (this.isSquare()) {\n      for (let i = 0; i < this.rows; i++) {\n        for (let j = 0; j <= i; j++) {\n          if (this.get(i, j) !== this.get(j, i)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  isDistance() {\n    if (!this.isSymmetric()) return false;\n\n    for (let i = 0; i < this.rows; i++) {\n      if (this.get(i, i) !== 0) return false;\n    }\n\n    return true;\n  }\n\n  isEchelonForm() {\n    let i = 0;\n    let j = 0;\n    let previousColumn = -1;\n    let isEchelonForm = true;\n    let checked = false;\n    while (i < this.rows && isEchelonForm) {\n      j = 0;\n      checked = false;\n      while (j < this.columns && checked === false) {\n        if (this.get(i, j) === 0) {\n          j++;\n        } else if (this.get(i, j) === 1 && j > previousColumn) {\n          checked = true;\n          previousColumn = j;\n        } else {\n          isEchelonForm = false;\n          checked = true;\n        }\n      }\n      i++;\n    }\n    return isEchelonForm;\n  }\n\n  isReducedEchelonForm() {\n    let i = 0;\n    let j = 0;\n    let previousColumn = -1;\n    let isReducedEchelonForm = true;\n    let checked = false;\n    while (i < this.rows && isReducedEchelonForm) {\n      j = 0;\n      checked = false;\n      while (j < this.columns && checked === false) {\n        if (this.get(i, j) === 0) {\n          j++;\n        } else if (this.get(i, j) === 1 && j > previousColumn) {\n          checked = true;\n          previousColumn = j;\n        } else {\n          isReducedEchelonForm = false;\n          checked = true;\n        }\n      }\n      for (let k = j + 1; k < this.rows; k++) {\n        if (this.get(i, k) !== 0) {\n          isReducedEchelonForm = false;\n        }\n      }\n      i++;\n    }\n    return isReducedEchelonForm;\n  }\n\n  echelonForm() {\n    let result = this.clone();\n    let h = 0;\n    let k = 0;\n    while (h < result.rows && k < result.columns) {\n      let iMax = h;\n      for (let i = h; i < result.rows; i++) {\n        if (result.get(i, k) > result.get(iMax, k)) {\n          iMax = i;\n        }\n      }\n      if (result.get(iMax, k) === 0) {\n        k++;\n      } else {\n        result.swapRows(h, iMax);\n        let tmp = result.get(h, k);\n        for (let j = k; j < result.columns; j++) {\n          result.set(h, j, result.get(h, j) / tmp);\n        }\n        for (let i = h + 1; i < result.rows; i++) {\n          let factor = result.get(i, k) / result.get(h, k);\n          result.set(i, k, 0);\n          for (let j = k + 1; j < result.columns; j++) {\n            result.set(i, j, result.get(i, j) - result.get(h, j) * factor);\n          }\n        }\n        h++;\n        k++;\n      }\n    }\n    return result;\n  }\n\n  reducedEchelonForm() {\n    let result = this.echelonForm();\n    let m = result.columns;\n    let n = result.rows;\n    let h = n - 1;\n    while (h >= 0) {\n      if (result.maxRow(h) === 0) {\n        h--;\n      } else {\n        let p = 0;\n        let pivot = false;\n        while (p < n && pivot === false) {\n          if (result.get(h, p) === 1) {\n            pivot = true;\n          } else {\n            p++;\n          }\n        }\n        for (let i = 0; i < h; i++) {\n          let factor = result.get(i, p);\n          for (let j = p; j < m; j++) {\n            let tmp = result.get(i, j) - factor * result.get(h, j);\n            result.set(i, j, tmp);\n          }\n        }\n        h--;\n      }\n    }\n    return result;\n  }\n\n  set() {\n    throw new Error('set method is unimplemented');\n  }\n\n  get() {\n    throw new Error('get method is unimplemented');\n  }\n\n  repeat(options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { rows = 1, columns = 1 } = options;\n    if (!Number.isInteger(rows) || rows <= 0) {\n      throw new TypeError('rows must be a positive integer');\n    }\n    if (!Number.isInteger(columns) || columns <= 0) {\n      throw new TypeError('columns must be a positive integer');\n    }\n    let matrix = new Matrix(this.rows * rows, this.columns * columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        matrix.setSubMatrix(this, this.rows * i, this.columns * j);\n      }\n    }\n    return matrix;\n  }\n\n  fill(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, value);\n      }\n    }\n    return this;\n  }\n\n  neg() {\n    return this.mulS(-1);\n  }\n\n  getRow(index) {\n    checkRowIndex(this, index);\n    let row = [];\n    for (let i = 0; i < this.columns; i++) {\n      row.push(this.get(index, i));\n    }\n    return row;\n  }\n\n  getRowVector(index) {\n    return Matrix.rowVector(this.getRow(index));\n  }\n\n  setRow(index, array) {\n    checkRowIndex(this, index);\n    array = checkRowVector(this, array);\n    for (let i = 0; i < this.columns; i++) {\n      this.set(index, i, array[i]);\n    }\n    return this;\n  }\n\n  swapRows(row1, row2) {\n    checkRowIndex(this, row1);\n    checkRowIndex(this, row2);\n    for (let i = 0; i < this.columns; i++) {\n      let temp = this.get(row1, i);\n      this.set(row1, i, this.get(row2, i));\n      this.set(row2, i, temp);\n    }\n    return this;\n  }\n\n  getColumn(index) {\n    checkColumnIndex(this, index);\n    let column = [];\n    for (let i = 0; i < this.rows; i++) {\n      column.push(this.get(i, index));\n    }\n    return column;\n  }\n\n  getColumnVector(index) {\n    return Matrix.columnVector(this.getColumn(index));\n  }\n\n  setColumn(index, array) {\n    checkColumnIndex(this, index);\n    array = checkColumnVector(this, array);\n    for (let i = 0; i < this.rows; i++) {\n      this.set(i, index, array[i]);\n    }\n    return this;\n  }\n\n  swapColumns(column1, column2) {\n    checkColumnIndex(this, column1);\n    checkColumnIndex(this, column2);\n    for (let i = 0; i < this.rows; i++) {\n      let temp = this.get(i, column1);\n      this.set(i, column1, this.get(i, column2));\n      this.set(i, column2, temp);\n    }\n    return this;\n  }\n\n  addRowVector(vector) {\n    vector = checkRowVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) + vector[j]);\n      }\n    }\n    return this;\n  }\n\n  subRowVector(vector) {\n    vector = checkRowVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) - vector[j]);\n      }\n    }\n    return this;\n  }\n\n  mulRowVector(vector) {\n    vector = checkRowVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) * vector[j]);\n      }\n    }\n    return this;\n  }\n\n  divRowVector(vector) {\n    vector = checkRowVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) / vector[j]);\n      }\n    }\n    return this;\n  }\n\n  addColumnVector(vector) {\n    vector = checkColumnVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) + vector[i]);\n      }\n    }\n    return this;\n  }\n\n  subColumnVector(vector) {\n    vector = checkColumnVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) - vector[i]);\n      }\n    }\n    return this;\n  }\n\n  mulColumnVector(vector) {\n    vector = checkColumnVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) * vector[i]);\n      }\n    }\n    return this;\n  }\n\n  divColumnVector(vector) {\n    vector = checkColumnVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) / vector[i]);\n      }\n    }\n    return this;\n  }\n\n  mulRow(index, value) {\n    checkRowIndex(this, index);\n    for (let i = 0; i < this.columns; i++) {\n      this.set(index, i, this.get(index, i) * value);\n    }\n    return this;\n  }\n\n  mulColumn(index, value) {\n    checkColumnIndex(this, index);\n    for (let i = 0; i < this.rows; i++) {\n      this.set(i, index, this.get(i, index) * value);\n    }\n    return this;\n  }\n\n  max(by) {\n    if (this.isEmpty()) {\n      return NaN;\n    }\n    switch (by) {\n      case 'row': {\n        const max = new Array(this.rows).fill(Number.NEGATIVE_INFINITY);\n        for (let row = 0; row < this.rows; row++) {\n          for (let column = 0; column < this.columns; column++) {\n            if (this.get(row, column) > max[row]) {\n              max[row] = this.get(row, column);\n            }\n          }\n        }\n        return max;\n      }\n      case 'column': {\n        const max = new Array(this.columns).fill(Number.NEGATIVE_INFINITY);\n        for (let row = 0; row < this.rows; row++) {\n          for (let column = 0; column < this.columns; column++) {\n            if (this.get(row, column) > max[column]) {\n              max[column] = this.get(row, column);\n            }\n          }\n        }\n        return max;\n      }\n      case undefined: {\n        let max = this.get(0, 0);\n        for (let row = 0; row < this.rows; row++) {\n          for (let column = 0; column < this.columns; column++) {\n            if (this.get(row, column) > max) {\n              max = this.get(row, column);\n            }\n          }\n        }\n        return max;\n      }\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  maxIndex() {\n    checkNonEmpty(this);\n    let v = this.get(0, 0);\n    let idx = [0, 0];\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        if (this.get(i, j) > v) {\n          v = this.get(i, j);\n          idx[0] = i;\n          idx[1] = j;\n        }\n      }\n    }\n    return idx;\n  }\n\n  min(by) {\n    if (this.isEmpty()) {\n      return NaN;\n    }\n\n    switch (by) {\n      case 'row': {\n        const min = new Array(this.rows).fill(Number.POSITIVE_INFINITY);\n        for (let row = 0; row < this.rows; row++) {\n          for (let column = 0; column < this.columns; column++) {\n            if (this.get(row, column) < min[row]) {\n              min[row] = this.get(row, column);\n            }\n          }\n        }\n        return min;\n      }\n      case 'column': {\n        const min = new Array(this.columns).fill(Number.POSITIVE_INFINITY);\n        for (let row = 0; row < this.rows; row++) {\n          for (let column = 0; column < this.columns; column++) {\n            if (this.get(row, column) < min[column]) {\n              min[column] = this.get(row, column);\n            }\n          }\n        }\n        return min;\n      }\n      case undefined: {\n        let min = this.get(0, 0);\n        for (let row = 0; row < this.rows; row++) {\n          for (let column = 0; column < this.columns; column++) {\n            if (this.get(row, column) < min) {\n              min = this.get(row, column);\n            }\n          }\n        }\n        return min;\n      }\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  minIndex() {\n    checkNonEmpty(this);\n    let v = this.get(0, 0);\n    let idx = [0, 0];\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        if (this.get(i, j) < v) {\n          v = this.get(i, j);\n          idx[0] = i;\n          idx[1] = j;\n        }\n      }\n    }\n    return idx;\n  }\n\n  maxRow(row) {\n    checkRowIndex(this, row);\n    if (this.isEmpty()) {\n      return NaN;\n    }\n    let v = this.get(row, 0);\n    for (let i = 1; i < this.columns; i++) {\n      if (this.get(row, i) > v) {\n        v = this.get(row, i);\n      }\n    }\n    return v;\n  }\n\n  maxRowIndex(row) {\n    checkRowIndex(this, row);\n    checkNonEmpty(this);\n    let v = this.get(row, 0);\n    let idx = [row, 0];\n    for (let i = 1; i < this.columns; i++) {\n      if (this.get(row, i) > v) {\n        v = this.get(row, i);\n        idx[1] = i;\n      }\n    }\n    return idx;\n  }\n\n  minRow(row) {\n    checkRowIndex(this, row);\n    if (this.isEmpty()) {\n      return NaN;\n    }\n    let v = this.get(row, 0);\n    for (let i = 1; i < this.columns; i++) {\n      if (this.get(row, i) < v) {\n        v = this.get(row, i);\n      }\n    }\n    return v;\n  }\n\n  minRowIndex(row) {\n    checkRowIndex(this, row);\n    checkNonEmpty(this);\n    let v = this.get(row, 0);\n    let idx = [row, 0];\n    for (let i = 1; i < this.columns; i++) {\n      if (this.get(row, i) < v) {\n        v = this.get(row, i);\n        idx[1] = i;\n      }\n    }\n    return idx;\n  }\n\n  maxColumn(column) {\n    checkColumnIndex(this, column);\n    if (this.isEmpty()) {\n      return NaN;\n    }\n    let v = this.get(0, column);\n    for (let i = 1; i < this.rows; i++) {\n      if (this.get(i, column) > v) {\n        v = this.get(i, column);\n      }\n    }\n    return v;\n  }\n\n  maxColumnIndex(column) {\n    checkColumnIndex(this, column);\n    checkNonEmpty(this);\n    let v = this.get(0, column);\n    let idx = [0, column];\n    for (let i = 1; i < this.rows; i++) {\n      if (this.get(i, column) > v) {\n        v = this.get(i, column);\n        idx[0] = i;\n      }\n    }\n    return idx;\n  }\n\n  minColumn(column) {\n    checkColumnIndex(this, column);\n    if (this.isEmpty()) {\n      return NaN;\n    }\n    let v = this.get(0, column);\n    for (let i = 1; i < this.rows; i++) {\n      if (this.get(i, column) < v) {\n        v = this.get(i, column);\n      }\n    }\n    return v;\n  }\n\n  minColumnIndex(column) {\n    checkColumnIndex(this, column);\n    checkNonEmpty(this);\n    let v = this.get(0, column);\n    let idx = [0, column];\n    for (let i = 1; i < this.rows; i++) {\n      if (this.get(i, column) < v) {\n        v = this.get(i, column);\n        idx[0] = i;\n      }\n    }\n    return idx;\n  }\n\n  diag() {\n    let min = Math.min(this.rows, this.columns);\n    let diag = [];\n    for (let i = 0; i < min; i++) {\n      diag.push(this.get(i, i));\n    }\n    return diag;\n  }\n\n  norm(type = 'frobenius') {\n    switch (type) {\n      case 'max':\n        return this.max();\n      case 'frobenius':\n        return Math.sqrt(this.dot(this));\n      default:\n        throw new RangeError(`unknown norm type: ${type}`);\n    }\n  }\n\n  cumulativeSum() {\n    let sum = 0;\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        sum += this.get(i, j);\n        this.set(i, j, sum);\n      }\n    }\n    return this;\n  }\n\n  dot(vector2) {\n    if (AbstractMatrix.isMatrix(vector2)) vector2 = vector2.to1DArray();\n    let vector1 = this.to1DArray();\n    if (vector1.length !== vector2.length) {\n      throw new RangeError('vectors do not have the same size');\n    }\n    let dot = 0;\n    for (let i = 0; i < vector1.length; i++) {\n      dot += vector1[i] * vector2[i];\n    }\n    return dot;\n  }\n\n  mmul(other) {\n    other = Matrix.checkMatrix(other);\n\n    let m = this.rows;\n    let n = this.columns;\n    let p = other.columns;\n\n    let result = new Matrix(m, p);\n\n    let Bcolj = new Float64Array(n);\n    for (let j = 0; j < p; j++) {\n      for (let k = 0; k < n; k++) {\n        Bcolj[k] = other.get(k, j);\n      }\n\n      for (let i = 0; i < m; i++) {\n        let s = 0;\n        for (let k = 0; k < n; k++) {\n          s += this.get(i, k) * Bcolj[k];\n        }\n\n        result.set(i, j, s);\n      }\n    }\n    return result;\n  }\n\n  mpow(scalar) {\n    if (!this.isSquare()) {\n      throw new RangeError('Matrix must be square');\n    }\n    if (!Number.isInteger(scalar) || scalar < 0) {\n      throw new RangeError('Exponent must be a non-negative integer');\n    }\n    // Russian Peasant exponentiation, i.e. exponentiation by squaring\n    let result = Matrix.eye(this.rows);\n    let bb = this;\n    // Note: Don't bit shift. In JS, that would truncate at 32 bits\n    for (let e = scalar; e >= 1; e /= 2) {\n      if ((e & 1) !== 0) {\n        result = result.mmul(bb);\n      }\n      bb = bb.mmul(bb);\n    }\n    return result;\n  }\n\n  strassen2x2(other) {\n    other = Matrix.checkMatrix(other);\n    let result = new Matrix(2, 2);\n    const a11 = this.get(0, 0);\n    const b11 = other.get(0, 0);\n    const a12 = this.get(0, 1);\n    const b12 = other.get(0, 1);\n    const a21 = this.get(1, 0);\n    const b21 = other.get(1, 0);\n    const a22 = this.get(1, 1);\n    const b22 = other.get(1, 1);\n\n    // Compute intermediate values.\n    const m1 = (a11 + a22) * (b11 + b22);\n    const m2 = (a21 + a22) * b11;\n    const m3 = a11 * (b12 - b22);\n    const m4 = a22 * (b21 - b11);\n    const m5 = (a11 + a12) * b22;\n    const m6 = (a21 - a11) * (b11 + b12);\n    const m7 = (a12 - a22) * (b21 + b22);\n\n    // Combine intermediate values into the output.\n    const c00 = m1 + m4 - m5 + m7;\n    const c01 = m3 + m5;\n    const c10 = m2 + m4;\n    const c11 = m1 - m2 + m3 + m6;\n\n    result.set(0, 0, c00);\n    result.set(0, 1, c01);\n    result.set(1, 0, c10);\n    result.set(1, 1, c11);\n    return result;\n  }\n\n  strassen3x3(other) {\n    other = Matrix.checkMatrix(other);\n    let result = new Matrix(3, 3);\n\n    const a00 = this.get(0, 0);\n    const a01 = this.get(0, 1);\n    const a02 = this.get(0, 2);\n    const a10 = this.get(1, 0);\n    const a11 = this.get(1, 1);\n    const a12 = this.get(1, 2);\n    const a20 = this.get(2, 0);\n    const a21 = this.get(2, 1);\n    const a22 = this.get(2, 2);\n\n    const b00 = other.get(0, 0);\n    const b01 = other.get(0, 1);\n    const b02 = other.get(0, 2);\n    const b10 = other.get(1, 0);\n    const b11 = other.get(1, 1);\n    const b12 = other.get(1, 2);\n    const b20 = other.get(2, 0);\n    const b21 = other.get(2, 1);\n    const b22 = other.get(2, 2);\n\n    const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;\n    const m2 = (a00 - a10) * (-b01 + b11);\n    const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);\n    const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);\n    const m5 = (a10 + a11) * (-b00 + b01);\n    const m6 = a00 * b00;\n    const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);\n    const m8 = (-a00 + a20) * (b02 - b12);\n    const m9 = (a20 + a21) * (-b00 + b02);\n    const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;\n    const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);\n    const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);\n    const m13 = (a02 - a22) * (b11 - b21);\n    const m14 = a02 * b20;\n    const m15 = (a21 + a22) * (-b20 + b21);\n    const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);\n    const m17 = (a02 - a12) * (b12 - b22);\n    const m18 = (a11 + a12) * (-b20 + b22);\n    const m19 = a01 * b10;\n    const m20 = a12 * b21;\n    const m21 = a10 * b02;\n    const m22 = a20 * b01;\n    const m23 = a22 * b22;\n\n    const c00 = m6 + m14 + m19;\n    const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;\n    const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;\n    const c10 = m2 + m3 + m4 + m6 + m14 + m16 + m17;\n    const c11 = m2 + m4 + m5 + m6 + m20;\n    const c12 = m14 + m16 + m17 + m18 + m21;\n    const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;\n    const c21 = m12 + m13 + m14 + m15 + m22;\n    const c22 = m6 + m7 + m8 + m9 + m23;\n\n    result.set(0, 0, c00);\n    result.set(0, 1, c01);\n    result.set(0, 2, c02);\n    result.set(1, 0, c10);\n    result.set(1, 1, c11);\n    result.set(1, 2, c12);\n    result.set(2, 0, c20);\n    result.set(2, 1, c21);\n    result.set(2, 2, c22);\n    return result;\n  }\n\n  mmulStrassen(y) {\n    y = Matrix.checkMatrix(y);\n    let x = this.clone();\n    let r1 = x.rows;\n    let c1 = x.columns;\n    let r2 = y.rows;\n    let c2 = y.columns;\n    if (c1 !== r2) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`,\n      );\n    }\n\n    // Put a matrix into the top left of a matrix of zeros.\n    // `rows` and `cols` are the dimensions of the output matrix.\n    function embed(mat, rows, cols) {\n      let r = mat.rows;\n      let c = mat.columns;\n      if (r === rows && c === cols) {\n        return mat;\n      } else {\n        let resultat = AbstractMatrix.zeros(rows, cols);\n        resultat = resultat.setSubMatrix(mat, 0, 0);\n        return resultat;\n      }\n    }\n\n    // Make sure both matrices are the same size.\n    // This is exclusively for simplicity:\n    // this algorithm can be implemented with matrices of different sizes.\n\n    let r = Math.max(r1, r2);\n    let c = Math.max(c1, c2);\n    x = embed(x, r, c);\n    y = embed(y, r, c);\n\n    // Our recursive multiplication function.\n    function blockMult(a, b, rows, cols) {\n      // For small matrices, resort to naive multiplication.\n      if (rows <= 512 || cols <= 512) {\n        return a.mmul(b); // a is equivalent to this\n      }\n\n      // Apply dynamic padding.\n      if (rows % 2 === 1 && cols % 2 === 1) {\n        a = embed(a, rows + 1, cols + 1);\n        b = embed(b, rows + 1, cols + 1);\n      } else if (rows % 2 === 1) {\n        a = embed(a, rows + 1, cols);\n        b = embed(b, rows + 1, cols);\n      } else if (cols % 2 === 1) {\n        a = embed(a, rows, cols + 1);\n        b = embed(b, rows, cols + 1);\n      }\n\n      let halfRows = parseInt(a.rows / 2, 10);\n      let halfCols = parseInt(a.columns / 2, 10);\n      // Subdivide input matrices.\n      let a11 = a.subMatrix(0, halfRows - 1, 0, halfCols - 1);\n      let b11 = b.subMatrix(0, halfRows - 1, 0, halfCols - 1);\n\n      let a12 = a.subMatrix(0, halfRows - 1, halfCols, a.columns - 1);\n      let b12 = b.subMatrix(0, halfRows - 1, halfCols, b.columns - 1);\n\n      let a21 = a.subMatrix(halfRows, a.rows - 1, 0, halfCols - 1);\n      let b21 = b.subMatrix(halfRows, b.rows - 1, 0, halfCols - 1);\n\n      let a22 = a.subMatrix(halfRows, a.rows - 1, halfCols, a.columns - 1);\n      let b22 = b.subMatrix(halfRows, b.rows - 1, halfCols, b.columns - 1);\n\n      // Compute intermediate values.\n      let m1 = blockMult(\n        AbstractMatrix.add(a11, a22),\n        AbstractMatrix.add(b11, b22),\n        halfRows,\n        halfCols,\n      );\n      let m2 = blockMult(AbstractMatrix.add(a21, a22), b11, halfRows, halfCols);\n      let m3 = blockMult(a11, AbstractMatrix.sub(b12, b22), halfRows, halfCols);\n      let m4 = blockMult(a22, AbstractMatrix.sub(b21, b11), halfRows, halfCols);\n      let m5 = blockMult(AbstractMatrix.add(a11, a12), b22, halfRows, halfCols);\n      let m6 = blockMult(\n        AbstractMatrix.sub(a21, a11),\n        AbstractMatrix.add(b11, b12),\n        halfRows,\n        halfCols,\n      );\n      let m7 = blockMult(\n        AbstractMatrix.sub(a12, a22),\n        AbstractMatrix.add(b21, b22),\n        halfRows,\n        halfCols,\n      );\n\n      // Combine intermediate values into the output.\n      let c11 = AbstractMatrix.add(m1, m4);\n      c11.sub(m5);\n      c11.add(m7);\n      let c12 = AbstractMatrix.add(m3, m5);\n      let c21 = AbstractMatrix.add(m2, m4);\n      let c22 = AbstractMatrix.sub(m1, m2);\n      c22.add(m3);\n      c22.add(m6);\n\n      // Crop output to the desired size (undo dynamic padding).\n      let result = AbstractMatrix.zeros(2 * c11.rows, 2 * c11.columns);\n      result = result.setSubMatrix(c11, 0, 0);\n      result = result.setSubMatrix(c12, c11.rows, 0);\n      result = result.setSubMatrix(c21, 0, c11.columns);\n      result = result.setSubMatrix(c22, c11.rows, c11.columns);\n      return result.subMatrix(0, rows - 1, 0, cols - 1);\n    }\n\n    return blockMult(x, y, r, c);\n  }\n\n  scaleRows(options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { min = 0, max = 1 } = options;\n    if (!Number.isFinite(min)) throw new TypeError('min must be a number');\n    if (!Number.isFinite(max)) throw new TypeError('max must be a number');\n    if (min >= max) throw new RangeError('min must be smaller than max');\n    let newMatrix = new Matrix(this.rows, this.columns);\n    for (let i = 0; i < this.rows; i++) {\n      const row = this.getRow(i);\n      if (row.length > 0) {\n        rescale(row, { min, max, output: row });\n      }\n      newMatrix.setRow(i, row);\n    }\n    return newMatrix;\n  }\n\n  scaleColumns(options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { min = 0, max = 1 } = options;\n    if (!Number.isFinite(min)) throw new TypeError('min must be a number');\n    if (!Number.isFinite(max)) throw new TypeError('max must be a number');\n    if (min >= max) throw new RangeError('min must be smaller than max');\n    let newMatrix = new Matrix(this.rows, this.columns);\n    for (let i = 0; i < this.columns; i++) {\n      const column = this.getColumn(i);\n      if (column.length) {\n        rescale(column, {\n          min,\n          max,\n          output: column,\n        });\n      }\n      newMatrix.setColumn(i, column);\n    }\n    return newMatrix;\n  }\n\n  flipRows() {\n    const middle = Math.ceil(this.columns / 2);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < middle; j++) {\n        let first = this.get(i, j);\n        let last = this.get(i, this.columns - 1 - j);\n        this.set(i, j, last);\n        this.set(i, this.columns - 1 - j, first);\n      }\n    }\n    return this;\n  }\n\n  flipColumns() {\n    const middle = Math.ceil(this.rows / 2);\n    for (let j = 0; j < this.columns; j++) {\n      for (let i = 0; i < middle; i++) {\n        let first = this.get(i, j);\n        let last = this.get(this.rows - 1 - i, j);\n        this.set(i, j, last);\n        this.set(this.rows - 1 - i, j, first);\n      }\n    }\n    return this;\n  }\n\n  kroneckerProduct(other) {\n    other = Matrix.checkMatrix(other);\n\n    let m = this.rows;\n    let n = this.columns;\n    let p = other.rows;\n    let q = other.columns;\n\n    let result = new Matrix(m * p, n * q);\n    for (let i = 0; i < m; i++) {\n      for (let j = 0; j < n; j++) {\n        for (let k = 0; k < p; k++) {\n          for (let l = 0; l < q; l++) {\n            result.set(p * i + k, q * j + l, this.get(i, j) * other.get(k, l));\n          }\n        }\n      }\n    }\n    return result;\n  }\n\n  kroneckerSum(other) {\n    other = Matrix.checkMatrix(other);\n    if (!this.isSquare() || !other.isSquare()) {\n      throw new Error('Kronecker Sum needs two Square Matrices');\n    }\n    let m = this.rows;\n    let n = other.rows;\n    let AxI = this.kroneckerProduct(Matrix.eye(n, n));\n    let IxB = Matrix.eye(m, m).kroneckerProduct(other);\n    return AxI.add(IxB);\n  }\n\n  transpose() {\n    let result = new Matrix(this.columns, this.rows);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        result.set(j, i, this.get(i, j));\n      }\n    }\n    return result;\n  }\n\n  sortRows(compareFunction = compareNumbers) {\n    for (let i = 0; i < this.rows; i++) {\n      this.setRow(i, this.getRow(i).sort(compareFunction));\n    }\n    return this;\n  }\n\n  sortColumns(compareFunction = compareNumbers) {\n    for (let i = 0; i < this.columns; i++) {\n      this.setColumn(i, this.getColumn(i).sort(compareFunction));\n    }\n    return this;\n  }\n\n  subMatrix(startRow, endRow, startColumn, endColumn) {\n    checkRange(this, startRow, endRow, startColumn, endColumn);\n    let newMatrix = new Matrix(\n      endRow - startRow + 1,\n      endColumn - startColumn + 1,\n    );\n    for (let i = startRow; i <= endRow; i++) {\n      for (let j = startColumn; j <= endColumn; j++) {\n        newMatrix.set(i - startRow, j - startColumn, this.get(i, j));\n      }\n    }\n    return newMatrix;\n  }\n\n  subMatrixRow(indices, startColumn, endColumn) {\n    if (startColumn === undefined) startColumn = 0;\n    if (endColumn === undefined) endColumn = this.columns - 1;\n    if (\n      startColumn > endColumn ||\n      startColumn < 0 ||\n      startColumn >= this.columns ||\n      endColumn < 0 ||\n      endColumn >= this.columns\n    ) {\n      throw new RangeError('Argument out of range');\n    }\n\n    let newMatrix = new Matrix(indices.length, endColumn - startColumn + 1);\n    for (let i = 0; i < indices.length; i++) {\n      for (let j = startColumn; j <= endColumn; j++) {\n        if (indices[i] < 0 || indices[i] >= this.rows) {\n          throw new RangeError(`Row index out of range: ${indices[i]}`);\n        }\n        newMatrix.set(i, j - startColumn, this.get(indices[i], j));\n      }\n    }\n    return newMatrix;\n  }\n\n  subMatrixColumn(indices, startRow, endRow) {\n    if (startRow === undefined) startRow = 0;\n    if (endRow === undefined) endRow = this.rows - 1;\n    if (\n      startRow > endRow ||\n      startRow < 0 ||\n      startRow >= this.rows ||\n      endRow < 0 ||\n      endRow >= this.rows\n    ) {\n      throw new RangeError('Argument out of range');\n    }\n\n    let newMatrix = new Matrix(endRow - startRow + 1, indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      for (let j = startRow; j <= endRow; j++) {\n        if (indices[i] < 0 || indices[i] >= this.columns) {\n          throw new RangeError(`Column index out of range: ${indices[i]}`);\n        }\n        newMatrix.set(j - startRow, i, this.get(j, indices[i]));\n      }\n    }\n    return newMatrix;\n  }\n\n  setSubMatrix(matrix, startRow, startColumn) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (matrix.isEmpty()) {\n      return this;\n    }\n    let endRow = startRow + matrix.rows - 1;\n    let endColumn = startColumn + matrix.columns - 1;\n    checkRange(this, startRow, endRow, startColumn, endColumn);\n    for (let i = 0; i < matrix.rows; i++) {\n      for (let j = 0; j < matrix.columns; j++) {\n        this.set(startRow + i, startColumn + j, matrix.get(i, j));\n      }\n    }\n    return this;\n  }\n\n  selection(rowIndices, columnIndices) {\n    checkRowIndices(this, rowIndices);\n    checkColumnIndices(this, columnIndices);\n    let newMatrix = new Matrix(rowIndices.length, columnIndices.length);\n    for (let i = 0; i < rowIndices.length; i++) {\n      let rowIndex = rowIndices[i];\n      for (let j = 0; j < columnIndices.length; j++) {\n        let columnIndex = columnIndices[j];\n        newMatrix.set(i, j, this.get(rowIndex, columnIndex));\n      }\n    }\n    return newMatrix;\n  }\n\n  trace() {\n    let min = Math.min(this.rows, this.columns);\n    let trace = 0;\n    for (let i = 0; i < min; i++) {\n      trace += this.get(i, i);\n    }\n    return trace;\n  }\n\n  clone() {\n    return this.constructor.copy(this, new Matrix(this.rows, this.columns));\n  }\n\n  /**\n   * @template {AbstractMatrix} M\n   * @param {AbstractMatrix} from\n   * @param {M} to\n   * @return {M}\n   */\n  static copy(from, to) {\n    for (const [row, column, value] of from.entries()) {\n      to.set(row, column, value);\n    }\n\n    return to;\n  }\n\n  sum(by) {\n    switch (by) {\n      case 'row':\n        return sumByRow(this);\n      case 'column':\n        return sumByColumn(this);\n      case undefined:\n        return sumAll(this);\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  product(by) {\n    switch (by) {\n      case 'row':\n        return productByRow(this);\n      case 'column':\n        return productByColumn(this);\n      case undefined:\n        return productAll(this);\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  mean(by) {\n    const sum = this.sum(by);\n    switch (by) {\n      case 'row': {\n        for (let i = 0; i < this.rows; i++) {\n          sum[i] /= this.columns;\n        }\n        return sum;\n      }\n      case 'column': {\n        for (let i = 0; i < this.columns; i++) {\n          sum[i] /= this.rows;\n        }\n        return sum;\n      }\n      case undefined:\n        return sum / this.size;\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  variance(by, options = {}) {\n    if (typeof by === 'object') {\n      options = by;\n      by = undefined;\n    }\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { unbiased = true, mean = this.mean(by) } = options;\n    if (typeof unbiased !== 'boolean') {\n      throw new TypeError('unbiased must be a boolean');\n    }\n    switch (by) {\n      case 'row': {\n        if (!isAnyArray.isAnyArray(mean)) {\n          throw new TypeError('mean must be an array');\n        }\n        return varianceByRow(this, unbiased, mean);\n      }\n      case 'column': {\n        if (!isAnyArray.isAnyArray(mean)) {\n          throw new TypeError('mean must be an array');\n        }\n        return varianceByColumn(this, unbiased, mean);\n      }\n      case undefined: {\n        if (typeof mean !== 'number') {\n          throw new TypeError('mean must be a number');\n        }\n        return varianceAll(this, unbiased, mean);\n      }\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  standardDeviation(by, options) {\n    if (typeof by === 'object') {\n      options = by;\n      by = undefined;\n    }\n    const variance = this.variance(by, options);\n    if (by === undefined) {\n      return Math.sqrt(variance);\n    } else {\n      for (let i = 0; i < variance.length; i++) {\n        variance[i] = Math.sqrt(variance[i]);\n      }\n      return variance;\n    }\n  }\n\n  center(by, options = {}) {\n    if (typeof by === 'object') {\n      options = by;\n      by = undefined;\n    }\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { center = this.mean(by) } = options;\n    switch (by) {\n      case 'row': {\n        if (!isAnyArray.isAnyArray(center)) {\n          throw new TypeError('center must be an array');\n        }\n        centerByRow(this, center);\n        return this;\n      }\n      case 'column': {\n        if (!isAnyArray.isAnyArray(center)) {\n          throw new TypeError('center must be an array');\n        }\n        centerByColumn(this, center);\n        return this;\n      }\n      case undefined: {\n        if (typeof center !== 'number') {\n          throw new TypeError('center must be a number');\n        }\n        centerAll(this, center);\n        return this;\n      }\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  scale(by, options = {}) {\n    if (typeof by === 'object') {\n      options = by;\n      by = undefined;\n    }\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    let scale = options.scale;\n    switch (by) {\n      case 'row': {\n        if (scale === undefined) {\n          scale = getScaleByRow(this);\n        } else if (!isAnyArray.isAnyArray(scale)) {\n          throw new TypeError('scale must be an array');\n        }\n        scaleByRow(this, scale);\n        return this;\n      }\n      case 'column': {\n        if (scale === undefined) {\n          scale = getScaleByColumn(this);\n        } else if (!isAnyArray.isAnyArray(scale)) {\n          throw new TypeError('scale must be an array');\n        }\n        scaleByColumn(this, scale);\n        return this;\n      }\n      case undefined: {\n        if (scale === undefined) {\n          scale = getScaleAll(this);\n        } else if (typeof scale !== 'number') {\n          throw new TypeError('scale must be a number');\n        }\n        scaleAll(this, scale);\n        return this;\n      }\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  toString(options) {\n    return inspectMatrixWithOptions(this, options);\n  }\n\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n\n  /**\n   * iterator from left to right, from top to bottom\n   * yield [row, column, value]\n   * @returns {Generator<[number, number, number], void, void>}\n   */\n  *entries() {\n    for (let row = 0; row < this.rows; row++) {\n      for (let col = 0; col < this.columns; col++) {\n        yield [row, col, this.get(row, col)];\n      }\n    }\n  }\n\n  /**\n   * iterator from left to right, from top to bottom\n   * yield value\n   * @returns {Generator<number, void, void>}\n   */\n  *values() {\n    for (let row = 0; row < this.rows; row++) {\n      for (let col = 0; col < this.columns; col++) {\n        yield this.get(row, col);\n      }\n    }\n  }\n}\n\nAbstractMatrix.prototype.klass = 'Matrix';\nif (typeof Symbol !== 'undefined') {\n  AbstractMatrix.prototype[Symbol.for('nodejs.util.inspect.custom')] =\n    inspectMatrix;\n}\n\nfunction compareNumbers(a, b) {\n  return a - b;\n}\n\nfunction isArrayOfNumbers(array) {\n  return array.every((element) => {\n    return typeof element === 'number';\n  });\n}\n\n// Synonyms\nAbstractMatrix.random = AbstractMatrix.rand;\nAbstractMatrix.randomInt = AbstractMatrix.randInt;\nAbstractMatrix.diagonal = AbstractMatrix.diag;\nAbstractMatrix.prototype.diagonal = AbstractMatrix.prototype.diag;\nAbstractMatrix.identity = AbstractMatrix.eye;\nAbstractMatrix.prototype.negate = AbstractMatrix.prototype.neg;\nAbstractMatrix.prototype.tensorProduct =\n  AbstractMatrix.prototype.kroneckerProduct;\n\nclass Matrix extends AbstractMatrix {\n  /**\n   * @type {Float64Array[]}\n   */\n  data;\n\n  /**\n   * Init an empty matrix\n   * @param {number} nRows\n   * @param {number} nColumns\n   */\n  #initData(nRows, nColumns) {\n    this.data = [];\n\n    if (Number.isInteger(nColumns) && nColumns >= 0) {\n      for (let i = 0; i < nRows; i++) {\n        this.data.push(new Float64Array(nColumns));\n      }\n    } else {\n      throw new TypeError('nColumns must be a positive integer');\n    }\n\n    this.rows = nRows;\n    this.columns = nColumns;\n  }\n\n  constructor(nRows, nColumns) {\n    super();\n    if (Matrix.isMatrix(nRows)) {\n      this.#initData(nRows.rows, nRows.columns);\n      Matrix.copy(nRows, this);\n    } else if (Number.isInteger(nRows) && nRows >= 0) {\n      this.#initData(nRows, nColumns);\n    } else if (isAnyArray.isAnyArray(nRows)) {\n      // Copy the values from the 2D array\n      const arrayData = nRows;\n      nRows = arrayData.length;\n      nColumns = nRows ? arrayData[0].length : 0;\n      if (typeof nColumns !== 'number') {\n        throw new TypeError(\n          'Data must be a 2D array with at least one element',\n        );\n      }\n      this.data = [];\n\n      for (let i = 0; i < nRows; i++) {\n        if (arrayData[i].length !== nColumns) {\n          throw new RangeError('Inconsistent array dimensions');\n        }\n        if (!isArrayOfNumbers(arrayData[i])) {\n          throw new TypeError('Input data contains non-numeric values');\n        }\n        this.data.push(Float64Array.from(arrayData[i]));\n      }\n\n      this.rows = nRows;\n      this.columns = nColumns;\n    } else {\n      throw new TypeError(\n        'First argument must be a positive number or an array',\n      );\n    }\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.data[rowIndex][columnIndex] = value;\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.data[rowIndex][columnIndex];\n  }\n\n  removeRow(index) {\n    checkRowIndex(this, index);\n    this.data.splice(index, 1);\n    this.rows -= 1;\n    return this;\n  }\n\n  addRow(index, array) {\n    if (array === undefined) {\n      array = index;\n      index = this.rows;\n    }\n    checkRowIndex(this, index, true);\n    array = Float64Array.from(checkRowVector(this, array));\n    this.data.splice(index, 0, array);\n    this.rows += 1;\n    return this;\n  }\n\n  removeColumn(index) {\n    checkColumnIndex(this, index);\n    for (let i = 0; i < this.rows; i++) {\n      const newRow = new Float64Array(this.columns - 1);\n      for (let j = 0; j < index; j++) {\n        newRow[j] = this.data[i][j];\n      }\n      for (let j = index + 1; j < this.columns; j++) {\n        newRow[j - 1] = this.data[i][j];\n      }\n      this.data[i] = newRow;\n    }\n    this.columns -= 1;\n    return this;\n  }\n\n  addColumn(index, array) {\n    if (typeof array === 'undefined') {\n      array = index;\n      index = this.columns;\n    }\n    checkColumnIndex(this, index, true);\n    array = checkColumnVector(this, array);\n    for (let i = 0; i < this.rows; i++) {\n      const newRow = new Float64Array(this.columns + 1);\n      let j = 0;\n      for (; j < index; j++) {\n        newRow[j] = this.data[i][j];\n      }\n      newRow[j++] = array[i];\n      for (; j < this.columns + 1; j++) {\n        newRow[j] = this.data[i][j - 1];\n      }\n      this.data[i] = newRow;\n    }\n    this.columns += 1;\n    return this;\n  }\n}\n\ninstallMathOperations(AbstractMatrix, Matrix);\n\n/**\n * @typedef {0 | 1 | number | boolean} Mask\n */\n\nclass SymmetricMatrix extends AbstractMatrix {\n  /** @type {Matrix} */\n  #matrix;\n\n  get size() {\n    return this.#matrix.size;\n  }\n\n  get rows() {\n    return this.#matrix.rows;\n  }\n\n  get columns() {\n    return this.#matrix.columns;\n  }\n\n  get diagonalSize() {\n    return this.rows;\n  }\n\n  /**\n   * not the same as matrix.isSymmetric()\n   * Here is to check if it's instanceof SymmetricMatrix without bundling issues\n   *\n   * @param value\n   * @returns {boolean}\n   */\n  static isSymmetricMatrix(value) {\n    return Matrix.isMatrix(value) && value.klassType === 'SymmetricMatrix';\n  }\n\n  /**\n   * @param diagonalSize\n   * @return {SymmetricMatrix}\n   */\n  static zeros(diagonalSize) {\n    return new this(diagonalSize);\n  }\n\n  /**\n   * @param diagonalSize\n   * @return {SymmetricMatrix}\n   */\n  static ones(diagonalSize) {\n    return new this(diagonalSize).fill(1);\n  }\n\n  /**\n   * @param {number | AbstractMatrix | ArrayLike<ArrayLike<number>>} diagonalSize\n   * @return {this}\n   */\n  constructor(diagonalSize) {\n    super();\n\n    if (Matrix.isMatrix(diagonalSize)) {\n      if (!diagonalSize.isSymmetric()) {\n        throw new TypeError('not symmetric data');\n      }\n\n      this.#matrix = Matrix.copy(\n        diagonalSize,\n        new Matrix(diagonalSize.rows, diagonalSize.rows),\n      );\n    } else if (Number.isInteger(diagonalSize) && diagonalSize >= 0) {\n      this.#matrix = new Matrix(diagonalSize, diagonalSize);\n    } else {\n      this.#matrix = new Matrix(diagonalSize);\n\n      if (!this.isSymmetric()) {\n        throw new TypeError('not symmetric data');\n      }\n    }\n  }\n\n  clone() {\n    const matrix = new SymmetricMatrix(this.diagonalSize);\n\n    for (const [row, col, value] of this.upperRightEntries()) {\n      matrix.set(row, col, value);\n    }\n\n    return matrix;\n  }\n\n  toMatrix() {\n    return new Matrix(this);\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.#matrix.get(rowIndex, columnIndex);\n  }\n  set(rowIndex, columnIndex, value) {\n    // symmetric set\n    this.#matrix.set(rowIndex, columnIndex, value);\n    this.#matrix.set(columnIndex, rowIndex, value);\n\n    return this;\n  }\n\n  removeCross(index) {\n    // symmetric remove side\n    this.#matrix.removeRow(index);\n    this.#matrix.removeColumn(index);\n\n    return this;\n  }\n\n  addCross(index, array) {\n    if (array === undefined) {\n      array = index;\n      index = this.diagonalSize;\n    }\n\n    const row = array.slice();\n    row.splice(index, 1);\n\n    this.#matrix.addRow(index, row);\n    this.#matrix.addColumn(index, array);\n\n    return this;\n  }\n\n  /**\n   * @param {Mask[]} mask\n   */\n  applyMask(mask) {\n    if (mask.length !== this.diagonalSize) {\n      throw new RangeError('Mask size do not match with matrix size');\n    }\n\n    // prepare sides to remove from matrix from mask\n    /** @type {number[]} */\n    const sidesToRemove = [];\n    for (const [index, passthroughs] of mask.entries()) {\n      if (passthroughs) continue;\n      sidesToRemove.push(index);\n    }\n    // to remove from highest to lowest for no mutation shifting\n    sidesToRemove.reverse();\n\n    // remove sides\n    for (const sideIndex of sidesToRemove) {\n      this.removeCross(sideIndex);\n    }\n\n    return this;\n  }\n\n  /**\n   * Compact format upper-right corner of matrix\n   * iterate from left to right, from top to bottom.\n   *\n   * ```\n   *   A B C D\n   * A 1 2 3 4\n   * B 2 5 6 7\n   * C 3 6 8 9\n   * D 4 7 9 10\n   * ```\n   *\n   * will return compact 1D array `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`\n   *\n   * length is S(i=0, n=sideSize) => 10 for a 4 sideSized matrix\n   *\n   * @returns {number[]}\n   */\n  toCompact() {\n    const { diagonalSize } = this;\n\n    /** @type {number[]} */\n    const compact = new Array((diagonalSize * (diagonalSize + 1)) / 2);\n    for (let col = 0, row = 0, index = 0; index < compact.length; index++) {\n      compact[index] = this.get(row, col);\n\n      if (++col >= diagonalSize) col = ++row;\n    }\n\n    return compact;\n  }\n\n  /**\n   * @param {number[]} compact\n   * @return {SymmetricMatrix}\n   */\n  static fromCompact(compact) {\n    const compactSize = compact.length;\n    // compactSize = (sideSize * (sideSize + 1)) / 2\n    // https://mathsolver.microsoft.com/fr/solve-problem/y%20%3D%20%20x%20%60cdot%20%20%20%60frac%7B%20%20%60left(%20x%2B1%20%20%60right)%20%20%20%20%7D%7B%202%20%20%7D\n    // sideSize = (Sqrt(8  compactSize + 1) - 1) / 2\n    const diagonalSize = (Math.sqrt(8 * compactSize + 1) - 1) / 2;\n\n    if (!Number.isInteger(diagonalSize)) {\n      throw new TypeError(\n        `This array is not a compact representation of a Symmetric Matrix, ${JSON.stringify(\n          compact,\n        )}`,\n      );\n    }\n\n    const matrix = new SymmetricMatrix(diagonalSize);\n    for (let col = 0, row = 0, index = 0; index < compactSize; index++) {\n      matrix.set(col, row, compact[index]);\n      if (++col >= diagonalSize) col = ++row;\n    }\n\n    return matrix;\n  }\n\n  /**\n   * half iterator upper-right-corner from left to right, from top to bottom\n   * yield [row, column, value]\n   *\n   * @returns {Generator<[number, number, number], void, void>}\n   */\n  *upperRightEntries() {\n    for (let row = 0, col = 0; row < this.diagonalSize; void 0) {\n      const value = this.get(row, col);\n\n      yield [row, col, value];\n\n      // at the end of row, move cursor to next row at diagonal position\n      if (++col >= this.diagonalSize) col = ++row;\n    }\n  }\n\n  /**\n   * half iterator upper-right-corner from left to right, from top to bottom\n   * yield value\n   *\n   * @returns {Generator<[number, number, number], void, void>}\n   */\n  *upperRightValues() {\n    for (let row = 0, col = 0; row < this.diagonalSize; void 0) {\n      const value = this.get(row, col);\n\n      yield value;\n\n      // at the end of row, move cursor to next row at diagonal position\n      if (++col >= this.diagonalSize) col = ++row;\n    }\n  }\n}\nSymmetricMatrix.prototype.klassType = 'SymmetricMatrix';\n\nclass DistanceMatrix extends SymmetricMatrix {\n  /**\n   * not the same as matrix.isSymmetric()\n   * Here is to check if it's instanceof SymmetricMatrix without bundling issues\n   *\n   * @param value\n   * @returns {boolean}\n   */\n  static isDistanceMatrix(value) {\n    return (\n      SymmetricMatrix.isSymmetricMatrix(value) &&\n      value.klassSubType === 'DistanceMatrix'\n    );\n  }\n\n  constructor(sideSize) {\n    super(sideSize);\n\n    if (!this.isDistance()) {\n      throw new TypeError('Provided arguments do no produce a distance matrix');\n    }\n  }\n\n  set(rowIndex, columnIndex, value) {\n    // distance matrix diagonal is 0\n    if (rowIndex === columnIndex) value = 0;\n\n    return super.set(rowIndex, columnIndex, value);\n  }\n\n  addCross(index, array) {\n    if (array === undefined) {\n      array = index;\n      index = this.diagonalSize;\n    }\n\n    // ensure distance\n    array = array.slice();\n    array[index] = 0;\n\n    return super.addCross(index, array);\n  }\n\n  toSymmetricMatrix() {\n    return new SymmetricMatrix(this);\n  }\n\n  clone() {\n    const matrix = new DistanceMatrix(this.diagonalSize);\n\n    for (const [row, col, value] of this.upperRightEntries()) {\n      if (row === col) continue;\n      matrix.set(row, col, value);\n    }\n\n    return matrix;\n  }\n\n  /**\n   * Compact format upper-right corner of matrix\n   * no diagonal (only zeros)\n   * iterable from left to right, from top to bottom.\n   *\n   * ```\n   *   A B C D\n   * A 0 1 2 3\n   * B 1 0 4 5\n   * C 2 4 0 6\n   * D 3 5 6 0\n   * ```\n   *\n   * will return compact 1D array `[1, 2, 3, 4, 5, 6]`\n   *\n   * length is S(i=0, n=sideSize-1) => 6 for a 4 side sized matrix\n   *\n   * @returns {number[]}\n   */\n  toCompact() {\n    const { diagonalSize } = this;\n    const compactLength = ((diagonalSize - 1) * diagonalSize) / 2;\n\n    /** @type {number[]} */\n    const compact = new Array(compactLength);\n    for (let col = 1, row = 0, index = 0; index < compact.length; index++) {\n      compact[index] = this.get(row, col);\n\n      if (++col >= diagonalSize) col = ++row + 1;\n    }\n\n    return compact;\n  }\n\n  /**\n   * @param {number[]} compact\n   */\n  static fromCompact(compact) {\n    const compactSize = compact.length;\n\n    if (compactSize === 0) {\n      return new this(0);\n    }\n\n    // compactSize in Natural integer range ]0;]\n    // compactSize = (sideSize * (sideSize - 1)) / 2\n    // sideSize = (Sqrt(8  compactSize + 1) + 1) / 2\n    const diagonalSize = (Math.sqrt(8 * compactSize + 1) + 1) / 2;\n\n    if (!Number.isInteger(diagonalSize)) {\n      throw new TypeError(\n        `This array is not a compact representation of a DistanceMatrix, ${JSON.stringify(\n          compact,\n        )}`,\n      );\n    }\n\n    const matrix = new this(diagonalSize);\n    for (let col = 1, row = 0, index = 0; index < compactSize; index++) {\n      matrix.set(col, row, compact[index]);\n      if (++col >= diagonalSize) col = ++row + 1;\n    }\n\n    return matrix;\n  }\n}\nDistanceMatrix.prototype.klassSubType = 'DistanceMatrix';\n\nclass BaseView extends AbstractMatrix {\n  constructor(matrix, rows, columns) {\n    super();\n    this.matrix = matrix;\n    this.rows = rows;\n    this.columns = columns;\n  }\n}\n\nclass MatrixColumnView extends BaseView {\n  constructor(matrix, column) {\n    checkColumnIndex(matrix, column);\n    super(matrix, matrix.rows, 1);\n    this.column = column;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.matrix.set(rowIndex, this.column, value);\n    return this;\n  }\n\n  get(rowIndex) {\n    return this.matrix.get(rowIndex, this.column);\n  }\n}\n\nclass MatrixColumnSelectionView extends BaseView {\n  constructor(matrix, columnIndices) {\n    checkColumnIndices(matrix, columnIndices);\n    super(matrix, matrix.rows, columnIndices.length);\n    this.columnIndices = columnIndices;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.matrix.set(rowIndex, this.columnIndices[columnIndex], value);\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.matrix.get(rowIndex, this.columnIndices[columnIndex]);\n  }\n}\n\nclass MatrixFlipColumnView extends BaseView {\n  constructor(matrix) {\n    super(matrix, matrix.rows, matrix.columns);\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.matrix.set(rowIndex, this.columns - columnIndex - 1, value);\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.matrix.get(rowIndex, this.columns - columnIndex - 1);\n  }\n}\n\nclass MatrixFlipRowView extends BaseView {\n  constructor(matrix) {\n    super(matrix, matrix.rows, matrix.columns);\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.matrix.set(this.rows - rowIndex - 1, columnIndex, value);\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.matrix.get(this.rows - rowIndex - 1, columnIndex);\n  }\n}\n\nclass MatrixRowView extends BaseView {\n  constructor(matrix, row) {\n    checkRowIndex(matrix, row);\n    super(matrix, 1, matrix.columns);\n    this.row = row;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.matrix.set(this.row, columnIndex, value);\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.matrix.get(this.row, columnIndex);\n  }\n}\n\nclass MatrixRowSelectionView extends BaseView {\n  constructor(matrix, rowIndices) {\n    checkRowIndices(matrix, rowIndices);\n    super(matrix, rowIndices.length, matrix.columns);\n    this.rowIndices = rowIndices;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.matrix.set(this.rowIndices[rowIndex], columnIndex, value);\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.matrix.get(this.rowIndices[rowIndex], columnIndex);\n  }\n}\n\nclass MatrixSelectionView extends BaseView {\n  constructor(matrix, rowIndices, columnIndices) {\n    checkRowIndices(matrix, rowIndices);\n    checkColumnIndices(matrix, columnIndices);\n    super(matrix, rowIndices.length, columnIndices.length);\n    this.rowIndices = rowIndices;\n    this.columnIndices = columnIndices;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.matrix.set(\n      this.rowIndices[rowIndex],\n      this.columnIndices[columnIndex],\n      value,\n    );\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.matrix.get(\n      this.rowIndices[rowIndex],\n      this.columnIndices[columnIndex],\n    );\n  }\n}\n\nclass MatrixSubView extends BaseView {\n  constructor(matrix, startRow, endRow, startColumn, endColumn) {\n    checkRange(matrix, startRow, endRow, startColumn, endColumn);\n    super(matrix, endRow - startRow + 1, endColumn - startColumn + 1);\n    this.startRow = startRow;\n    this.startColumn = startColumn;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.matrix.set(\n      this.startRow + rowIndex,\n      this.startColumn + columnIndex,\n      value,\n    );\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.matrix.get(\n      this.startRow + rowIndex,\n      this.startColumn + columnIndex,\n    );\n  }\n}\n\nclass MatrixTransposeView extends BaseView {\n  constructor(matrix) {\n    super(matrix, matrix.columns, matrix.rows);\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.matrix.set(columnIndex, rowIndex, value);\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.matrix.get(columnIndex, rowIndex);\n  }\n}\n\nclass WrapperMatrix1D extends AbstractMatrix {\n  constructor(data, options = {}) {\n    const { rows = 1 } = options;\n\n    if (data.length % rows !== 0) {\n      throw new Error('the data length is not divisible by the number of rows');\n    }\n    super();\n    this.rows = rows;\n    this.columns = data.length / rows;\n    this.data = data;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    let index = this._calculateIndex(rowIndex, columnIndex);\n    this.data[index] = value;\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    let index = this._calculateIndex(rowIndex, columnIndex);\n    return this.data[index];\n  }\n\n  _calculateIndex(row, column) {\n    return row * this.columns + column;\n  }\n}\n\nclass WrapperMatrix2D extends AbstractMatrix {\n  constructor(data) {\n    super();\n    this.data = data;\n    this.rows = data.length;\n    this.columns = data[0].length;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.data[rowIndex][columnIndex] = value;\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.data[rowIndex][columnIndex];\n  }\n}\n\nfunction wrap(array, options) {\n  if (isAnyArray.isAnyArray(array)) {\n    if (array[0] && isAnyArray.isAnyArray(array[0])) {\n      return new WrapperMatrix2D(array);\n    } else {\n      return new WrapperMatrix1D(array, options);\n    }\n  } else {\n    throw new Error('the argument is not an array');\n  }\n}\n\nclass LuDecomposition {\n  constructor(matrix) {\n    matrix = WrapperMatrix2D.checkMatrix(matrix);\n\n    let lu = matrix.clone();\n    let rows = lu.rows;\n    let columns = lu.columns;\n    let pivotVector = new Float64Array(rows);\n    let pivotSign = 1;\n    let i, j, k, p, s, t, v;\n    let LUcolj, kmax;\n\n    for (i = 0; i < rows; i++) {\n      pivotVector[i] = i;\n    }\n\n    LUcolj = new Float64Array(rows);\n\n    for (j = 0; j < columns; j++) {\n      for (i = 0; i < rows; i++) {\n        LUcolj[i] = lu.get(i, j);\n      }\n\n      for (i = 0; i < rows; i++) {\n        kmax = Math.min(i, j);\n        s = 0;\n        for (k = 0; k < kmax; k++) {\n          s += lu.get(i, k) * LUcolj[k];\n        }\n        LUcolj[i] -= s;\n        lu.set(i, j, LUcolj[i]);\n      }\n\n      p = j;\n      for (i = j + 1; i < rows; i++) {\n        if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {\n          p = i;\n        }\n      }\n\n      if (p !== j) {\n        for (k = 0; k < columns; k++) {\n          t = lu.get(p, k);\n          lu.set(p, k, lu.get(j, k));\n          lu.set(j, k, t);\n        }\n\n        v = pivotVector[p];\n        pivotVector[p] = pivotVector[j];\n        pivotVector[j] = v;\n\n        pivotSign = -pivotSign;\n      }\n\n      if (j < rows && lu.get(j, j) !== 0) {\n        for (i = j + 1; i < rows; i++) {\n          lu.set(i, j, lu.get(i, j) / lu.get(j, j));\n        }\n      }\n    }\n\n    this.LU = lu;\n    this.pivotVector = pivotVector;\n    this.pivotSign = pivotSign;\n  }\n\n  isSingular() {\n    let data = this.LU;\n    let col = data.columns;\n    for (let j = 0; j < col; j++) {\n      if (data.get(j, j) === 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  solve(value) {\n    value = Matrix.checkMatrix(value);\n\n    let lu = this.LU;\n    let rows = lu.rows;\n\n    if (rows !== value.rows) {\n      throw new Error('Invalid matrix dimensions');\n    }\n    if (this.isSingular()) {\n      throw new Error('LU matrix is singular');\n    }\n\n    let count = value.columns;\n    let X = value.subMatrixRow(this.pivotVector, 0, count - 1);\n    let columns = lu.columns;\n    let i, j, k;\n\n    for (k = 0; k < columns; k++) {\n      for (i = k + 1; i < columns; i++) {\n        for (j = 0; j < count; j++) {\n          X.set(i, j, X.get(i, j) - X.get(k, j) * lu.get(i, k));\n        }\n      }\n    }\n    for (k = columns - 1; k >= 0; k--) {\n      for (j = 0; j < count; j++) {\n        X.set(k, j, X.get(k, j) / lu.get(k, k));\n      }\n      for (i = 0; i < k; i++) {\n        for (j = 0; j < count; j++) {\n          X.set(i, j, X.get(i, j) - X.get(k, j) * lu.get(i, k));\n        }\n      }\n    }\n    return X;\n  }\n\n  get determinant() {\n    let data = this.LU;\n    if (!data.isSquare()) {\n      throw new Error('Matrix must be square');\n    }\n    let determinant = this.pivotSign;\n    let col = data.columns;\n    for (let j = 0; j < col; j++) {\n      determinant *= data.get(j, j);\n    }\n    return determinant;\n  }\n\n  get lowerTriangularMatrix() {\n    let data = this.LU;\n    let rows = data.rows;\n    let columns = data.columns;\n    let X = new Matrix(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        if (i > j) {\n          X.set(i, j, data.get(i, j));\n        } else if (i === j) {\n          X.set(i, j, 1);\n        } else {\n          X.set(i, j, 0);\n        }\n      }\n    }\n    return X;\n  }\n\n  get upperTriangularMatrix() {\n    let data = this.LU;\n    let rows = data.rows;\n    let columns = data.columns;\n    let X = new Matrix(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        if (i <= j) {\n          X.set(i, j, data.get(i, j));\n        } else {\n          X.set(i, j, 0);\n        }\n      }\n    }\n    return X;\n  }\n\n  get pivotPermutationVector() {\n    return Array.from(this.pivotVector);\n  }\n}\n\nfunction hypotenuse(a, b) {\n  let r = 0;\n  if (Math.abs(a) > Math.abs(b)) {\n    r = b / a;\n    return Math.abs(a) * Math.sqrt(1 + r * r);\n  }\n  if (b !== 0) {\n    r = a / b;\n    return Math.abs(b) * Math.sqrt(1 + r * r);\n  }\n  return 0;\n}\n\nclass QrDecomposition {\n  constructor(value) {\n    value = WrapperMatrix2D.checkMatrix(value);\n\n    let qr = value.clone();\n    let m = value.rows;\n    let n = value.columns;\n    let rdiag = new Float64Array(n);\n    let i, j, k, s;\n\n    for (k = 0; k < n; k++) {\n      let nrm = 0;\n      for (i = k; i < m; i++) {\n        nrm = hypotenuse(nrm, qr.get(i, k));\n      }\n      if (nrm !== 0) {\n        if (qr.get(k, k) < 0) {\n          nrm = -nrm;\n        }\n        for (i = k; i < m; i++) {\n          qr.set(i, k, qr.get(i, k) / nrm);\n        }\n        qr.set(k, k, qr.get(k, k) + 1);\n        for (j = k + 1; j < n; j++) {\n          s = 0;\n          for (i = k; i < m; i++) {\n            s += qr.get(i, k) * qr.get(i, j);\n          }\n          s = -s / qr.get(k, k);\n          for (i = k; i < m; i++) {\n            qr.set(i, j, qr.get(i, j) + s * qr.get(i, k));\n          }\n        }\n      }\n      rdiag[k] = -nrm;\n    }\n\n    this.QR = qr;\n    this.Rdiag = rdiag;\n  }\n\n  solve(value) {\n    value = Matrix.checkMatrix(value);\n\n    let qr = this.QR;\n    let m = qr.rows;\n\n    if (value.rows !== m) {\n      throw new Error('Matrix row dimensions must agree');\n    }\n    if (!this.isFullRank()) {\n      throw new Error('Matrix is rank deficient');\n    }\n\n    let count = value.columns;\n    let X = value.clone();\n    let n = qr.columns;\n    let i, j, k, s;\n\n    for (k = 0; k < n; k++) {\n      for (j = 0; j < count; j++) {\n        s = 0;\n        for (i = k; i < m; i++) {\n          s += qr.get(i, k) * X.get(i, j);\n        }\n        s = -s / qr.get(k, k);\n        for (i = k; i < m; i++) {\n          X.set(i, j, X.get(i, j) + s * qr.get(i, k));\n        }\n      }\n    }\n    for (k = n - 1; k >= 0; k--) {\n      for (j = 0; j < count; j++) {\n        X.set(k, j, X.get(k, j) / this.Rdiag[k]);\n      }\n      for (i = 0; i < k; i++) {\n        for (j = 0; j < count; j++) {\n          X.set(i, j, X.get(i, j) - X.get(k, j) * qr.get(i, k));\n        }\n      }\n    }\n\n    return X.subMatrix(0, n - 1, 0, count - 1);\n  }\n\n  isFullRank() {\n    let columns = this.QR.columns;\n    for (let i = 0; i < columns; i++) {\n      if (this.Rdiag[i] === 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  get upperTriangularMatrix() {\n    let qr = this.QR;\n    let n = qr.columns;\n    let X = new Matrix(n, n);\n    let i, j;\n    for (i = 0; i < n; i++) {\n      for (j = 0; j < n; j++) {\n        if (i < j) {\n          X.set(i, j, qr.get(i, j));\n        } else if (i === j) {\n          X.set(i, j, this.Rdiag[i]);\n        } else {\n          X.set(i, j, 0);\n        }\n      }\n    }\n    return X;\n  }\n\n  get orthogonalMatrix() {\n    let qr = this.QR;\n    let rows = qr.rows;\n    let columns = qr.columns;\n    let X = new Matrix(rows, columns);\n    let i, j, k, s;\n\n    for (k = columns - 1; k >= 0; k--) {\n      for (i = 0; i < rows; i++) {\n        X.set(i, k, 0);\n      }\n      X.set(k, k, 1);\n      for (j = k; j < columns; j++) {\n        if (qr.get(k, k) !== 0) {\n          s = 0;\n          for (i = k; i < rows; i++) {\n            s += qr.get(i, k) * X.get(i, j);\n          }\n\n          s = -s / qr.get(k, k);\n\n          for (i = k; i < rows; i++) {\n            X.set(i, j, X.get(i, j) + s * qr.get(i, k));\n          }\n        }\n      }\n    }\n    return X;\n  }\n}\n\nclass SingularValueDecomposition {\n  constructor(value, options = {}) {\n    value = WrapperMatrix2D.checkMatrix(value);\n\n    if (value.isEmpty()) {\n      throw new Error('Matrix must be non-empty');\n    }\n\n    let m = value.rows;\n    let n = value.columns;\n\n    const {\n      computeLeftSingularVectors = true,\n      computeRightSingularVectors = true,\n      autoTranspose = false,\n    } = options;\n\n    let wantu = Boolean(computeLeftSingularVectors);\n    let wantv = Boolean(computeRightSingularVectors);\n\n    let swapped = false;\n    let a;\n    if (m < n) {\n      if (!autoTranspose) {\n        a = value.clone();\n        // eslint-disable-next-line no-console\n        console.warn(\n          'Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose',\n        );\n      } else {\n        a = value.transpose();\n        m = a.rows;\n        n = a.columns;\n        swapped = true;\n        let aux = wantu;\n        wantu = wantv;\n        wantv = aux;\n      }\n    } else {\n      a = value.clone();\n    }\n\n    let nu = Math.min(m, n);\n    let ni = Math.min(m + 1, n);\n    let s = new Float64Array(ni);\n    let U = new Matrix(m, nu);\n    let V = new Matrix(n, n);\n\n    let e = new Float64Array(n);\n    let work = new Float64Array(m);\n\n    let si = new Float64Array(ni);\n    for (let i = 0; i < ni; i++) si[i] = i;\n\n    let nct = Math.min(m - 1, n);\n    let nrt = Math.max(0, Math.min(n - 2, m));\n    let mrc = Math.max(nct, nrt);\n\n    for (let k = 0; k < mrc; k++) {\n      if (k < nct) {\n        s[k] = 0;\n        for (let i = k; i < m; i++) {\n          s[k] = hypotenuse(s[k], a.get(i, k));\n        }\n        if (s[k] !== 0) {\n          if (a.get(k, k) < 0) {\n            s[k] = -s[k];\n          }\n          for (let i = k; i < m; i++) {\n            a.set(i, k, a.get(i, k) / s[k]);\n          }\n          a.set(k, k, a.get(k, k) + 1);\n        }\n        s[k] = -s[k];\n      }\n\n      for (let j = k + 1; j < n; j++) {\n        if (k < nct && s[k] !== 0) {\n          let t = 0;\n          for (let i = k; i < m; i++) {\n            t += a.get(i, k) * a.get(i, j);\n          }\n          t = -t / a.get(k, k);\n          for (let i = k; i < m; i++) {\n            a.set(i, j, a.get(i, j) + t * a.get(i, k));\n          }\n        }\n        e[j] = a.get(k, j);\n      }\n\n      if (wantu && k < nct) {\n        for (let i = k; i < m; i++) {\n          U.set(i, k, a.get(i, k));\n        }\n      }\n\n      if (k < nrt) {\n        e[k] = 0;\n        for (let i = k + 1; i < n; i++) {\n          e[k] = hypotenuse(e[k], e[i]);\n        }\n        if (e[k] !== 0) {\n          if (e[k + 1] < 0) {\n            e[k] = 0 - e[k];\n          }\n          for (let i = k + 1; i < n; i++) {\n            e[i] /= e[k];\n          }\n          e[k + 1] += 1;\n        }\n        e[k] = -e[k];\n        if (k + 1 < m && e[k] !== 0) {\n          for (let i = k + 1; i < m; i++) {\n            work[i] = 0;\n          }\n          for (let i = k + 1; i < m; i++) {\n            for (let j = k + 1; j < n; j++) {\n              work[i] += e[j] * a.get(i, j);\n            }\n          }\n          for (let j = k + 1; j < n; j++) {\n            let t = -e[j] / e[k + 1];\n            for (let i = k + 1; i < m; i++) {\n              a.set(i, j, a.get(i, j) + t * work[i]);\n            }\n          }\n        }\n        if (wantv) {\n          for (let i = k + 1; i < n; i++) {\n            V.set(i, k, e[i]);\n          }\n        }\n      }\n    }\n\n    let p = Math.min(n, m + 1);\n    if (nct < n) {\n      s[nct] = a.get(nct, nct);\n    }\n    if (m < p) {\n      s[p - 1] = 0;\n    }\n    if (nrt + 1 < p) {\n      e[nrt] = a.get(nrt, p - 1);\n    }\n    e[p - 1] = 0;\n\n    if (wantu) {\n      for (let j = nct; j < nu; j++) {\n        for (let i = 0; i < m; i++) {\n          U.set(i, j, 0);\n        }\n        U.set(j, j, 1);\n      }\n      for (let k = nct - 1; k >= 0; k--) {\n        if (s[k] !== 0) {\n          for (let j = k + 1; j < nu; j++) {\n            let t = 0;\n            for (let i = k; i < m; i++) {\n              t += U.get(i, k) * U.get(i, j);\n            }\n            t = -t / U.get(k, k);\n            for (let i = k; i < m; i++) {\n              U.set(i, j, U.get(i, j) + t * U.get(i, k));\n            }\n          }\n          for (let i = k; i < m; i++) {\n            U.set(i, k, -U.get(i, k));\n          }\n          U.set(k, k, 1 + U.get(k, k));\n          for (let i = 0; i < k - 1; i++) {\n            U.set(i, k, 0);\n          }\n        } else {\n          for (let i = 0; i < m; i++) {\n            U.set(i, k, 0);\n          }\n          U.set(k, k, 1);\n        }\n      }\n    }\n\n    if (wantv) {\n      for (let k = n - 1; k >= 0; k--) {\n        if (k < nrt && e[k] !== 0) {\n          for (let j = k + 1; j < n; j++) {\n            let t = 0;\n            for (let i = k + 1; i < n; i++) {\n              t += V.get(i, k) * V.get(i, j);\n            }\n            t = -t / V.get(k + 1, k);\n            for (let i = k + 1; i < n; i++) {\n              V.set(i, j, V.get(i, j) + t * V.get(i, k));\n            }\n          }\n        }\n        for (let i = 0; i < n; i++) {\n          V.set(i, k, 0);\n        }\n        V.set(k, k, 1);\n      }\n    }\n\n    let pp = p - 1;\n    let eps = Number.EPSILON;\n    while (p > 0) {\n      let k, kase;\n      for (k = p - 2; k >= -1; k--) {\n        if (k === -1) {\n          break;\n        }\n        const alpha =\n          Number.MIN_VALUE + eps * Math.abs(s[k] + Math.abs(s[k + 1]));\n        if (Math.abs(e[k]) <= alpha || Number.isNaN(e[k])) {\n          e[k] = 0;\n          break;\n        }\n      }\n      if (k === p - 2) {\n        kase = 4;\n      } else {\n        let ks;\n        for (ks = p - 1; ks >= k; ks--) {\n          if (ks === k) {\n            break;\n          }\n          let t =\n            (ks !== p ? Math.abs(e[ks]) : 0) +\n            (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);\n          if (Math.abs(s[ks]) <= eps * t) {\n            s[ks] = 0;\n            break;\n          }\n        }\n        if (ks === k) {\n          kase = 3;\n        } else if (ks === p - 1) {\n          kase = 1;\n        } else {\n          kase = 2;\n          k = ks;\n        }\n      }\n\n      k++;\n\n      switch (kase) {\n        case 1: {\n          let f = e[p - 2];\n          e[p - 2] = 0;\n          for (let j = p - 2; j >= k; j--) {\n            let t = hypotenuse(s[j], f);\n            let cs = s[j] / t;\n            let sn = f / t;\n            s[j] = t;\n            if (j !== k) {\n              f = -sn * e[j - 1];\n              e[j - 1] = cs * e[j - 1];\n            }\n            if (wantv) {\n              for (let i = 0; i < n; i++) {\n                t = cs * V.get(i, j) + sn * V.get(i, p - 1);\n                V.set(i, p - 1, -sn * V.get(i, j) + cs * V.get(i, p - 1));\n                V.set(i, j, t);\n              }\n            }\n          }\n          break;\n        }\n        case 2: {\n          let f = e[k - 1];\n          e[k - 1] = 0;\n          for (let j = k; j < p; j++) {\n            let t = hypotenuse(s[j], f);\n            let cs = s[j] / t;\n            let sn = f / t;\n            s[j] = t;\n            f = -sn * e[j];\n            e[j] = cs * e[j];\n            if (wantu) {\n              for (let i = 0; i < m; i++) {\n                t = cs * U.get(i, j) + sn * U.get(i, k - 1);\n                U.set(i, k - 1, -sn * U.get(i, j) + cs * U.get(i, k - 1));\n                U.set(i, j, t);\n              }\n            }\n          }\n          break;\n        }\n        case 3: {\n          const scale = Math.max(\n            Math.abs(s[p - 1]),\n            Math.abs(s[p - 2]),\n            Math.abs(e[p - 2]),\n            Math.abs(s[k]),\n            Math.abs(e[k]),\n          );\n          const sp = s[p - 1] / scale;\n          const spm1 = s[p - 2] / scale;\n          const epm1 = e[p - 2] / scale;\n          const sk = s[k] / scale;\n          const ek = e[k] / scale;\n          const b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;\n          const c = sp * epm1 * (sp * epm1);\n          let shift = 0;\n          if (b !== 0 || c !== 0) {\n            if (b < 0) {\n              shift = 0 - Math.sqrt(b * b + c);\n            } else {\n              shift = Math.sqrt(b * b + c);\n            }\n            shift = c / (b + shift);\n          }\n          let f = (sk + sp) * (sk - sp) + shift;\n          let g = sk * ek;\n          for (let j = k; j < p - 1; j++) {\n            let t = hypotenuse(f, g);\n            if (t === 0) t = Number.MIN_VALUE;\n            let cs = f / t;\n            let sn = g / t;\n            if (j !== k) {\n              e[j - 1] = t;\n            }\n            f = cs * s[j] + sn * e[j];\n            e[j] = cs * e[j] - sn * s[j];\n            g = sn * s[j + 1];\n            s[j + 1] = cs * s[j + 1];\n            if (wantv) {\n              for (let i = 0; i < n; i++) {\n                t = cs * V.get(i, j) + sn * V.get(i, j + 1);\n                V.set(i, j + 1, -sn * V.get(i, j) + cs * V.get(i, j + 1));\n                V.set(i, j, t);\n              }\n            }\n            t = hypotenuse(f, g);\n            if (t === 0) t = Number.MIN_VALUE;\n            cs = f / t;\n            sn = g / t;\n            s[j] = t;\n            f = cs * e[j] + sn * s[j + 1];\n            s[j + 1] = -sn * e[j] + cs * s[j + 1];\n            g = sn * e[j + 1];\n            e[j + 1] = cs * e[j + 1];\n            if (wantu && j < m - 1) {\n              for (let i = 0; i < m; i++) {\n                t = cs * U.get(i, j) + sn * U.get(i, j + 1);\n                U.set(i, j + 1, -sn * U.get(i, j) + cs * U.get(i, j + 1));\n                U.set(i, j, t);\n              }\n            }\n          }\n          e[p - 2] = f;\n          break;\n        }\n        case 4: {\n          if (s[k] <= 0) {\n            s[k] = s[k] < 0 ? -s[k] : 0;\n            if (wantv) {\n              for (let i = 0; i <= pp; i++) {\n                V.set(i, k, -V.get(i, k));\n              }\n            }\n          }\n          while (k < pp) {\n            if (s[k] >= s[k + 1]) {\n              break;\n            }\n            let t = s[k];\n            s[k] = s[k + 1];\n            s[k + 1] = t;\n            if (wantv && k < n - 1) {\n              for (let i = 0; i < n; i++) {\n                t = V.get(i, k + 1);\n                V.set(i, k + 1, V.get(i, k));\n                V.set(i, k, t);\n              }\n            }\n            if (wantu && k < m - 1) {\n              for (let i = 0; i < m; i++) {\n                t = U.get(i, k + 1);\n                U.set(i, k + 1, U.get(i, k));\n                U.set(i, k, t);\n              }\n            }\n            k++;\n          }\n          p--;\n          break;\n        }\n        // no default\n      }\n    }\n\n    if (swapped) {\n      let tmp = V;\n      V = U;\n      U = tmp;\n    }\n\n    this.m = m;\n    this.n = n;\n    this.s = s;\n    this.U = U;\n    this.V = V;\n  }\n\n  solve(value) {\n    let Y = value;\n    let e = this.threshold;\n    let scols = this.s.length;\n    let Ls = Matrix.zeros(scols, scols);\n\n    for (let i = 0; i < scols; i++) {\n      if (Math.abs(this.s[i]) <= e) {\n        Ls.set(i, i, 0);\n      } else {\n        Ls.set(i, i, 1 / this.s[i]);\n      }\n    }\n\n    let U = this.U;\n    let V = this.rightSingularVectors;\n\n    let VL = V.mmul(Ls);\n    let vrows = V.rows;\n    let urows = U.rows;\n    let VLU = Matrix.zeros(vrows, urows);\n\n    for (let i = 0; i < vrows; i++) {\n      for (let j = 0; j < urows; j++) {\n        let sum = 0;\n        for (let k = 0; k < scols; k++) {\n          sum += VL.get(i, k) * U.get(j, k);\n        }\n        VLU.set(i, j, sum);\n      }\n    }\n\n    return VLU.mmul(Y);\n  }\n\n  solveForDiagonal(value) {\n    return this.solve(Matrix.diag(value));\n  }\n\n  inverse() {\n    let V = this.V;\n    let e = this.threshold;\n    let vrows = V.rows;\n    let vcols = V.columns;\n    let X = new Matrix(vrows, this.s.length);\n\n    for (let i = 0; i < vrows; i++) {\n      for (let j = 0; j < vcols; j++) {\n        if (Math.abs(this.s[j]) > e) {\n          X.set(i, j, V.get(i, j) / this.s[j]);\n        }\n      }\n    }\n\n    let U = this.U;\n\n    let urows = U.rows;\n    let ucols = U.columns;\n    let Y = new Matrix(vrows, urows);\n\n    for (let i = 0; i < vrows; i++) {\n      for (let j = 0; j < urows; j++) {\n        let sum = 0;\n        for (let k = 0; k < ucols; k++) {\n          sum += X.get(i, k) * U.get(j, k);\n        }\n        Y.set(i, j, sum);\n      }\n    }\n\n    return Y;\n  }\n\n  get condition() {\n    return this.s[0] / this.s[Math.min(this.m, this.n) - 1];\n  }\n\n  get norm2() {\n    return this.s[0];\n  }\n\n  get rank() {\n    let tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;\n    let r = 0;\n    let s = this.s;\n    for (let i = 0, ii = s.length; i < ii; i++) {\n      if (s[i] > tol) {\n        r++;\n      }\n    }\n    return r;\n  }\n\n  get diagonal() {\n    return Array.from(this.s);\n  }\n\n  get threshold() {\n    return (Number.EPSILON / 2) * Math.max(this.m, this.n) * this.s[0];\n  }\n\n  get leftSingularVectors() {\n    return this.U;\n  }\n\n  get rightSingularVectors() {\n    return this.V;\n  }\n\n  get diagonalMatrix() {\n    return Matrix.diag(this.s);\n  }\n}\n\nfunction inverse(matrix, useSVD = false) {\n  matrix = WrapperMatrix2D.checkMatrix(matrix);\n  if (useSVD) {\n    return new SingularValueDecomposition(matrix).inverse();\n  } else {\n    return solve(matrix, Matrix.eye(matrix.rows));\n  }\n}\n\nfunction solve(leftHandSide, rightHandSide, useSVD = false) {\n  leftHandSide = WrapperMatrix2D.checkMatrix(leftHandSide);\n  rightHandSide = WrapperMatrix2D.checkMatrix(rightHandSide);\n  if (useSVD) {\n    return new SingularValueDecomposition(leftHandSide).solve(rightHandSide);\n  } else {\n    return leftHandSide.isSquare()\n      ? new LuDecomposition(leftHandSide).solve(rightHandSide)\n      : new QrDecomposition(leftHandSide).solve(rightHandSide);\n  }\n}\n\nfunction determinant(matrix) {\n  matrix = Matrix.checkMatrix(matrix);\n  if (matrix.isSquare()) {\n    if (matrix.columns === 0) {\n      return 1;\n    }\n\n    let a, b, c, d;\n    if (matrix.columns === 2) {\n      // 2 x 2 matrix\n      a = matrix.get(0, 0);\n      b = matrix.get(0, 1);\n      c = matrix.get(1, 0);\n      d = matrix.get(1, 1);\n\n      return a * d - b * c;\n    } else if (matrix.columns === 3) {\n      // 3 x 3 matrix\n      let subMatrix0, subMatrix1, subMatrix2;\n      subMatrix0 = new MatrixSelectionView(matrix, [1, 2], [1, 2]);\n      subMatrix1 = new MatrixSelectionView(matrix, [1, 2], [0, 2]);\n      subMatrix2 = new MatrixSelectionView(matrix, [1, 2], [0, 1]);\n      a = matrix.get(0, 0);\n      b = matrix.get(0, 1);\n      c = matrix.get(0, 2);\n\n      return (\n        a * determinant(subMatrix0) -\n        b * determinant(subMatrix1) +\n        c * determinant(subMatrix2)\n      );\n    } else {\n      // general purpose determinant using the LU decomposition\n      return new LuDecomposition(matrix).determinant;\n    }\n  } else {\n    throw Error('determinant can only be calculated for a square matrix');\n  }\n}\n\nfunction xrange(n, exception) {\n  let range = [];\n  for (let i = 0; i < n; i++) {\n    if (i !== exception) {\n      range.push(i);\n    }\n  }\n  return range;\n}\n\nfunction dependenciesOneRow(\n  error,\n  matrix,\n  index,\n  thresholdValue = 10e-10,\n  thresholdError = 10e-10,\n) {\n  if (error > thresholdError) {\n    return new Array(matrix.rows + 1).fill(0);\n  } else {\n    let returnArray = matrix.addRow(index, [0]);\n    for (let i = 0; i < returnArray.rows; i++) {\n      if (Math.abs(returnArray.get(i, 0)) < thresholdValue) {\n        returnArray.set(i, 0, 0);\n      }\n    }\n    return returnArray.to1DArray();\n  }\n}\n\nfunction linearDependencies(matrix, options = {}) {\n  const { thresholdValue = 10e-10, thresholdError = 10e-10 } = options;\n  matrix = Matrix.checkMatrix(matrix);\n\n  let n = matrix.rows;\n  let results = new Matrix(n, n);\n\n  for (let i = 0; i < n; i++) {\n    let b = Matrix.columnVector(matrix.getRow(i));\n    let Abis = matrix.subMatrixRow(xrange(n, i)).transpose();\n    let svd = new SingularValueDecomposition(Abis);\n    let x = svd.solve(b);\n    let error = Matrix.sub(b, Abis.mmul(x)).abs().max();\n    results.setRow(\n      i,\n      dependenciesOneRow(error, x, i, thresholdValue, thresholdError),\n    );\n  }\n  return results;\n}\n\nfunction pseudoInverse(matrix, threshold = Number.EPSILON) {\n  matrix = Matrix.checkMatrix(matrix);\n  if (matrix.isEmpty()) {\n    // with a zero dimension, the pseudo-inverse is the transpose, since all 0xn and nx0 matrices are singular\n    // (0xn)*(nx0)*(0xn) = 0xn\n    // (nx0)*(0xn)*(nx0) = nx0\n    return matrix.transpose();\n  }\n  let svdSolution = new SingularValueDecomposition(matrix, { autoTranspose: true });\n\n  let U = svdSolution.leftSingularVectors;\n  let V = svdSolution.rightSingularVectors;\n  let s = svdSolution.diagonal;\n\n  for (let i = 0; i < s.length; i++) {\n    if (Math.abs(s[i]) > threshold) {\n      s[i] = 1.0 / s[i];\n    } else {\n      s[i] = 0.0;\n    }\n  }\n\n  return V.mmul(Matrix.diag(s).mmul(U.transpose()));\n}\n\nfunction covariance(xMatrix, yMatrix = xMatrix, options = {}) {\n  xMatrix = new Matrix(xMatrix);\n  let yIsSame = false;\n  if (\n    typeof yMatrix === 'object' &&\n    !Matrix.isMatrix(yMatrix) &&\n    !isAnyArray.isAnyArray(yMatrix)\n  ) {\n    options = yMatrix;\n    yMatrix = xMatrix;\n    yIsSame = true;\n  } else {\n    yMatrix = new Matrix(yMatrix);\n  }\n  if (xMatrix.rows !== yMatrix.rows) {\n    throw new TypeError('Both matrices must have the same number of rows');\n  }\n  const { center = true } = options;\n  if (center) {\n    xMatrix = xMatrix.center('column');\n    if (!yIsSame) {\n      yMatrix = yMatrix.center('column');\n    }\n  }\n  const cov = xMatrix.transpose().mmul(yMatrix);\n  for (let i = 0; i < cov.rows; i++) {\n    for (let j = 0; j < cov.columns; j++) {\n      cov.set(i, j, cov.get(i, j) * (1 / (xMatrix.rows - 1)));\n    }\n  }\n  return cov;\n}\n\nfunction correlation(xMatrix, yMatrix = xMatrix, options = {}) {\n  xMatrix = new Matrix(xMatrix);\n  let yIsSame = false;\n  if (\n    typeof yMatrix === 'object' &&\n    !Matrix.isMatrix(yMatrix) &&\n    !isAnyArray.isAnyArray(yMatrix)\n  ) {\n    options = yMatrix;\n    yMatrix = xMatrix;\n    yIsSame = true;\n  } else {\n    yMatrix = new Matrix(yMatrix);\n  }\n  if (xMatrix.rows !== yMatrix.rows) {\n    throw new TypeError('Both matrices must have the same number of rows');\n  }\n\n  const { center = true, scale = true } = options;\n  if (center) {\n    xMatrix.center('column');\n    if (!yIsSame) {\n      yMatrix.center('column');\n    }\n  }\n  if (scale) {\n    xMatrix.scale('column');\n    if (!yIsSame) {\n      yMatrix.scale('column');\n    }\n  }\n\n  const sdx = xMatrix.standardDeviation('column', { unbiased: true });\n  const sdy = yIsSame\n    ? sdx\n    : yMatrix.standardDeviation('column', { unbiased: true });\n\n  const corr = xMatrix.transpose().mmul(yMatrix);\n  for (let i = 0; i < corr.rows; i++) {\n    for (let j = 0; j < corr.columns; j++) {\n      corr.set(\n        i,\n        j,\n        corr.get(i, j) * (1 / (sdx[i] * sdy[j])) * (1 / (xMatrix.rows - 1)),\n      );\n    }\n  }\n  return corr;\n}\n\nclass EigenvalueDecomposition {\n  constructor(matrix, options = {}) {\n    const { assumeSymmetric = false } = options;\n\n    matrix = WrapperMatrix2D.checkMatrix(matrix);\n    if (!matrix.isSquare()) {\n      throw new Error('Matrix is not a square matrix');\n    }\n\n    if (matrix.isEmpty()) {\n      throw new Error('Matrix must be non-empty');\n    }\n\n    let n = matrix.columns;\n    let V = new Matrix(n, n);\n    let d = new Float64Array(n);\n    let e = new Float64Array(n);\n    let value = matrix;\n    let i, j;\n\n    let isSymmetric = false;\n    if (assumeSymmetric) {\n      isSymmetric = true;\n    } else {\n      isSymmetric = matrix.isSymmetric();\n    }\n\n    if (isSymmetric) {\n      for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n          V.set(i, j, value.get(i, j));\n        }\n      }\n      tred2(n, e, d, V);\n      tql2(n, e, d, V);\n    } else {\n      let H = new Matrix(n, n);\n      let ort = new Float64Array(n);\n      for (j = 0; j < n; j++) {\n        for (i = 0; i < n; i++) {\n          H.set(i, j, value.get(i, j));\n        }\n      }\n      orthes(n, H, ort, V);\n      hqr2(n, e, d, V, H);\n    }\n\n    this.n = n;\n    this.e = e;\n    this.d = d;\n    this.V = V;\n  }\n\n  get realEigenvalues() {\n    return Array.from(this.d);\n  }\n\n  get imaginaryEigenvalues() {\n    return Array.from(this.e);\n  }\n\n  get eigenvectorMatrix() {\n    return this.V;\n  }\n\n  get diagonalMatrix() {\n    let n = this.n;\n    let e = this.e;\n    let d = this.d;\n    let X = new Matrix(n, n);\n    let i, j;\n    for (i = 0; i < n; i++) {\n      for (j = 0; j < n; j++) {\n        X.set(i, j, 0);\n      }\n      X.set(i, i, d[i]);\n      if (e[i] > 0) {\n        X.set(i, i + 1, e[i]);\n      } else if (e[i] < 0) {\n        X.set(i, i - 1, e[i]);\n      }\n    }\n    return X;\n  }\n}\n\nfunction tred2(n, e, d, V) {\n  let f, g, h, i, j, k, hh, scale;\n\n  for (j = 0; j < n; j++) {\n    d[j] = V.get(n - 1, j);\n  }\n\n  for (i = n - 1; i > 0; i--) {\n    scale = 0;\n    h = 0;\n    for (k = 0; k < i; k++) {\n      scale = scale + Math.abs(d[k]);\n    }\n\n    if (scale === 0) {\n      e[i] = d[i - 1];\n      for (j = 0; j < i; j++) {\n        d[j] = V.get(i - 1, j);\n        V.set(i, j, 0);\n        V.set(j, i, 0);\n      }\n    } else {\n      for (k = 0; k < i; k++) {\n        d[k] /= scale;\n        h += d[k] * d[k];\n      }\n\n      f = d[i - 1];\n      g = Math.sqrt(h);\n      if (f > 0) {\n        g = -g;\n      }\n\n      e[i] = scale * g;\n      h = h - f * g;\n      d[i - 1] = f - g;\n      for (j = 0; j < i; j++) {\n        e[j] = 0;\n      }\n\n      for (j = 0; j < i; j++) {\n        f = d[j];\n        V.set(j, i, f);\n        g = e[j] + V.get(j, j) * f;\n        for (k = j + 1; k <= i - 1; k++) {\n          g += V.get(k, j) * d[k];\n          e[k] += V.get(k, j) * f;\n        }\n        e[j] = g;\n      }\n\n      f = 0;\n      for (j = 0; j < i; j++) {\n        e[j] /= h;\n        f += e[j] * d[j];\n      }\n\n      hh = f / (h + h);\n      for (j = 0; j < i; j++) {\n        e[j] -= hh * d[j];\n      }\n\n      for (j = 0; j < i; j++) {\n        f = d[j];\n        g = e[j];\n        for (k = j; k <= i - 1; k++) {\n          V.set(k, j, V.get(k, j) - (f * e[k] + g * d[k]));\n        }\n        d[j] = V.get(i - 1, j);\n        V.set(i, j, 0);\n      }\n    }\n    d[i] = h;\n  }\n\n  for (i = 0; i < n - 1; i++) {\n    V.set(n - 1, i, V.get(i, i));\n    V.set(i, i, 1);\n    h = d[i + 1];\n    if (h !== 0) {\n      for (k = 0; k <= i; k++) {\n        d[k] = V.get(k, i + 1) / h;\n      }\n\n      for (j = 0; j <= i; j++) {\n        g = 0;\n        for (k = 0; k <= i; k++) {\n          g += V.get(k, i + 1) * V.get(k, j);\n        }\n        for (k = 0; k <= i; k++) {\n          V.set(k, j, V.get(k, j) - g * d[k]);\n        }\n      }\n    }\n\n    for (k = 0; k <= i; k++) {\n      V.set(k, i + 1, 0);\n    }\n  }\n\n  for (j = 0; j < n; j++) {\n    d[j] = V.get(n - 1, j);\n    V.set(n - 1, j, 0);\n  }\n\n  V.set(n - 1, n - 1, 1);\n  e[0] = 0;\n}\n\nfunction tql2(n, e, d, V) {\n  let g, h, i, j, k, l, m, p, r, dl1, c, c2, c3, el1, s, s2;\n\n  for (i = 1; i < n; i++) {\n    e[i - 1] = e[i];\n  }\n\n  e[n - 1] = 0;\n\n  let f = 0;\n  let tst1 = 0;\n  let eps = Number.EPSILON;\n\n  for (l = 0; l < n; l++) {\n    tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));\n    m = l;\n    while (m < n) {\n      if (Math.abs(e[m]) <= eps * tst1) {\n        break;\n      }\n      m++;\n    }\n\n    if (m > l) {\n      do {\n\n        g = d[l];\n        p = (d[l + 1] - g) / (2 * e[l]);\n        r = hypotenuse(p, 1);\n        if (p < 0) {\n          r = -r;\n        }\n\n        d[l] = e[l] / (p + r);\n        d[l + 1] = e[l] * (p + r);\n        dl1 = d[l + 1];\n        h = g - d[l];\n        for (i = l + 2; i < n; i++) {\n          d[i] -= h;\n        }\n\n        f = f + h;\n\n        p = d[m];\n        c = 1;\n        c2 = c;\n        c3 = c;\n        el1 = e[l + 1];\n        s = 0;\n        s2 = 0;\n        for (i = m - 1; i >= l; i--) {\n          c3 = c2;\n          c2 = c;\n          s2 = s;\n          g = c * e[i];\n          h = c * p;\n          r = hypotenuse(p, e[i]);\n          e[i + 1] = s * r;\n          s = e[i] / r;\n          c = p / r;\n          p = c * d[i] - s * g;\n          d[i + 1] = h + s * (c * g + s * d[i]);\n\n          for (k = 0; k < n; k++) {\n            h = V.get(k, i + 1);\n            V.set(k, i + 1, s * V.get(k, i) + c * h);\n            V.set(k, i, c * V.get(k, i) - s * h);\n          }\n        }\n\n        p = (-s * s2 * c3 * el1 * e[l]) / dl1;\n        e[l] = s * p;\n        d[l] = c * p;\n      } while (Math.abs(e[l]) > eps * tst1);\n    }\n    d[l] = d[l] + f;\n    e[l] = 0;\n  }\n\n  for (i = 0; i < n - 1; i++) {\n    k = i;\n    p = d[i];\n    for (j = i + 1; j < n; j++) {\n      if (d[j] < p) {\n        k = j;\n        p = d[j];\n      }\n    }\n\n    if (k !== i) {\n      d[k] = d[i];\n      d[i] = p;\n      for (j = 0; j < n; j++) {\n        p = V.get(j, i);\n        V.set(j, i, V.get(j, k));\n        V.set(j, k, p);\n      }\n    }\n  }\n}\n\nfunction orthes(n, H, ort, V) {\n  let low = 0;\n  let high = n - 1;\n  let f, g, h, i, j, m;\n  let scale;\n\n  for (m = low + 1; m <= high - 1; m++) {\n    scale = 0;\n    for (i = m; i <= high; i++) {\n      scale = scale + Math.abs(H.get(i, m - 1));\n    }\n\n    if (scale !== 0) {\n      h = 0;\n      for (i = high; i >= m; i--) {\n        ort[i] = H.get(i, m - 1) / scale;\n        h += ort[i] * ort[i];\n      }\n\n      g = Math.sqrt(h);\n      if (ort[m] > 0) {\n        g = -g;\n      }\n\n      h = h - ort[m] * g;\n      ort[m] = ort[m] - g;\n\n      for (j = m; j < n; j++) {\n        f = 0;\n        for (i = high; i >= m; i--) {\n          f += ort[i] * H.get(i, j);\n        }\n\n        f = f / h;\n        for (i = m; i <= high; i++) {\n          H.set(i, j, H.get(i, j) - f * ort[i]);\n        }\n      }\n\n      for (i = 0; i <= high; i++) {\n        f = 0;\n        for (j = high; j >= m; j--) {\n          f += ort[j] * H.get(i, j);\n        }\n\n        f = f / h;\n        for (j = m; j <= high; j++) {\n          H.set(i, j, H.get(i, j) - f * ort[j]);\n        }\n      }\n\n      ort[m] = scale * ort[m];\n      H.set(m, m - 1, scale * g);\n    }\n  }\n\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < n; j++) {\n      V.set(i, j, i === j ? 1 : 0);\n    }\n  }\n\n  for (m = high - 1; m >= low + 1; m--) {\n    if (H.get(m, m - 1) !== 0) {\n      for (i = m + 1; i <= high; i++) {\n        ort[i] = H.get(i, m - 1);\n      }\n\n      for (j = m; j <= high; j++) {\n        g = 0;\n        for (i = m; i <= high; i++) {\n          g += ort[i] * V.get(i, j);\n        }\n\n        g = g / ort[m] / H.get(m, m - 1);\n        for (i = m; i <= high; i++) {\n          V.set(i, j, V.get(i, j) + g * ort[i]);\n        }\n      }\n    }\n  }\n}\n\nfunction hqr2(nn, e, d, V, H) {\n  let n = nn - 1;\n  let low = 0;\n  let high = nn - 1;\n  let eps = Number.EPSILON;\n  let exshift = 0;\n  let norm = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let z = 0;\n  let iter = 0;\n  let i, j, k, l, m, t, w, x, y;\n  let ra, sa, vr, vi;\n  let notlast, cdivres;\n\n  for (i = 0; i < nn; i++) {\n    if (i < low || i > high) {\n      d[i] = H.get(i, i);\n      e[i] = 0;\n    }\n\n    for (j = Math.max(i - 1, 0); j < nn; j++) {\n      norm = norm + Math.abs(H.get(i, j));\n    }\n  }\n\n  while (n >= low) {\n    l = n;\n    while (l > low) {\n      s = Math.abs(H.get(l - 1, l - 1)) + Math.abs(H.get(l, l));\n      if (s === 0) {\n        s = norm;\n      }\n      if (Math.abs(H.get(l, l - 1)) < eps * s) {\n        break;\n      }\n      l--;\n    }\n\n    if (l === n) {\n      H.set(n, n, H.get(n, n) + exshift);\n      d[n] = H.get(n, n);\n      e[n] = 0;\n      n--;\n      iter = 0;\n    } else if (l === n - 1) {\n      w = H.get(n, n - 1) * H.get(n - 1, n);\n      p = (H.get(n - 1, n - 1) - H.get(n, n)) / 2;\n      q = p * p + w;\n      z = Math.sqrt(Math.abs(q));\n      H.set(n, n, H.get(n, n) + exshift);\n      H.set(n - 1, n - 1, H.get(n - 1, n - 1) + exshift);\n      x = H.get(n, n);\n\n      if (q >= 0) {\n        z = p >= 0 ? p + z : p - z;\n        d[n - 1] = x + z;\n        d[n] = d[n - 1];\n        if (z !== 0) {\n          d[n] = x - w / z;\n        }\n        e[n - 1] = 0;\n        e[n] = 0;\n        x = H.get(n, n - 1);\n        s = Math.abs(x) + Math.abs(z);\n        p = x / s;\n        q = z / s;\n        r = Math.sqrt(p * p + q * q);\n        p = p / r;\n        q = q / r;\n\n        for (j = n - 1; j < nn; j++) {\n          z = H.get(n - 1, j);\n          H.set(n - 1, j, q * z + p * H.get(n, j));\n          H.set(n, j, q * H.get(n, j) - p * z);\n        }\n\n        for (i = 0; i <= n; i++) {\n          z = H.get(i, n - 1);\n          H.set(i, n - 1, q * z + p * H.get(i, n));\n          H.set(i, n, q * H.get(i, n) - p * z);\n        }\n\n        for (i = low; i <= high; i++) {\n          z = V.get(i, n - 1);\n          V.set(i, n - 1, q * z + p * V.get(i, n));\n          V.set(i, n, q * V.get(i, n) - p * z);\n        }\n      } else {\n        d[n - 1] = x + p;\n        d[n] = x + p;\n        e[n - 1] = z;\n        e[n] = -z;\n      }\n\n      n = n - 2;\n      iter = 0;\n    } else {\n      x = H.get(n, n);\n      y = 0;\n      w = 0;\n      if (l < n) {\n        y = H.get(n - 1, n - 1);\n        w = H.get(n, n - 1) * H.get(n - 1, n);\n      }\n\n      if (iter === 10) {\n        exshift += x;\n        for (i = low; i <= n; i++) {\n          H.set(i, i, H.get(i, i) - x);\n        }\n        s = Math.abs(H.get(n, n - 1)) + Math.abs(H.get(n - 1, n - 2));\n        // eslint-disable-next-line no-multi-assign\n        x = y = 0.75 * s;\n        w = -0.4375 * s * s;\n      }\n\n      if (iter === 30) {\n        s = (y - x) / 2;\n        s = s * s + w;\n        if (s > 0) {\n          s = Math.sqrt(s);\n          if (y < x) {\n            s = -s;\n          }\n          s = x - w / ((y - x) / 2 + s);\n          for (i = low; i <= n; i++) {\n            H.set(i, i, H.get(i, i) - s);\n          }\n          exshift += s;\n          // eslint-disable-next-line no-multi-assign\n          x = y = w = 0.964;\n        }\n      }\n\n      iter = iter + 1;\n\n      m = n - 2;\n      while (m >= l) {\n        z = H.get(m, m);\n        r = x - z;\n        s = y - z;\n        p = (r * s - w) / H.get(m + 1, m) + H.get(m, m + 1);\n        q = H.get(m + 1, m + 1) - z - r - s;\n        r = H.get(m + 2, m + 1);\n        s = Math.abs(p) + Math.abs(q) + Math.abs(r);\n        p = p / s;\n        q = q / s;\n        r = r / s;\n        if (m === l) {\n          break;\n        }\n        if (\n          Math.abs(H.get(m, m - 1)) * (Math.abs(q) + Math.abs(r)) <\n          eps *\n            (Math.abs(p) *\n              (Math.abs(H.get(m - 1, m - 1)) +\n                Math.abs(z) +\n                Math.abs(H.get(m + 1, m + 1))))\n        ) {\n          break;\n        }\n        m--;\n      }\n\n      for (i = m + 2; i <= n; i++) {\n        H.set(i, i - 2, 0);\n        if (i > m + 2) {\n          H.set(i, i - 3, 0);\n        }\n      }\n\n      for (k = m; k <= n - 1; k++) {\n        notlast = k !== n - 1;\n        if (k !== m) {\n          p = H.get(k, k - 1);\n          q = H.get(k + 1, k - 1);\n          r = notlast ? H.get(k + 2, k - 1) : 0;\n          x = Math.abs(p) + Math.abs(q) + Math.abs(r);\n          if (x !== 0) {\n            p = p / x;\n            q = q / x;\n            r = r / x;\n          }\n        }\n\n        if (x === 0) {\n          break;\n        }\n\n        s = Math.sqrt(p * p + q * q + r * r);\n        if (p < 0) {\n          s = -s;\n        }\n\n        if (s !== 0) {\n          if (k !== m) {\n            H.set(k, k - 1, -s * x);\n          } else if (l !== m) {\n            H.set(k, k - 1, -H.get(k, k - 1));\n          }\n\n          p = p + s;\n          x = p / s;\n          y = q / s;\n          z = r / s;\n          q = q / p;\n          r = r / p;\n\n          for (j = k; j < nn; j++) {\n            p = H.get(k, j) + q * H.get(k + 1, j);\n            if (notlast) {\n              p = p + r * H.get(k + 2, j);\n              H.set(k + 2, j, H.get(k + 2, j) - p * z);\n            }\n\n            H.set(k, j, H.get(k, j) - p * x);\n            H.set(k + 1, j, H.get(k + 1, j) - p * y);\n          }\n\n          for (i = 0; i <= Math.min(n, k + 3); i++) {\n            p = x * H.get(i, k) + y * H.get(i, k + 1);\n            if (notlast) {\n              p = p + z * H.get(i, k + 2);\n              H.set(i, k + 2, H.get(i, k + 2) - p * r);\n            }\n\n            H.set(i, k, H.get(i, k) - p);\n            H.set(i, k + 1, H.get(i, k + 1) - p * q);\n          }\n\n          for (i = low; i <= high; i++) {\n            p = x * V.get(i, k) + y * V.get(i, k + 1);\n            if (notlast) {\n              p = p + z * V.get(i, k + 2);\n              V.set(i, k + 2, V.get(i, k + 2) - p * r);\n            }\n\n            V.set(i, k, V.get(i, k) - p);\n            V.set(i, k + 1, V.get(i, k + 1) - p * q);\n          }\n        }\n      }\n    }\n  }\n\n  if (norm === 0) {\n    return;\n  }\n\n  for (n = nn - 1; n >= 0; n--) {\n    p = d[n];\n    q = e[n];\n\n    if (q === 0) {\n      l = n;\n      H.set(n, n, 1);\n      for (i = n - 1; i >= 0; i--) {\n        w = H.get(i, i) - p;\n        r = 0;\n        for (j = l; j <= n; j++) {\n          r = r + H.get(i, j) * H.get(j, n);\n        }\n\n        if (e[i] < 0) {\n          z = w;\n          s = r;\n        } else {\n          l = i;\n          if (e[i] === 0) {\n            H.set(i, n, w !== 0 ? -r / w : -r / (eps * norm));\n          } else {\n            x = H.get(i, i + 1);\n            y = H.get(i + 1, i);\n            q = (d[i] - p) * (d[i] - p) + e[i] * e[i];\n            t = (x * s - z * r) / q;\n            H.set(i, n, t);\n            H.set(\n              i + 1,\n              n,\n              Math.abs(x) > Math.abs(z) ? (-r - w * t) / x : (-s - y * t) / z,\n            );\n          }\n\n          t = Math.abs(H.get(i, n));\n          if (eps * t * t > 1) {\n            for (j = i; j <= n; j++) {\n              H.set(j, n, H.get(j, n) / t);\n            }\n          }\n        }\n      }\n    } else if (q < 0) {\n      l = n - 1;\n\n      if (Math.abs(H.get(n, n - 1)) > Math.abs(H.get(n - 1, n))) {\n        H.set(n - 1, n - 1, q / H.get(n, n - 1));\n        H.set(n - 1, n, -(H.get(n, n) - p) / H.get(n, n - 1));\n      } else {\n        cdivres = cdiv(0, -H.get(n - 1, n), H.get(n - 1, n - 1) - p, q);\n        H.set(n - 1, n - 1, cdivres[0]);\n        H.set(n - 1, n, cdivres[1]);\n      }\n\n      H.set(n, n - 1, 0);\n      H.set(n, n, 1);\n      for (i = n - 2; i >= 0; i--) {\n        ra = 0;\n        sa = 0;\n        for (j = l; j <= n; j++) {\n          ra = ra + H.get(i, j) * H.get(j, n - 1);\n          sa = sa + H.get(i, j) * H.get(j, n);\n        }\n\n        w = H.get(i, i) - p;\n\n        if (e[i] < 0) {\n          z = w;\n          r = ra;\n          s = sa;\n        } else {\n          l = i;\n          if (e[i] === 0) {\n            cdivres = cdiv(-ra, -sa, w, q);\n            H.set(i, n - 1, cdivres[0]);\n            H.set(i, n, cdivres[1]);\n          } else {\n            x = H.get(i, i + 1);\n            y = H.get(i + 1, i);\n            vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;\n            vi = (d[i] - p) * 2 * q;\n            if (vr === 0 && vi === 0) {\n              vr =\n                eps *\n                norm *\n                (Math.abs(w) +\n                  Math.abs(q) +\n                  Math.abs(x) +\n                  Math.abs(y) +\n                  Math.abs(z));\n            }\n            cdivres = cdiv(\n              x * r - z * ra + q * sa,\n              x * s - z * sa - q * ra,\n              vr,\n              vi,\n            );\n            H.set(i, n - 1, cdivres[0]);\n            H.set(i, n, cdivres[1]);\n            if (Math.abs(x) > Math.abs(z) + Math.abs(q)) {\n              H.set(\n                i + 1,\n                n - 1,\n                (-ra - w * H.get(i, n - 1) + q * H.get(i, n)) / x,\n              );\n              H.set(\n                i + 1,\n                n,\n                (-sa - w * H.get(i, n) - q * H.get(i, n - 1)) / x,\n              );\n            } else {\n              cdivres = cdiv(\n                -r - y * H.get(i, n - 1),\n                -s - y * H.get(i, n),\n                z,\n                q,\n              );\n              H.set(i + 1, n - 1, cdivres[0]);\n              H.set(i + 1, n, cdivres[1]);\n            }\n          }\n\n          t = Math.max(Math.abs(H.get(i, n - 1)), Math.abs(H.get(i, n)));\n          if (eps * t * t > 1) {\n            for (j = i; j <= n; j++) {\n              H.set(j, n - 1, H.get(j, n - 1) / t);\n              H.set(j, n, H.get(j, n) / t);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  for (i = 0; i < nn; i++) {\n    if (i < low || i > high) {\n      for (j = i; j < nn; j++) {\n        V.set(i, j, H.get(i, j));\n      }\n    }\n  }\n\n  for (j = nn - 1; j >= low; j--) {\n    for (i = low; i <= high; i++) {\n      z = 0;\n      for (k = low; k <= Math.min(j, high); k++) {\n        z = z + V.get(i, k) * H.get(k, j);\n      }\n      V.set(i, j, z);\n    }\n  }\n}\n\nfunction cdiv(xr, xi, yr, yi) {\n  let r, d;\n  if (Math.abs(yr) > Math.abs(yi)) {\n    r = yi / yr;\n    d = yr + r * yi;\n    return [(xr + r * xi) / d, (xi - r * xr) / d];\n  } else {\n    r = yr / yi;\n    d = yi + r * yr;\n    return [(r * xr + xi) / d, (r * xi - xr) / d];\n  }\n}\n\nclass CholeskyDecomposition {\n  constructor(value) {\n    value = WrapperMatrix2D.checkMatrix(value);\n    if (!value.isSymmetric()) {\n      throw new Error('Matrix is not symmetric');\n    }\n\n    let a = value;\n    let dimension = a.rows;\n    let l = new Matrix(dimension, dimension);\n    let positiveDefinite = true;\n    let i, j, k;\n\n    for (j = 0; j < dimension; j++) {\n      let d = 0;\n      for (k = 0; k < j; k++) {\n        let s = 0;\n        for (i = 0; i < k; i++) {\n          s += l.get(k, i) * l.get(j, i);\n        }\n        s = (a.get(j, k) - s) / l.get(k, k);\n        l.set(j, k, s);\n        d = d + s * s;\n      }\n\n      d = a.get(j, j) - d;\n\n      positiveDefinite &&= d > 0;\n      l.set(j, j, Math.sqrt(Math.max(d, 0)));\n      for (k = j + 1; k < dimension; k++) {\n        l.set(j, k, 0);\n      }\n    }\n\n    this.L = l;\n    this.positiveDefinite = positiveDefinite;\n  }\n\n  isPositiveDefinite() {\n    return this.positiveDefinite;\n  }\n\n  solve(value) {\n    value = WrapperMatrix2D.checkMatrix(value);\n\n    let l = this.L;\n    let dimension = l.rows;\n\n    if (value.rows !== dimension) {\n      throw new Error('Matrix dimensions do not match');\n    }\n    if (this.isPositiveDefinite() === false) {\n      throw new Error('Matrix is not positive definite');\n    }\n\n    let count = value.columns;\n    let B = value.clone();\n    let i, j, k;\n\n    for (k = 0; k < dimension; k++) {\n      for (j = 0; j < count; j++) {\n        for (i = 0; i < k; i++) {\n          B.set(k, j, B.get(k, j) - B.get(i, j) * l.get(k, i));\n        }\n        B.set(k, j, B.get(k, j) / l.get(k, k));\n      }\n    }\n\n    for (k = dimension - 1; k >= 0; k--) {\n      for (j = 0; j < count; j++) {\n        for (i = k + 1; i < dimension; i++) {\n          B.set(k, j, B.get(k, j) - B.get(i, j) * l.get(i, k));\n        }\n        B.set(k, j, B.get(k, j) / l.get(k, k));\n      }\n    }\n\n    return B;\n  }\n\n  get lowerTriangularMatrix() {\n    return this.L;\n  }\n}\n\nclass nipals {\n  constructor(X, options = {}) {\n    X = WrapperMatrix2D.checkMatrix(X);\n    let { Y } = options;\n    const {\n      scaleScores = false,\n      maxIterations = 1000,\n      terminationCriteria = 1e-10,\n    } = options;\n\n    let u;\n    if (Y) {\n      if (isAnyArray.isAnyArray(Y) && typeof Y[0] === 'number') {\n        Y = Matrix.columnVector(Y);\n      } else {\n        Y = WrapperMatrix2D.checkMatrix(Y);\n      }\n      if (Y.rows !== X.rows) {\n        throw new Error('Y should have the same number of rows as X');\n      }\n      u = Y.getColumnVector(0);\n    } else {\n      u = X.getColumnVector(0);\n    }\n\n    let diff = 1;\n    let t, q, w, tOld;\n\n    for (\n      let counter = 0;\n      counter < maxIterations && diff > terminationCriteria;\n      counter++\n    ) {\n      w = X.transpose().mmul(u).div(u.transpose().mmul(u).get(0, 0));\n      w = w.div(w.norm());\n\n      t = X.mmul(w).div(w.transpose().mmul(w).get(0, 0));\n\n      if (counter > 0) {\n        diff = t.clone().sub(tOld).pow(2).sum();\n      }\n      tOld = t.clone();\n\n      if (Y) {\n        q = Y.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));\n        q = q.div(q.norm());\n\n        u = Y.mmul(q).div(q.transpose().mmul(q).get(0, 0));\n      } else {\n        u = t;\n      }\n    }\n\n    if (Y) {\n      let p = X.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));\n      p = p.div(p.norm());\n      let xResidual = X.clone().sub(t.clone().mmul(p.transpose()));\n      let residual = u.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));\n      let yResidual = Y.clone().sub(\n        t.clone().mulS(residual.get(0, 0)).mmul(q.transpose()),\n      );\n\n      this.t = t;\n      this.p = p.transpose();\n      this.w = w.transpose();\n      this.q = q;\n      this.u = u;\n      this.s = t.transpose().mmul(t);\n      this.xResidual = xResidual;\n      this.yResidual = yResidual;\n      this.betas = residual;\n    } else {\n      this.w = w.transpose();\n      this.s = t.transpose().mmul(t).sqrt();\n      if (scaleScores) {\n        this.t = t.clone().div(this.s.get(0, 0));\n      } else {\n        this.t = t;\n      }\n      this.xResidual = X.sub(t.mmul(w.transpose()));\n    }\n  }\n}\n\nexports.AbstractMatrix = AbstractMatrix;\nexports.CHO = CholeskyDecomposition;\nexports.CholeskyDecomposition = CholeskyDecomposition;\nexports.DistanceMatrix = DistanceMatrix;\nexports.EVD = EigenvalueDecomposition;\nexports.EigenvalueDecomposition = EigenvalueDecomposition;\nexports.LU = LuDecomposition;\nexports.LuDecomposition = LuDecomposition;\nexports.Matrix = Matrix;\nexports.MatrixColumnSelectionView = MatrixColumnSelectionView;\nexports.MatrixColumnView = MatrixColumnView;\nexports.MatrixFlipColumnView = MatrixFlipColumnView;\nexports.MatrixFlipRowView = MatrixFlipRowView;\nexports.MatrixRowSelectionView = MatrixRowSelectionView;\nexports.MatrixRowView = MatrixRowView;\nexports.MatrixSelectionView = MatrixSelectionView;\nexports.MatrixSubView = MatrixSubView;\nexports.MatrixTransposeView = MatrixTransposeView;\nexports.NIPALS = nipals;\nexports.Nipals = nipals;\nexports.QR = QrDecomposition;\nexports.QrDecomposition = QrDecomposition;\nexports.SVD = SingularValueDecomposition;\nexports.SingularValueDecomposition = SingularValueDecomposition;\nexports.SymmetricMatrix = SymmetricMatrix;\nexports.WrapperMatrix1D = WrapperMatrix1D;\nexports.WrapperMatrix2D = WrapperMatrix2D;\nexports.correlation = correlation;\nexports.covariance = covariance;\nexports.default = Matrix;\nexports.determinant = determinant;\nexports.inverse = inverse;\nexports.linearDependencies = linearDependencies;\nexports.pseudoInverse = pseudoInverse;\nexports.solve = solve;\nexports.wrap = wrap;\n","import * as matrix from './matrix.js';\n\nexport const AbstractMatrix = matrix.AbstractMatrix;\nexport const CHO = matrix.CHO;\nexport const CholeskyDecomposition = matrix.CholeskyDecomposition;\nexport const DistanceMatrix = matrix.DistanceMatrix;\nexport const EVD = matrix.EVD;\nexport const EigenvalueDecomposition = matrix.EigenvalueDecomposition;\nexport const LU = matrix.LU;\nexport const LuDecomposition = matrix.LuDecomposition;\nexport const Matrix = matrix.Matrix;\nexport const MatrixColumnSelectionView = matrix.MatrixColumnSelectionView;\nexport const MatrixColumnView = matrix.MatrixColumnView;\nexport const MatrixFlipColumnView = matrix.MatrixFlipColumnView;\nexport const MatrixFlipRowView = matrix.MatrixFlipRowView;\nexport const MatrixRowSelectionView = matrix.MatrixRowSelectionView;\nexport const MatrixRowView = matrix.MatrixRowView;\nexport const MatrixSelectionView = matrix.MatrixSelectionView;\nexport const MatrixSubView = matrix.MatrixSubView;\nexport const MatrixTransposeView = matrix.MatrixTransposeView;\nexport const NIPALS = matrix.NIPALS;\nexport const Nipals = matrix.Nipals;\nexport const QR = matrix.QR;\nexport const QrDecomposition = matrix.QrDecomposition;\nexport const SVD = matrix.SVD;\nexport const SingularValueDecomposition = matrix.SingularValueDecomposition;\nexport const SymmetricMatrix = matrix.SymmetricMatrix;\nexport const WrapperMatrix1D = matrix.WrapperMatrix1D;\nexport const WrapperMatrix2D = matrix.WrapperMatrix2D;\nexport const correlation = matrix.correlation;\nexport const covariance = matrix.covariance;\nexport default matrix.default.Matrix ? matrix.default.Matrix : matrix.Matrix;\nexport const determinant = matrix.determinant;\nexport const inverse = matrix.inverse;\nexport const linearDependencies = matrix.linearDependencies;\nexport const pseudoInverse = matrix.pseudoInverse;\nexport const solve = matrix.solve;\nexport const wrap = matrix.wrap;\n","import Matrix from 'ml-matrix';\n/**\n * Compute the centroid of a set of points.\n *\n * @param points - Points to process as a 3xN matrix. Third dimension must be padded with ones.\n * @returns The centroid.\n */\nexport function getCentroid(points) {\n    let result = new Matrix(3, 1);\n    const nbPoints = points.columns;\n    let xSum = 0;\n    let ySum = 0;\n    for (let i = 0; i < nbPoints; i++) {\n        xSum += points.get(0, i);\n        ySum += points.get(1, i);\n    }\n    result.set(0, 0, xSum / nbPoints);\n    result.set(1, 0, ySum / nbPoints);\n    return result;\n}\n//# sourceMappingURL=getCentroid.js.map","import Matrix, { SingularValueDecomposition, determinant } from 'ml-matrix';\nimport { getCentroid } from './getCentroid';\n/**\n * Get best rotation and translation of source points to destination points.\n * Based on {@link https://nghiaho.com/?page_id=671}\n *\n * @param source - Source points as a 3xN matrix. Third dimension must be padded with ones.\n * @param destination - Destination points as a 3xN matrix. Third dimension must be padded with ones.\n * @returns The affine transformation.\n */\nexport function getAffineTransform(source, destination) {\n    if (source.columns !== destination.columns) {\n        throw new Error('Source and destination matrices should have same dimensions (same number of points).');\n    }\n    if (source.columns < 2) {\n        throw new Error('Matrices should contain at least two points for the algorithm to run properly.');\n    }\n    const sourceCentroid = getCentroid(source);\n    const destinationCentroid = getCentroid(destination);\n    const translatedSource = source.clone().subColumnVector(sourceCentroid);\n    const translatedDestination = destination\n        .clone()\n        .subColumnVector(destinationCentroid);\n    // computing scale\n    let ratioSum = 0;\n    const nbPoints = source.columns;\n    for (let i = 0; i < nbPoints; i++) {\n        const sourcePoint = translatedSource.getColumn(i);\n        const destinationPoint = translatedDestination.getColumn(i);\n        ratioSum +=\n            getDistanceToOrigin(destinationPoint) / getDistanceToOrigin(sourcePoint);\n    }\n    const scale = ratioSum / nbPoints;\n    const scaledSource = Matrix.mul(translatedSource, scale);\n    // computing rotation\n    const covarianceMatrix = scaledSource.mmul(translatedDestination.transpose());\n    const svd = new SingularValueDecomposition(covarianceMatrix);\n    const U = svd.leftSingularVectors;\n    const V = svd.rightSingularVectors;\n    let rotation = V.mmul(U.transpose());\n    if (determinant(rotation) < 0) {\n        const newV = V.mulColumn(2, -1);\n        rotation = newV.mmul(U.transpose());\n    }\n    let angleDegrees = (Math.atan2(rotation.get(1, 0), rotation.get(0, 0)) * 180) / Math.PI;\n    if (angleDegrees === -180) {\n        angleDegrees = 180;\n    }\n    // computing translation\n    const translation = Matrix.sub(destinationCentroid, Matrix.mul(rotation.mmul(sourceCentroid), scale));\n    return {\n        translation: {\n            x: translation.get(0, 0),\n            y: translation.get(1, 0),\n        },\n        rotation: angleDegrees,\n        scale,\n    };\n}\nfunction getDistanceToOrigin(point) {\n    return Math.hypot(point[0], point[1]);\n}\n//# sourceMappingURL=getAffineTransform.js.map","(function(){function a(d){for(var e=0,f=d.length-1,g=void 0,h=void 0,i=void 0,j=c(e,f);!0;){if(f<=e)return d[j];if(f==e+1)return d[e]>d[f]&&b(d,e,f),d[j];for(g=c(e,f),d[g]>d[f]&&b(d,g,f),d[e]>d[f]&&b(d,e,f),d[g]>d[e]&&b(d,g,e),b(d,g,e+1),h=e+1,i=f;!0;){do h++;while(d[e]>d[h]);do i--;while(d[i]>d[e]);if(i<h)break;b(d,h,i)}b(d,e,i),i<=j&&(e=h),i>=j&&(f=i-1)}}var b=function b(d,e,f){var _ref;return _ref=[d[f],d[e]],d[e]=_ref[0],d[f]=_ref[1],_ref},c=function c(d,e){return~~((d+e)/2)};'undefined'!=typeof module&&module.exports?module.exports=a:window.median=a})();\n","import { isAnyArray } from 'is-any-array';\nimport quickSelectMedian from 'median-quickselect';\n\nfunction median(input) {\n  if (!isAnyArray(input)) {\n    throw new TypeError('input must be an array');\n  }\n\n  if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  return quickSelectMedian(input.slice());\n}\n\nexport { median as default };\n","const LOOP = 8;\nconst FLOAT_MUL = 1 / 16777216;\nconst sh1 = 15;\nconst sh2 = 18;\nconst sh3 = 11;\nfunction multiply_uint32(n, m) {\n    n >>>= 0;\n    m >>>= 0;\n    const nlo = n & 0xffff;\n    const nhi = n - nlo;\n    return (((nhi * m) >>> 0) + nlo * m) >>> 0;\n}\nexport default class XSadd {\n    constructor(seed = Date.now()) {\n        this.state = new Uint32Array(4);\n        this.init(seed);\n        this.random = this.getFloat.bind(this);\n    }\n    /**\n     * Returns a 32-bit integer r (0 <= r < 2^32)\n     */\n    getUint32() {\n        this.nextState();\n        return (this.state[3] + this.state[2]) >>> 0;\n    }\n    /**\n     * Returns a floating point number r (0.0 <= r < 1.0)\n     */\n    getFloat() {\n        return (this.getUint32() >>> 8) * FLOAT_MUL;\n    }\n    init(seed) {\n        if (!Number.isInteger(seed)) {\n            throw new TypeError('seed must be an integer');\n        }\n        this.state[0] = seed;\n        this.state[1] = 0;\n        this.state[2] = 0;\n        this.state[3] = 0;\n        for (let i = 1; i < LOOP; i++) {\n            this.state[i & 3] ^=\n                (i +\n                    multiply_uint32(1812433253, this.state[(i - 1) & 3] ^ ((this.state[(i - 1) & 3] >>> 30) >>> 0))) >>>\n                    0;\n        }\n        this.periodCertification();\n        for (let i = 0; i < LOOP; i++) {\n            this.nextState();\n        }\n    }\n    periodCertification() {\n        if (this.state[0] === 0 &&\n            this.state[1] === 0 &&\n            this.state[2] === 0 &&\n            this.state[3] === 0) {\n            this.state[0] = 88; // X\n            this.state[1] = 83; // S\n            this.state[2] = 65; // A\n            this.state[3] = 68; // D\n        }\n    }\n    nextState() {\n        let t = this.state[0];\n        t ^= t << sh1;\n        t ^= t >>> sh2;\n        t ^= this.state[3] << sh3;\n        this.state[0] = this.state[1];\n        this.state[1] = this.state[2];\n        this.state[2] = this.state[3];\n        this.state[3] = t;\n    }\n}\n","const PROB_TOLERANCE = 0.00000001;\nfunction randomChoice(values, options = {}, random = Math.random) {\n    const { size = 1, replace = false, probabilities } = options;\n    let valuesArr;\n    let cumSum;\n    if (typeof values === 'number') {\n        valuesArr = getArray(values);\n    }\n    else {\n        valuesArr = values.slice();\n    }\n    if (probabilities) {\n        if (!replace) {\n            throw new Error('choice with probabilities and no replacement is not implemented');\n        }\n        // check input is sane\n        if (probabilities.length !== valuesArr.length) {\n            throw new Error('the length of probabilities option should be equal to the number of choices');\n        }\n        cumSum = [probabilities[0]];\n        for (let i = 1; i < probabilities.length; i++) {\n            cumSum[i] = cumSum[i - 1] + probabilities[i];\n        }\n        if (Math.abs(1 - cumSum[cumSum.length - 1]) > PROB_TOLERANCE) {\n            throw new Error(`probabilities should sum to 1, but instead sums to ${cumSum[cumSum.length - 1]}`);\n        }\n    }\n    if (replace === false && size > valuesArr.length) {\n        throw new Error('size option is too large');\n    }\n    const result = [];\n    for (let i = 0; i < size; i++) {\n        const index = randomIndex(valuesArr.length, random, cumSum);\n        result.push(valuesArr[index]);\n        if (!replace) {\n            valuesArr.splice(index, 1);\n        }\n    }\n    return result;\n}\nfunction getArray(n) {\n    const arr = [];\n    for (let i = 0; i < n; i++) {\n        arr.push(i);\n    }\n    return arr;\n}\nfunction randomIndex(n, random, cumSum) {\n    const rand = random();\n    if (!cumSum) {\n        return Math.floor(rand * n);\n    }\n    else {\n        let idx = 0;\n        while (rand > cumSum[idx]) {\n            idx++;\n        }\n        return idx;\n    }\n}\nexport default randomChoice;\n","// tslint:disable-next-line\nimport XSAdd from 'ml-xsadd';\nimport choice from './choice';\n/**\n * @classdesc Random class\n */\nexport default class Random {\n    /**\n     * @param [seedOrRandom=Math.random] - Control the random number generator used by the Random class instance. Pass a random number generator function with a uniform distribution over the half-open interval [0, 1[. If seed will pass it to ml-xsadd to create a seeded random number generator. If undefined will use Math.random.\n     */\n    constructor(seedOrRandom = Math.random) {\n        if (typeof seedOrRandom === 'number') {\n            const xsadd = new XSAdd(seedOrRandom);\n            this.randomGenerator = xsadd.random;\n        }\n        else {\n            this.randomGenerator = seedOrRandom;\n        }\n    }\n    choice(values, options) {\n        if (typeof values === 'number') {\n            return choice(values, options, this.randomGenerator);\n        }\n        return choice(values, options, this.randomGenerator);\n    }\n    /**\n     * Draw a random number from a uniform distribution on [0,1)\n     * @return The random number\n     */\n    random() {\n        return this.randomGenerator();\n    }\n    /**\n     * Draw a random integer from a uniform distribution on [low, high). If only low is specified, the number is drawn on [0, low)\n     * @param low - The lower bound of the uniform distribution interval.\n     * @param high - The higher bound of the uniform distribution interval.\n     */\n    randInt(low, high) {\n        if (high === undefined) {\n            high = low;\n            low = 0;\n        }\n        return low + Math.floor(this.randomGenerator() * (high - low));\n    }\n    /**\n     * Draw several random number from a uniform distribution on [0, 1)\n     * @param size - The number of number to draw\n     * @return - The list of drawn numbers.\n     */\n    randomSample(size) {\n        const result = [];\n        for (let i = 0; i < size; i++) {\n            result.push(this.random());\n        }\n        return result;\n    }\n}\n","/**\n * Get the minimal number of iterations of the RANSAC algorithm\n * required to have the given probability of having found the best model.\n *\n * @param probability - Desired probability (between 0 and 1).\n * @param outliersFraction - The estimated fraction of the data that is outliers (from 0 to 1).\n * @param sampleSize - The sample size for the RANSAC algoritm (number of values used for each random test).\n * @returns The minimal number of iterations.\n */\nexport function getNbIterations(probability, outliersFraction, sampleSize) {\n    const value = Math.log10(1 - probability) /\n        Math.log10(1 - (1 - outliersFraction) ** sampleSize);\n    return Math.ceil(value);\n}\n//# sourceMappingURL=getNbIterations.js.map","import arrayMedian from 'ml-array-median';\nimport Random from 'ml-random';\nimport { getNbIterations } from './utils/getNbIterations';\n/**\n * RANdom SAmple Consensus algorithm: find the best model matching the data and ignoring outliers.\n *\n * @see https://en.wikipedia.org/wiki/Random_sample_consensus\n * @param source - The source data.\n * @param destination - The destination data.\n * @param options - RANSAC options.\n * @returns The model parameters and the corresponding inliers.\n */\nexport function ransac(source, destination, options) {\n    let minNbInliers = 0;\n    if (options.minNbInliers) {\n        minNbInliers = getNbValues(options.minNbInliers, source.length);\n    }\n    else {\n        minNbInliers = source.length;\n    }\n    const { sampleSize = 2, threshold = 1, fitFunction, distanceFunction, modelFunction, seed = undefined, } = options;\n    if (source.length !== destination.length) {\n        throw new Error('source and destination data should have the same length');\n    }\n    let maxNbIterations;\n    if ('outliersFraction' in options) {\n        const { stopProbabilty = 0.99 } = options;\n        maxNbIterations = getNbIterations(stopProbabilty, options.outliersFraction, sampleSize);\n    }\n    else {\n        maxNbIterations = options.maxNbIterations ? options.maxNbIterations : 100;\n    }\n    let iteration = 0;\n    let bestNbInliers = 0;\n    let bestInliers = [];\n    let bestModelParameters = [];\n    let bestError = 0;\n    let seeds = [];\n    if (seed !== undefined) {\n        seeds = new Random(seed).choice(maxNbIterations, {\n            size: maxNbIterations,\n        });\n    }\n    while (iteration < maxNbIterations) {\n        iteration++;\n        let indices;\n        if (seed !== undefined) {\n            indices = new Random(seeds[iteration]).choice(source.length, {\n                size: sampleSize,\n            });\n        }\n        else {\n            indices = new Random().choice(source.length, {\n                size: sampleSize,\n            });\n        }\n        const srcSubset = [];\n        const dstSubset = [];\n        for (let i of indices) {\n            srcSubset.push(source[i]);\n            dstSubset.push(destination[i]);\n        }\n        const modelParameters = fitFunction(srcSubset, dstSubset);\n        const model = modelFunction(modelParameters);\n        let predictedDestination = [];\n        for (let value of source) {\n            predictedDestination.push(model(value));\n        }\n        let nbInliers = 0;\n        let inliers = [];\n        let distances = [];\n        let error = 0;\n        for (let i = 0; i < destination.length; i++) {\n            if (indices.includes(i)) {\n                nbInliers++;\n                inliers.push(i);\n                continue;\n            }\n            const distance = distanceFunction(destination[i], predictedDestination[i]);\n            distances.push(distance);\n            if (distance < threshold) {\n                nbInliers++;\n                inliers.push(i);\n            }\n        }\n        error = arrayMedian(distances);\n        if (nbInliers > bestNbInliers) {\n            bestNbInliers = nbInliers;\n            bestInliers = inliers; // potential bug with pointers?\n            bestModelParameters = modelParameters;\n            bestError = error;\n            if (nbInliers >= minNbInliers) {\n                return { modelParameters, inliers, nbIterations: iteration, error };\n            }\n        }\n    }\n    return {\n        modelParameters: bestModelParameters,\n        inliers: bestInliers,\n        nbIterations: maxNbIterations,\n        error: bestError,\n    };\n}\nfunction getNbValues(value, size) {\n    if (Number.isInteger(value)) {\n        return value;\n    }\n    else {\n        return Math.ceil(value * size);\n    }\n}\n//# sourceMappingURL=index.js.map","/**\n * Compute the squared distance from each keypoint to the other ones.\n * @param keypoints - Keypoints to process.\n * @returns Distance matrix.\n */\nexport function getDistanceMatrix(keypoints) {\n    const size = keypoints.length;\n    const matrix = new Array(size);\n    for (let i = 0; i < size; i++) {\n        matrix[i] = new Float64Array(size).fill(0);\n    }\n    for (let i = 0; i < size; i++) {\n        const point1 = keypoints[i].origin;\n        for (let j = i; j < size; j++) {\n            if (i === j) {\n                matrix[i][j] = 0;\n            }\n            const point2 = keypoints[j].origin;\n            const squaredDistance = (point1.row - point2.row) ** 2 + (point1.column - point2.column) ** 2;\n            matrix[i][j] = squaredDistance;\n            matrix[j][i] = squaredDistance;\n        }\n    }\n    return matrix;\n}\n//# sourceMappingURL=getDistanceMatrix.js.map","import { getDistanceMatrix } from './getDistanceMatrix.js';\n/**\n * Find all keypoints within radius from the current keypoint.\n * @param keypoints - Keypoints to process.\n * @param radius - Radius in which the surrounding keypoints should be.\n * @returns Array of keypoints within radius for each of the keypoints.\n */\nexport function getKeypointsInRadius(keypoints, radius) {\n    const size = keypoints.length;\n    const matrix = getDistanceMatrix(keypoints);\n    const squaredRadius = radius ** 2;\n    const result = [];\n    for (let i = 0; i < size; i++) {\n        const currentIndices = [];\n        for (let j = 0; j < size; j++) {\n            if (i === j)\n                continue;\n            if (matrix[i][j] <= squaredRadius) {\n                currentIndices.push(j);\n            }\n        }\n        result.push(currentIndices);\n    }\n    return result;\n}\n//# sourceMappingURL=getKeypointsInRadius.js.map","import { getKeypointsInRadius } from './utils/getKeypointsInRadius.js';\n/**\n * Return the best keypoints within the given radius in pixels.\n * @param keypoints - Keypoints to process.\n * @param radius - Minimum distance in pixels between two keypoints.\n * @returns The filtered keypoints.\n */\nexport function getBestKeypointsInRadius(keypoints, radius = 5) {\n    const size = keypoints.length;\n    const keypointsInRadius = getKeypointsInRadius(keypoints, radius);\n    const toIgnore = new Uint8Array(size).fill(0);\n    for (let i = 0; i < size; i++) {\n        const keypoint = keypoints[i];\n        for (const secondKeypointIndex of keypointsInRadius[i]) {\n            const secondKeypoint = keypoints[secondKeypointIndex];\n            if (keypoint.score < secondKeypoint.score) {\n                toIgnore[i] = 1;\n                continue;\n            }\n        }\n    }\n    const result = [];\n    for (let i = 0; i < size; i++) {\n        if (!toIgnore[i]) {\n            result.push(keypoints[i]);\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=getBestKeypointsInRadius.js.map","/**\n * Calculates a new point that is the difference p1 - p2.\n * @param p1 - First point.\n * @param p2 - Second Point.\n * @returns Difference between the two points.\n */\nexport function difference(p1, p2) {\n    return { column: p1.column - p2.column, row: p1.row - p2.row };\n}\n/**\n * Calculates a new point that is the sum p1 + p2.\n * @param p1 - First point.\n * @param p2 - Second Point.\n * @returns Sum of the two points.\n */\nexport function sum(p1, p2) {\n    return { column: p1.column + p2.column, row: p1.row + p2.row };\n}\n/**\n * Normalize a point (more precisely the vector from the origin to the point).\n * @param point - Point to normalize.\n * @returns - Normalized point.\n */\nexport function normalize(point) {\n    const length = Math.hypot(point.column, point.row);\n    return { column: point.column / length, row: point.row / length };\n}\n/**\n * Rotate an array of points by an angle in radians.\n * The rotation is clockwise and the reference is (0,0).\n * @param radians - Angle in radians.\n * @param points - Source points.\n * @returns The points after rotation.\n */\nexport function rotate(radians, points) {\n    const results = [];\n    const cos = Math.cos(radians);\n    const sin = Math.sin(radians);\n    for (const point of points) {\n        results.push({\n            column: cos * point.column - sin * point.row,\n            row: sin * point.column + cos * point.row,\n        });\n    }\n    return results;\n}\n/**\n * Dot product of 2 points assuming vectors starting from (0,0).\n * @param p1 - First point.\n * @param p2 - Second point.\n * @returns Dot product between the two vectors.\n */\nexport function dot(p1, p2) {\n    return p1.column * p2.column + p1.row * p2.row;\n}\n/**\n * Round the coordinates of the point.\n * @param point - The point.\n * @returns Rounded coordinates of the point.\n */\nexport function round(point) {\n    return { column: Math.round(point.column), row: Math.round(point.row) };\n}\n/**\n * Sort an array of points by column then row.\n * @param points - Array of points to sort.\n * @returns Sorted points.\n */\nexport function sortByColumnRow(points) {\n    const sortedPoints = points.slice();\n    sortedPoints.sort((point1, point2) => {\n        if (point1.column < point2.column)\n            return -1;\n        if (point1.column > point2.column)\n            return 1;\n        return point1.row - point2.row;\n    });\n    return sortedPoints;\n}\n//# sourceMappingURL=points.js.map","import { difference, normalize } from '../../utils/geometry/points.js';\n/**\n * The angle in radians of a vector relatively to the x axis.\n * The angle is positive in the clockwise direction.\n * This is an optimized version because it assumes that one of\n * the points is on the line y = 0.\n * @param p1 - First point.\n * @param p2 - Second point.\n * @returns Rotation angle in radians to make the line horizontal. - <= angle <= .\n */\nexport function getAngle(p1, p2) {\n    const diff = difference(p2, p1);\n    const vector = normalize(diff);\n    const angle = Math.acos(vector.column);\n    if (vector.row < 0)\n        return -angle;\n    return angle;\n}\n/**\n * Compute the clockwise angle in radians between the x-axis and the segment p1-p2.\n * @param p1 - First point.\n * @param p2 - Second point.\n * @returns Clockwise angle between x-axis and the segment.\n */\nexport function getClockwiseAngle(p1, p2) {\n    const diff = difference(p2, p1);\n    const vector = normalize(diff);\n    const atan = -Math.atan(vector.row / vector.column);\n    if (vector.column < 0) {\n        if (vector.row < 0) {\n            return atan - Math.PI;\n        }\n        else {\n            return atan + Math.PI;\n        }\n    }\n    else {\n        return atan;\n    }\n}\n//# sourceMappingURL=getAngle.js.map","import { difference, dot, normalize } from './points.js';\n/**\n * Convert radians to degrees.\n * @param radians - Angle in radians.\n * @returns  Angle in degrees.\n */\nexport function toDegrees(radians) {\n    return (radians * 180) / Math.PI;\n}\n/**\n * Returns the angle between 3 points. The first one is the point where the angle is.\n * @param origin - Origin where the angle has to be measured.\n * @param p1 - First point.\n * @param p2 - Second point.\n * @returns The angle in radians.\n */\nexport function angle(origin, p1, p2) {\n    const v1 = normalize(difference(p1, origin));\n    const v2 = normalize(difference(p2, origin));\n    const dotProduct = dot(v1, v2);\n    // TODO this code is not correct because it may return the opposite angle\n    return Math.acos(dotProduct);\n}\n//# sourceMappingURL=angles.js.map","/**\n * Compute the radius of the circle of given size.\n * @param size - Size of the circle.\n * @returns The radius.\n */\nexport function getRadius(size) {\n    if (size % 2 !== 1 || size < 0) {\n        throw new RangeError('size must be positive and odd');\n    }\n    return (size - 1) / 2;\n}\n//# sourceMappingURL=getRadius.js.map","/**\n * Check that a point is not too close to the border of the image.\n * @param image - Image to process.\n * @param point - The interest point.\n * @param distance - The minimum distance to the border required.\n * @returns Whether the point is far enough from the border.\n */\nexport function checkBorderDistance(image, point, distance) {\n    return (point.column >= distance &&\n        point.row >= distance &&\n        image.width - point.column > distance &&\n        image.height - point.row > distance);\n}\n//# sourceMappingURL=checkBorderDistance.js.map","const t=Symbol.for(\"@ts-pattern/matcher\"),e=Symbol.for(\"@ts-pattern/isVariadic\"),n=\"@ts-pattern/anonymous-select-key\",r=t=>Boolean(t&&\"object\"==typeof t),i=e=>e&&!!e[t],o=(n,s,c)=>{if(i(n)){const e=n[t](),{matched:r,selections:i}=e.match(s);return r&&i&&Object.keys(i).forEach(t=>c(t,i[t])),r}if(r(n)){if(!r(s))return!1;if(Array.isArray(n)){if(!Array.isArray(s))return!1;let t=[],r=[],u=[];for(const o of n.keys()){const s=n[o];i(s)&&s[e]?u.push(s):u.length?r.push(s):t.push(s)}if(u.length){if(u.length>1)throw new Error(\"Pattern error: Using `...P.array(...)` several times in a single pattern is not allowed.\");if(s.length<t.length+r.length)return!1;const e=s.slice(0,t.length),n=0===r.length?[]:s.slice(-r.length),i=s.slice(t.length,0===r.length?Infinity:-r.length);return t.every((t,n)=>o(t,e[n],c))&&r.every((t,e)=>o(t,n[e],c))&&(0===u.length||o(u[0],i,c))}return n.length===s.length&&n.every((t,e)=>o(t,s[e],c))}return Reflect.ownKeys(n).every(e=>{const r=n[e];return(e in s||i(u=r)&&\"optional\"===u[t]().matcherType)&&o(r,s[e],c);var u})}return Object.is(s,n)},s=e=>{var n,o,u;return r(e)?i(e)?null!=(n=null==(o=(u=e[t]()).getSelectionKeys)?void 0:o.call(u))?n:[]:Array.isArray(e)?c(e,s):c(Object.values(e),s):[]},c=(t,e)=>t.reduce((t,n)=>t.concat(e(n)),[]);function u(...t){if(1===t.length){const[e]=t;return t=>o(e,t,()=>{})}if(2===t.length){const[e,n]=t;return o(e,n,()=>{})}throw new Error(`isMatching wasn't given the right number of arguments: expected 1 or 2, received ${t.length}.`)}function a(t){return Object.assign(t,{optional:()=>h(t),and:e=>d(t,e),or:e=>y(t,e),select:e=>void 0===e?v(t):v(e,t)})}function l(t){return Object.assign((t=>Object.assign(t,{[Symbol.iterator](){let n=0;const r=[{value:Object.assign(t,{[e]:!0}),done:!1},{done:!0,value:void 0}];return{next:()=>{var t;return null!=(t=r[n++])?t:r.at(-1)}}}}))(t),{optional:()=>l(h(t)),select:e=>l(void 0===e?v(t):v(e,t))})}function h(e){return a({[t]:()=>({match:t=>{let n={};const r=(t,e)=>{n[t]=e};return void 0===t?(s(e).forEach(t=>r(t,void 0)),{matched:!0,selections:n}):{matched:o(e,t,r),selections:n}},getSelectionKeys:()=>s(e),matcherType:\"optional\"})})}const f=(t,e)=>{for(const n of t)if(!e(n))return!1;return!0},g=(t,e)=>{for(const[n,r]of t.entries())if(!e(r,n))return!1;return!0},m=(t,e)=>{const n=Reflect.ownKeys(t);for(const r of n)if(!e(r,t[r]))return!1;return!0};function d(...e){return a({[t]:()=>({match:t=>{let n={};const r=(t,e)=>{n[t]=e};return{matched:e.every(e=>o(e,t,r)),selections:n}},getSelectionKeys:()=>c(e,s),matcherType:\"and\"})})}function y(...e){return a({[t]:()=>({match:t=>{let n={};const r=(t,e)=>{n[t]=e};return c(e,s).forEach(t=>r(t,void 0)),{matched:e.some(e=>o(e,t,r)),selections:n}},getSelectionKeys:()=>c(e,s),matcherType:\"or\"})})}function p(e){return{[t]:()=>({match:t=>({matched:Boolean(e(t))})})}}function v(...e){const r=\"string\"==typeof e[0]?e[0]:void 0,i=2===e.length?e[1]:\"string\"==typeof e[0]?void 0:e[0];return a({[t]:()=>({match:t=>{let e={[null!=r?r:n]:t};return{matched:void 0===i||o(i,t,(t,n)=>{e[t]=n}),selections:e}},getSelectionKeys:()=>[null!=r?r:n].concat(void 0===i?[]:s(i))})})}function b(t){return!0}function w(t){return\"number\"==typeof t}function S(t){return\"string\"==typeof t}function j(t){return\"bigint\"==typeof t}const K=a(p(b)),O=a(p(b)),E=K,x=t=>Object.assign(a(t),{startsWith:e=>{return x(d(t,(n=e,p(t=>S(t)&&t.startsWith(n)))));var n},endsWith:e=>{return x(d(t,(n=e,p(t=>S(t)&&t.endsWith(n)))));var n},minLength:e=>x(d(t,(t=>p(e=>S(e)&&e.length>=t))(e))),length:e=>x(d(t,(t=>p(e=>S(e)&&e.length===t))(e))),maxLength:e=>x(d(t,(t=>p(e=>S(e)&&e.length<=t))(e))),includes:e=>{return x(d(t,(n=e,p(t=>S(t)&&t.includes(n)))));var n},regex:e=>{return x(d(t,(n=e,p(t=>S(t)&&Boolean(t.match(n))))));var n}}),A=x(p(S)),N=t=>Object.assign(a(t),{between:(e,n)=>N(d(t,((t,e)=>p(n=>w(n)&&t<=n&&e>=n))(e,n))),lt:e=>N(d(t,(t=>p(e=>w(e)&&e<t))(e))),gt:e=>N(d(t,(t=>p(e=>w(e)&&e>t))(e))),lte:e=>N(d(t,(t=>p(e=>w(e)&&e<=t))(e))),gte:e=>N(d(t,(t=>p(e=>w(e)&&e>=t))(e))),int:()=>N(d(t,p(t=>w(t)&&Number.isInteger(t)))),finite:()=>N(d(t,p(t=>w(t)&&Number.isFinite(t)))),positive:()=>N(d(t,p(t=>w(t)&&t>0))),negative:()=>N(d(t,p(t=>w(t)&&t<0)))}),P=N(p(w)),k=t=>Object.assign(a(t),{between:(e,n)=>k(d(t,((t,e)=>p(n=>j(n)&&t<=n&&e>=n))(e,n))),lt:e=>k(d(t,(t=>p(e=>j(e)&&e<t))(e))),gt:e=>k(d(t,(t=>p(e=>j(e)&&e>t))(e))),lte:e=>k(d(t,(t=>p(e=>j(e)&&e<=t))(e))),gte:e=>k(d(t,(t=>p(e=>j(e)&&e>=t))(e))),positive:()=>k(d(t,p(t=>j(t)&&t>0))),negative:()=>k(d(t,p(t=>j(t)&&t<0)))}),T=k(p(j)),B=a(p(function(t){return\"boolean\"==typeof t})),_=a(p(function(t){return\"symbol\"==typeof t})),W=a(p(function(t){return null==t})),$=a(p(function(t){return null!=t}));var z={__proto__:null,matcher:t,optional:h,array:function(...e){return l({[t]:()=>({match:t=>{if(!Array.isArray(t))return{matched:!1};if(0===e.length)return{matched:!0};const n=e[0];let r={};if(0===t.length)return s(n).forEach(t=>{r[t]=[]}),{matched:!0,selections:r};const i=(t,e)=>{r[t]=(r[t]||[]).concat([e])};return{matched:t.every(t=>o(n,t,i)),selections:r}},getSelectionKeys:()=>0===e.length?[]:s(e[0])})})},set:function(...e){return a({[t]:()=>({match:t=>{if(!(t instanceof Set))return{matched:!1};let n={};if(0===t.size)return{matched:!0,selections:n};if(0===e.length)return{matched:!0};const r=(t,e)=>{n[t]=(n[t]||[]).concat([e])},i=e[0];return{matched:f(t,t=>o(i,t,r)),selections:n}},getSelectionKeys:()=>0===e.length?[]:s(e[0])})})},map:function(...e){return a({[t]:()=>({match:t=>{if(!(t instanceof Map))return{matched:!1};let n={};if(0===t.size)return{matched:!0,selections:n};const r=(t,e)=>{n[t]=(n[t]||[]).concat([e])};if(0===e.length)return{matched:!0};var i;if(1===e.length)throw new Error(`\\`P.map\\` wasn't given enough arguments. Expected (key, value), received ${null==(i=e[0])?void 0:i.toString()}`);const[s,c]=e;return{matched:g(t,(t,e)=>{const n=o(s,e,r),i=o(c,t,r);return n&&i}),selections:n}},getSelectionKeys:()=>0===e.length?[]:[...s(e[0]),...s(e[1])]})})},record:function(...e){return a({[t]:()=>({match:t=>{if(null===t||\"object\"!=typeof t||Array.isArray(t))return{matched:!1};var n;if(0===e.length)throw new Error(`\\`P.record\\` wasn't given enough arguments. Expected (value) or (key, value), received ${null==(n=e[0])?void 0:n.toString()}`);let r={};const i=(t,e)=>{r[t]=(r[t]||[]).concat([e])},[s,c]=1===e.length?[A,e[0]]:e;return{matched:m(t,(t,e)=>{const n=\"string\"!=typeof t||Number.isNaN(Number(t))?null:Number(t),r=null!==n&&o(s,n,i),u=o(s,t,i),a=o(c,e,i);return(u||r)&&a}),selections:r}},getSelectionKeys:()=>0===e.length?[]:[...s(e[0]),...s(e[1])]})})},intersection:d,union:y,not:function(e){return a({[t]:()=>({match:t=>({matched:!o(e,t,()=>{})}),getSelectionKeys:()=>[],matcherType:\"not\"})})},when:p,select:v,any:K,unknown:O,_:E,string:A,number:P,bigint:T,boolean:B,symbol:_,nullish:W,nonNullable:$,instanceOf:function(t){return a(p(function(t){return e=>e instanceof t}(t)))},shape:function(t){return a(p(u(t)))}};class I extends Error{constructor(t){let e;try{e=JSON.stringify(t)}catch(n){e=t}super(`Pattern matching error: no pattern matches value ${e}`),this.input=void 0,this.input=t}}const L={matched:!1,value:void 0};function M(t){return new R(t,L)}class R{constructor(t,e){this.input=void 0,this.state=void 0,this.input=t,this.state=e}with(...t){if(this.state.matched)return this;const e=t[t.length-1],r=[t[0]];let i;3===t.length&&\"function\"==typeof t[1]?i=t[1]:t.length>2&&r.push(...t.slice(1,t.length-1));let s=!1,c={};const u=(t,e)=>{s=!0,c[t]=e},a=!r.some(t=>o(t,this.input,u))||i&&!Boolean(i(this.input))?L:{matched:!0,value:e(s?n in c?c[n]:c:this.input,this.input)};return new R(this.input,a)}when(t,e){if(this.state.matched)return this;const n=Boolean(t(this.input));return new R(this.input,n?{matched:!0,value:e(this.input,this.input)}:L)}otherwise(t){return this.state.matched?this.state.value:t(this.input)}exhaustive(t=F){return this.state.matched?this.state.value:t(this.input)}run(){return this.exhaustive()}returnType(){return this}narrow(){return this}}function F(t){throw new I(t)}export{I as NonExhaustiveError,z as P,z as Pattern,u as isMatching,M as match};\n//# sourceMappingURL=index.js.map\n","(function(N,J){typeof exports==\"object\"&&typeof module<\"u\"?J(exports):typeof define==\"function\"&&define.amd?define([\"exports\"],J):(N=typeof globalThis<\"u\"?globalThis:N||self,J(N.bresenham={}))})(this,(function(N){\"use strict\";function J(f,a,o,t,e){const h=Math.abs(o-f),r=f<o?1:-1,l=-Math.abs(t-a),M=a<t?1:-1;let i=h+l,n;for(;;){if(e(f,a),n=2*i,n>=l){if(f===o)break;i+=l,f+=r}if(n<=h){if(a===t)break;i+=h,a+=M}}}function U(f,a,o,t,e){const h=f<o?1:-1,r=a<t?1:-1;let l,M=Math.abs(o-f),i=Math.abs(t-a),n=M*M+i*i,c=n===0?1:1/Math.sqrt(n);for(M*=c,i*=c,n=M-i;;){if(e(f,a,Math.abs(n-(M+i))>>16),c=n,l=f,2*c>=-M){if(f===o)break;c+i<16711680&&e(f,a+r,c+i>>16),n-=i,f+=h}if(2*c<=i){if(a===t)break;M-c<16711680&&e(l+h,a,M-c>>16),n+=M,a+=r}}}function w(f,a,o,t,e,h){let r=Math.abs(o-f),l=f<o?1:-1,M=Math.abs(t-a),i=a<t?1:-1,n=r-M,c,q,d,b=r+M==0?1:Math.sqrt(r*r+M*M);for(e=(e+1)/2;;){if(h(f,a,Math.max(0,255*(Math.abs(n-r+M)/b-e+1))),c=n,q=f,2*c>=-r){for(c+=M,d=a;c<b*e&&(t!=d||r>M);c+=r)h(f,d+=i,Math.max(0,255*(Math.abs(c)/b-e+1)));if(f==o)break;c=n,n-=M,f+=l}if(2*c<=M){for(c=r-c;c<b*e&&(o!=q||r<M);c+=M)h(q+=l,a,Math.max(0,255*(Math.abs(c)/b-e+1)));if(a==t)break;n+=r,a+=i}}}function I(f,a=\"assert error\"){if(!f)throw new Error(a)}function P(f,a,o,t,e,h,r,l){var M=f-2*o+e,i=a-2*t+h,n=f-o,c=a-t,q,d,b;I(r>=0,\"width is negative\"),n*(e-o)>0&&(c*(h-t)>0&&Math.abs(n*i)>Math.abs(c*M)&&(f=e,e=n+o,a=h,h=c+t),f==e||r==1?d=(f-o)/M:(b=Math.sqrt(4*r*r*(f-o)*(e-o)+(e-f)*(e-f)),o<f&&(b=-b),d=(2*r*(f-o)-f+e+b)/(2*(1-r)*(e-f))),b=1/(2*d*(1-d)*(r-1)+1),n=(d*d*(f-2*r*o+e)+2*d*(r*o-f)+f)*b,c=(d*d*(a-2*r*t+h)+2*d*(r*t-a)+a)*b,q=d*(r-1)+1,q*=q*b,r=((1-d)*(r-1)+1)*Math.sqrt(b),M=Math.floor(n+.5),i=Math.floor(c+.5),c=(n-f)*(t-a)/(o-f)+a,H(f,a,M,Math.floor(c+.5),M,i,q,l),c=(n-e)*(t-h)/(o-e)+h,t=Math.floor(c+.5),f=o=M,a=i),(a-t)*(h-t)>0&&(a==h||r==1?d=(a-t)/(a-2*t+h):(b=Math.sqrt(4*r*r*(a-t)*(h-t)+(h-a)*(h-a)),t<a&&(b=-b),d=(2*r*(a-t)-a+h+b)/(2*(1-r)*(h-a))),b=1/(2*d*(1-d)*(r-1)+1),n=(d*d*(f-2*r*o+e)+2*d*(r*o-f)+f)*b,c=(d*d*(a-2*r*t+h)+2*d*(r*t-a)+a)*b,q=d*(r-1)+1,q*=q*b,r=((1-d)*(r-1)+1)*Math.sqrt(b),M=Math.floor(n+.5),i=Math.floor(c+.5),n=(o-f)*(c-a)/(t-a)+f,H(f,a,Math.floor(n+.5),i,M,i,q,l),n=(o-e)*(c-h)/(t-h)+e,o=Math.floor(n+.5),f=M,a=t=i),H(f,a,o,t,e,h,r*r,l)}function H(f,a,o,t,e,h,r,l){var M=e-o,i=h-t,n=f-e,c=a-h,q=f-o,d=a-t,b=q*i+d*M,s=q*i-d*M,u;if(I(q*M<=0&&d*i<=0,\"sign of gradient must not change\"),s!=0&&r>0){if(M*M+i*i>q*q+d*d&&(e=f,f-=n,h=a,a-=c,s=-s),q=2*(4*r*M*q+n*n),d=2*(4*r*i*d+c*c),M=f<e?1:-1,i=a<h?1:-1,b=-2*M*i*(2*r*b+n*c),s*M*i<0&&(q=-q,d=-d,b=-b,s=-s),n=4*r*(o-f)*i*s+q/2+b,c=4*r*(a-t)*M*s+d/2+b,r<.5&&(c>b||n<b)){s=(r+1)/2,r=Math.sqrt(r),b=1/(r+1),M=Math.floor((f+2*r*o+e)*b/2+.5),i=Math.floor((a+2*r*t+h)*b/2+.5),n=Math.floor((r*o+f)*b+.5),c=Math.floor((t*r+a)*b+.5),H(f,a,n,c,M,i,s,l),n=Math.floor((r*o+e)*b+.5),c=Math.floor((t*r+h)*b+.5),H(M,i,n,c,e,h,s,l);return}u=n+c-b;do{if(l(f,a),f==e&&a==h)return;o=2*u>c?1:0,t=2*(u+d)<-c?1:0,(2*u<n||t)&&(a+=i,c+=b,u+=n+=q),(2*u>n||o)&&(f+=M,n+=b,u+=c+=d)}while(c<=b&&n>=b)}J(f,a,e,h,l)}function V(f,a,o,t,e,h,r,l){var M=e-o,i=h-t,n=f-e,c=a-h,q=f-o,d=a-t,b=q*i+d*M,s=q*i-d*M,u,z,j;if(I(q*M<=0&&d*i<=0),s!=0&&r>0){if(M*M+i*i>q*q+d*d&&(e=f,f-=n,h=a,a-=c,s=-s),q=2*(4*r*M*q+n*n),d=2*(4*r*i*d+c*c),M=f<e?1:-1,i=a<h?1:-1,b=-2*M*i*(2*r*b+n*c),s*M*i<0&&(q=-q,d=-d,s=-s,b=-b),n=4*r*(o-f)*i*s+q/2+b,c=4*r*(a-t)*M*s+d/2+b,r<.5&&c>n)return s=(r+1)/2,r=Math.sqrt(r),b=1/(r+1),M=Math.floor((f+2*r*o+e)*b/2+.5),i=Math.floor((a+2*r*t+h)*b/2+.5),n=Math.floor((r*o+f)*b+.5),c=Math.floor((t*r+a)*b+.5),V(f,a,n,c,M,i,s,l),n=Math.floor((r*o+e)*b+.5),c=Math.floor((t*r+h)*b+.5),V(M,i,n,c,e,h,s,l);u=n+c-b;do{if(s=Math.min(n-b,b-c),z=Math.max(n-b,b-c),z+=2*z*s*s/(4*z*z+s*s),o=255*Math.abs(u-n-c+b)/z,o<256&&l(f,a,o),j=2*u+c<0){if(a==h)return;n-u<z&&l(f+M,a,255*Math.abs(n-u)/z)}if(2*u+n>0){if(f==e)return;u-c<z&&l(f,a+i,255*Math.abs(u-c)/z),f+=M,n+=b,u+=c+=d}j&&(a+=i,c+=b,u+=n+=q)}while(c<n)}U(f,a,e,h,l)}function y(f,a,o,t,e){let h=-o,r=0,l=t*t,M=h*(2*l+h)+l;do e(f-h,a+r),e(f+h,a+r),e(f+h,a-r),e(f-h,a-r),l=2*M,l>=(h*2+1)*t*t&&(M+=(++h*2+1)*t*t),l<=(r*2+1)*o*o&&(M+=(++r*2+1)*o*o);while(h<=0);for(;r++<t;)e(f,a+r),e(f,a-r)}function x(f,a,o,t,e,h){let r=o*o,l=t*t;const M=Math.sin(e);let i=(r-l)*M;r=Math.sqrt(r-i*M),l=Math.sqrt(l+i*M),o=r+.5,t=l+.5,i=i*o*t/(r*l),Y(f-o,a-t,f+o,a+t,4*i*Math.cos(e),h)}function Y(f,a,o,t,e,h){let r=o-f,l=t-a,M=r*l;if(e===0)return Z(f,a,o,t,h);M!==0&&(M=(M-e)/(M+M)),I(M<=1&&M>=0,\"limit angle to |zd|<=xd*yd\"),r=Math.floor(r*M+.5),l=Math.floor(l*M+.5),H(f,a+l,f,a,f+r,a,1-M,h),H(f,a+l,f,t,o-r,t,M,h),H(o,t-l,o,t,o-r,t,1-M,h),H(o,t-l,o,a,f+r,a,M,h)}function Z(f,a,o,t,e){let h=Math.abs(o-f),r=Math.abs(t-a),l=r&1,M=4*(1-h)*r*r,i=4*(l+1)*h*h,n=M+i+l*h*h,c;f>o&&(f=o,o+=h),a>t&&(a=t),a+=(r+1)/2,t=a-l,h=8*h*h,l=8*r*r;do e(o,a),e(f,a),e(f,t),e(o,t),c=2*n,c<=i&&(a++,t--,n+=i+=h),(c>=M||2*n>i)&&(f++,o--,n+=M+=l);while(f<=o);for(;a-t<=r;)e(f-1,a),e(o+1,a++),e(f-1,t),e(o+1,t--)}function aa(f,a,o,t){var e=-o,h=0,r=2-2*o;do t(f-e,a+h),t(f-h,a-e),t(f+e,a-h),t(f+h,a+e),o=r,o<=h&&(r+=++h*2+1),(o>e||r>h)&&(r+=++e*2+1);while(e<0)}function fa(f,a,o,t){var e=-o,h=0,r,l,M,i=2-2*o;o=1-i;do r=255*Math.abs(i-2*(e+h)-2)/o,t(f-e,a+h,r),t(f-h,a-e,r),t(f+e,a-h,r),t(f+h,a+e,r),M=i,l=e,i+h>0&&(r=255*(i-2*e-1)/o,r<256&&(t(f-e,a+h+1,r),t(f-h-1,a-e,r),t(f+e,a-h-1,r),t(f+h+1,a+e,r)),i+=++e*2+1),M+l<=0&&(r=255*(2*h+3-M)/o,r<256&&(t(f-l-1,a+h,r),t(f-h,a-l-1,r),t(f+l+1,a-h,r),t(f+h,a+l+1,r)),i+=++h*2+1);while(e<0)}function ta(f,a,o,t,e,h,r){var l=f-o,M=a-t,i=f-2*o+e,n;l*(e-o)>0&&(M*(h-t)>0&&Math.abs((a-2*t+h)/i*l)>Math.abs(M)&&(f=e,e=l+o,a=h,h=M+t),i=(f-o)/i,n=(1-i)*((1-i)*a+2*i*t)+i*i*h,i=(f*e-o*o)*i/(f-o),l=Math.floor(i+.5),M=Math.floor(n+.5),n=(t-a)*(i-f)/(o-f)+a,L(f,a,l,Math.floor(n+.5),l,M,r),n=(t-h)*(i-e)/(o-e)+h,f=o=l,a=M,t=Math.floor(n+.5)),(a-t)*(h-t)>0&&(i=a-2*t+h,i=(a-t)/i,n=(1-i)*((1-i)*f+2*i*o)+i*i*e,i=(a*h-t*t)*i/(a-t),l=Math.floor(n+.5),M=Math.floor(i+.5),n=(o-f)*(i-a)/(t-a)+f,L(f,a,Math.floor(n+.5),M,l,M,r),n=(o-e)*(i-h)/(t-h)+e,f=l,o=Math.floor(n+.5),a=t=M),L(f,a,o,t,e,h,r)}function L(f,a,o,t,e,h,r){var l=e-o,M=h-t,i=f-o,n=a-t,c,q,d,b,s=i*M-n*l;if(I(i*l<=0&&n*M<=0,\"sign of gradient must not change\"),l*l+M*M>i*i+n*n&&(e=f,f=l+o,h=a,a=M+t,s=-s),s!=0){i+=l,i*=l=f<e?1:-1,n+=M,n*=M=a<h?1:-1,c=2*i*n,i*=i,n*=n,s*l*M<0&&(i=-i,n=-n,c=-c,s=-s),q=4*M*s*(o-f)+i-c,d=4*l*s*(a-t)+n-c,i+=i,n+=n,b=q+d+c;do{if(r(f,a),f==e&&a==h)return;t=+(2*b<q),2*b>d&&(f+=l,q-=c,b+=d+=n),t&&(a+=M,d-=c,b+=q+=i)}while(d<0&&q>0)}J(f,a,e,h,r)}function ia(f,a,o,t,e,h,r){var l=f-o,M=a-t,i=f-2*o+e,n;l*(e-o)>0&&(M*(h-t)>0&&Math.abs((a-2*t+h)/i*l)>Math.abs(M)&&(f=e,e=l+o,a=h,h=M+t),i=(f-o)/i,n=(1-i)*((1-i)*a+2*i*t)+i*i*h,i=(f*e-o*o)*i/(f-o),l=Math.floor(i+.5),M=Math.floor(n+.5),n=(t-a)*(i-f)/(o-f)+a,Q(f,a,l,Math.floor(n+.5),l,M,r),n=(t-h)*(i-e)/(o-e)+h,f=o=l,a=M,t=Math.floor(n+.5)),(a-t)*(h-t)>0&&(i=a-2*t+h,i=(a-t)/i,n=(1-i)*((1-i)*f+2*i*o)+i*i*e,i=(a*h-t*t)*i/(a-t),l=Math.floor(n+.5),M=Math.floor(i+.5),n=(o-f)*(i-a)/(t-a)+f,Q(f,a,Math.floor(n+.5),M,l,M,r),n=(o-e)*(i-h)/(t-h)+e,f=l,o=Math.floor(n+.5),a=t=M),Q(f,a,o,t,e,h,r)}function Q(f,a,o,t,e,h,r){var l=e-o,M=h-t,i=f-o,n=a-t,c,q,d,b,s,u=i*M-n*l;if(l*l+M*M>i*i+n*n&&(e=f,f=l+o,h=a,a=M+t,u=-u),u!=0){i+=l,i*=l=f<e?1:-1,n+=M,n*=M=a<h?1:-1,c=2*i*n,i*=i,n*=n,u*l*M<0&&(i=-i,n=-n,c=-c,u=-u),q=4*M*(o-f)*u+i-c,d=4*l*(a-t)*u+n-c,i+=i,n+=n,b=q+d+c;do{if(u=Math.min(q+c,-c-d),s=Math.max(q+c,-c-d),s+=2*s*u*u/(4*s*s+u*u),r(f,a,255*Math.abs(b-q-d-c)/s),f==e||a==h)break;o=f,u=q-b,t=+(2*b+d<0),2*b+q>0&&(b-d<s&&r(f,a+M,255*Math.abs(b-d)/s),f+=l,q-=c,b+=d+=n),t&&(u<s&&r(o+l,a,255*Math.abs(u)/s),a+=M,d-=c,b+=q+=i)}while(d<q)}U(f,a,e,h,r)}function _(f,a,o,t,e,h,r,l,M){var i,n,c,q=1;let d=f<r?1:-1,b=a<l?1:-1,s=-Math.abs(f+o-e-r),u=s-4*d*(o-e),z=d*(f-o-e+r),j=-Math.abs(a+t-h-l),B=j-4*b*(t-h),R=b*(a-t-h+l),p,S,W,T,G,E,O,v,g,k,F,D=.01;if(I((o-f)*(e-r)<D&&((r-f)*(o-e)<D||z*z<u*s+D),\"slope change\"),I((t-a)*(h-l)<D&&((l-a)*(t-h)<D||R*R<B*j+D),\"slope change\"),u==0&&B==0)return d=Math.floor((3*o-f+1)/2),b=Math.floor((3*t-a+1)/2),L(f,a,d,b,r,l,M);o=(o-f)*(o-f)+(t-a)*(t-a)+1,e=(e-r)*(e-r)+(h-l)*(h-l)+1;do{p=u*R-z*B,S=u*j-s*B,W=z*j-s*R,k=p*(p+S-3*W)+S*S,i=k>0?1:Math.sqrt(1+1024/o),p*=i,S*=i,W*=i,k*=i*i,E=9*(p+S+W)/8,T=8*(u-B),v=27*(8*p*(R*R-B*j)+k*(B+2*R+j))/64-B*B*(E-B),g=27*(8*p*(z*z-u*s)-k*(u+2*z+s))/64-u*u*(E+u),G=3*(3*p*(3*R*R-B*B-2*B*j)-B*(3*S*(B+R)+B*T))/4,O=3*(3*p*(3*z*z-u*u-2*u*s)-u*(3*S*(u+z)+u*T))/4,E=u*B*(6*p+6*S-3*W+T),S=B*B,T=u*u,E=3*(E+9*i*(T*R*j-z*s*S)-18*z*R*p)/8,k<0&&(v=-v,g=-g,G=-G,O=-O,E=-E,S=-S,T=-T),p=6*B*S,S=-6*u*S,W=6*B*T,T=-6*u*T,v+=E,k=v+g,g+=E;a:for(F=E,n=c=i;f!=r&&a!=l;){M(f,a);do{if(v>F||g<F)break a;t=2*k-g,2*k>=v&&(n--,k+=v+=G,g+=E+=S,O+=W,G+=p),t<=0&&(c--,k+=g+=O,v+=E+=W,G+=S,O+=T)}while(n>0&&c>0);2*n<=i&&(f+=d,n+=i),2*c<=i&&(a+=b,c+=i),F==E&&v<0&&g>0&&(F=D)}G=f,f=r,r=G,d=-d,z=-z,O=a,a=l,l=O,b=-b,R=-R,o=e}while(q--);J(f,a,r,l,M)}function $(f,a,o,t,e,h,r,l,M){let i,n,c,q=1,d=f<r?1:-1,b=a<l?1:-1,s=-Math.abs(f+o-e-r),u=s-4*d*(o-e),z=d*(f-o-e+r),j=-Math.abs(a+t-h-l),B=j-4*b*(t-h),R=b*(a-t-h+l),p,S,W,T,G,E,O,v,g,k,F,D,C,A;const K=.01;if(I((o-f)*(e-r)<K&&((r-f)*(o-e)<K||z*z<u*s+K)),I((t-a)*(h-l)<K&&((l-a)*(t-h)<K||R*R<B*j+K)),u===0&&B===0)return d=Math.floor((3*o-f+1)/2),b=Math.floor((3*t-a+1)/2),Q(f,a,d,b,r,l,M);o=(o-f)*(o-f)+(t-a)*(t-a)+1,e=(e-r)*(e-r)+(h-l)*(h-l)+1;do{p=u*R-z*B,S=u*j-s*B,W=z*j-s*R,A=4*p*W-S*S,k=p*(p+S-3*W)+S*S,i=k>0?1:Math.sqrt(1+1024/o),p*=i,S*=i,W*=i,k*=i*i,E=9*(p+S+W)/8,T=8*(u-B),v=27*(8*p*(R*R-B*j)+k*(B+2*R+j))/64-B*B*(E-B),g=27*(8*p*(z*z-u*s)-k*(u+2*z+s))/64-u*u*(E+u),G=3*(3*p*(3*R*R-B*B-2*B*j)-B*(3*S*(B+R)+B*T))/4,O=3*(3*p*(3*z*z-u*u-2*u*s)-u*(3*S*(u+z)+u*T))/4,E=u*B*(6*p+6*S-3*W+T),S=B*B,T=u*u,E=3*(E+9*i*(T*R*j-z*s*S)-18*z*R*p)/8,k<0&&(v=-v,g=-g,G=-G,O=-O,E=-E,S=-S,T=-T),p=6*B*S,S=-6*u*S,W=6*B*T,T=-6*u*T,v+=E,k=v+g,g+=E;let X=!1;a:for(n=c=i;f!==r&&a!==l;){t=Math.min(Math.abs(E-v),Math.abs(g-E)),C=Math.max(Math.abs(E-v),Math.abs(g-E)),C=i*(C+2*C*t*t/(4*C*C+t*t)),t=255*Math.abs(k-(i-n+1)*v-(i-c+1)*g+i*E)/C,t<256&&M(f,a,t),F=Math.abs(k-(i-n+1)*v+(c-1)*g),D=Math.abs(k+(n-1)*v-(i-c+1)*g),h=a;do{if(A>=-K&&(v+G>E||g+O<E)){X=!0;break a}if(t=2*k+v,2*k+g>0)n--,k+=v+=G,g+=E+=S,O+=W,G+=p;else if(t>0){X=!0;break a}t<=0&&(c--,k+=g+=O,v+=E+=W,G+=S,O+=T)}while(n>0&&c>0);2*c<=i&&(D<C&&M(f+d,a,255*D/C),a+=b,c+=i),2*n<=i&&(F<C&&M(f,h+b,255*F/C),f+=d,n+=i)}X&&(2*k<g&&2*c<=i+2&&(D<C&&M(f+d,a,255*D/C),a+=b),2*k>v&&2*n<=i+2&&(F<C&&M(f,h+b,255*F/C),f+=d),G=f,f=r,r=G,d=-d,z=-z,O=a,a=l,l=O,b=-b,R=-R,o=e);break}while(q--);U(Math.floor(f),Math.floor(a),Math.floor(r),Math.floor(l),M)}function m(f,a,o,t,e,h,r,l,M,i){let n=0,c=0,q=f+o-e-r,d=q-4*(o-e),b=f-o-e+r,s=b+4*(o+e),u=a+t-h-l,z=u-4*(t-h),j=a-t-h+l,B=j+4*(t+h);var R=f,p,S,W,T=a,G,E,O;let v=b*b-d*q,g;const k=[0,0,0,0,0];for(d==0?Math.abs(q)<2*Math.abs(b)&&(k[n++]=q/(2*b)):v>0&&(g=Math.sqrt(v),v=(b-g)/d,Math.abs(v)<1&&(k[n++]=v),v=(b+g)/d,Math.abs(v)<1&&(k[n++]=v)),v=j*j-z*u,z==0?Math.abs(u)<2*Math.abs(j)&&(k[n++]=u/(2*j)):v>0&&(g=Math.sqrt(v),v=(j-g)/z,Math.abs(v)<1&&(k[n++]=v),v=(j+g)/z,Math.abs(v)<1&&(k[n++]=v)),c=1;c<n;c++)(v=k[c-1])>k[c]&&(k[c-1]=k[c],k[c]=v,c=0);for(v=-1,k[n]=1,c=0;c<=n;c++)g=k[c],p=(v*(v*b-2*q)-g*(v*(v*d-2*b)+q)+s)/8-R,G=(v*(v*j-2*u)-g*(v*(v*z-2*j)+u)+B)/8-T,S=(g*(g*b-2*q)-v*(g*(g*d-2*b)+q)+s)/8-R,E=(g*(g*j-2*u)-v*(g*(g*z-2*j)+u)+B)/8-T,R-=W=(g*(g*(3*b-g*d)-3*q)+s)/8,T-=O=(g*(g*(3*j-g*z)-3*u)+B)/8,r=Math.floor(W+.5),l=Math.floor(O+.5),R!=0&&(p*=R=(f-r)/R,S*=R),T!=0&&(G*=T=(a-l)/T,E*=T),(f!=r||a!=l)&&M(f,a,f+p,a+G,f+S,a+E,r,l,i),f=r,a=l,R=W,T=O,v=g}function ra(f,a,o,t,e,h,r,l,M){m(f,a,o,t,e,h,r,l,_,M)}function oa(f,a,o,t,e,h,r,l,M){m(f,a,o,t,e,h,r,l,$,M)}N.circle=aa,N.circleAA=fa,N.cubicBezier=ra,N.cubicBezierAA=oa,N.cubicBezierSegment=_,N.cubicBezierSegmentAA=$,N.ellipse=y,N.ellipseRect=Z,N.line=J,N.lineAA=U,N.lineWidth=w,N.quadBezier=ta,N.quadBezierAA=ia,N.quadBezierSegment=L,N.quadBezierSegmentAA=Q,N.quadRationalBezier=P,N.quadRationalBezierSegment=H,N.quadRationalBezierSegmentAA=V,N.rotatedEllipse=x,N.rotatedEllipseRect=Y,Object.defineProperty(N,Symbol.toStringTag,{value:\"Module\"})}));\n","/**\n * Remove duplicate points from array.\n * @param points - Polygon points array.\n * @returns Cleaned polygon points array.\n */\nexport function deleteDuplicates(points) {\n    const finalPoints = [];\n    for (let i = 0; i < points.length; i++) {\n        if (points[i].column === points[(i + 1) % points.length].column &&\n            points[i].row === points[(i + 1) % points.length].row) {\n            continue;\n        }\n        else {\n            finalPoints.push(points[i]);\n        }\n    }\n    return finalPoints;\n}\n//# sourceMappingURL=deleteDuplicates.js.map","import { circle, line } from 'bresenham-zingl';\nimport { deleteDuplicates } from '../../draw/utils/deleteDuplicates.js';\nimport { sortByColumnRow } from './points.js';\n/**\n * Get the coordinates of the points on a circle. The reference is the center of the circle.\n * The first point is the right one and they are then sorted clockwise.\n * @param radius - Radius of the circle.\n * @returns The coordinates of the points on a circle of given diameter.\n */\nexport function getCirclePoints(radius) {\n    const circlePoints = [];\n    circle(radius, radius, radius, (column, row) => {\n        circlePoints.push({ row: row - radius, column: column - radius });\n    });\n    const firstQuarter = [];\n    const secondQuarter = [];\n    const thirdQuarter = [];\n    const fourthQuarter = [];\n    for (let i = 0; i < circlePoints.length; i = i + 4) {\n        firstQuarter.push(circlePoints[i % circlePoints.length]);\n        secondQuarter.push(circlePoints[(i + 1) % circlePoints.length]);\n        thirdQuarter.push(circlePoints[(i + 2) % circlePoints.length]);\n        fourthQuarter.push(circlePoints[(i + 3) % circlePoints.length]);\n    }\n    return firstQuarter.concat(secondQuarter, thirdQuarter, fourthQuarter);\n}\nconst zeroPoint = { row: 0, column: 0 };\n/**\n * Get the coordinates of the points in a circle of given radius. The points are sorted by column then row.\n * @param radius - Radius of the circle.\n * @param center - Center of the circle.\n * @returns The coordinates of the points in a circle of given radius.\n */\nexport function getFilledCirclePoints(radius, center = zeroPoint) {\n    const circlePoints = [];\n    if (radius === 0) {\n        return [center];\n    }\n    if (radius === 1) {\n        circlePoints.push(center);\n    }\n    circle(center.column, center.row, radius, (column, row) => {\n        circlePoints.push({ row, column });\n        if (column - 1 > center.column) {\n            circlePoints.push(...getLinePoints({ row, column: column - 1 }, { row, column: center.column }));\n        }\n        else if (column + 1 < center.column) {\n            circlePoints.push(...getLinePoints({ row, column: column + 1 }, { row, column: center.column }));\n        }\n    });\n    const sorted = sortByColumnRow(circlePoints);\n    return deleteDuplicates(sorted);\n}\n/**\n * Get the coordinates of the points on a line.\n * @param from - Starting point.\n * @param to - End point.\n * @returns The coordinates of the points on the line.\n */\nexport function getLinePoints(from, to) {\n    const linePoints = [];\n    line(from.column, from.row, to.column, to.row, (column, row) => {\n        linePoints.push({\n            row,\n            column,\n        });\n    });\n    return linePoints;\n}\n/**\n * Get the coordinates of the points that are on right, bottom, left and top at a given radius. The reference is the origin of the circle.\n * First point is the most on the right, then points are in clockwise order.\n * @param radius - Radius of the circle.\n * @returns The coordinates of the compass points.\n */\nexport function getCompassPoints(radius) {\n    const circlePoints = [];\n    circle(radius, radius, radius, (column, row) => {\n        circlePoints.push({ row: row - radius, column: column - radius });\n    });\n    return [\n        { row: 0, column: radius },\n        { row: radius, column: 0 },\n        { row: 0, column: -radius },\n        { row: -radius, column: 0 },\n    ];\n}\n//# sourceMappingURL=getCirclePoints.js.map","/**\n * Compute the current pixel index based on the value coordinates.\n * @param column - Column of the value.\n * @param row - Row of the value.\n * @param image - The image that is being processed.\n * @param channel - Value channel.\n * @returns The value index.\n */\nexport function getIndex(column, row, image, channel = 0) {\n    return (row * image.width + column) * image.channels + channel;\n}\n//# sourceMappingURL=getIndex.js.map","/**\n * Coordinates of the surrounding pixels relative to the current pixel.\n * First pixel is the one on the right, then they are in clockwise order.\n */\nexport const surroundingPixels = [\n    { row: 0, column: 1 },\n    { row: 1, column: 1 },\n    { row: 1, column: 0 },\n    { row: 1, column: -1 },\n    { row: 0, column: -1 },\n    { row: -1, column: -1 },\n    { row: -1, column: 0 },\n    { row: -1, column: 1 },\n];\n//# sourceMappingURL=surroundingPixels.js.map","const formatter = new Intl.ListFormat('en', { type: 'disjunction' });\n/**\n * This method checks if a process can be applied on the current image.\n * @param image - Image for which compatibility has to be checked.\n * @param options - Check processable options.\n */\nexport default function checkProcessable(image, options = {}) {\n    let { bitDepth, alpha, colorModel, components, channels } = options;\n    if (bitDepth) {\n        if (!Array.isArray(bitDepth)) {\n            bitDepth = [bitDepth];\n        }\n        if (!bitDepth.includes(image.bitDepth)) {\n            throw new RangeError(`image bitDepth must be ${format(bitDepth)} to apply this algorithm`);\n        }\n    }\n    if (alpha) {\n        if (!Array.isArray(alpha)) {\n            alpha = [alpha];\n        }\n        if (!alpha.includes(image.alpha)) {\n            throw new RangeError(`image alpha must be ${format(alpha)} to apply this algorithm`);\n        }\n    }\n    if (colorModel) {\n        if (!Array.isArray(colorModel)) {\n            colorModel = [colorModel];\n        }\n        if (!colorModel.includes(image.colorModel)) {\n            throw new RangeError(`image colorModel must be ${format(colorModel)} to apply this algorithm`);\n        }\n    }\n    if (components) {\n        if (!Array.isArray(components)) {\n            components = [components];\n        }\n        if (!components.includes(image.components)) {\n            const errorMessage = `image components must be ${format(components)} to apply this algorithm`;\n            if (components.length === 1 && components[0] === 1) {\n                throw new RangeError(`${errorMessage}. The image can be converted using \"image.grey()\"`);\n            }\n            else {\n                throw new RangeError(errorMessage);\n            }\n        }\n    }\n    if (channels) {\n        if (!Array.isArray(channels)) {\n            channels = [channels];\n        }\n        if (!channels.includes(image.channels)) {\n            throw new RangeError(`image channels must be ${format(channels)} to apply this algorithm`);\n        }\n    }\n}\n/**\n * Format array to a string.\n * @param array - Array to format.\n * @returns The formatted string.\n */\nexport function format(array) {\n    return formatter.format(array.map(String));\n}\n//# sourceMappingURL=checkProcessable.js.map","/**\n * Compute the score of a keypoint using the function described in the FAST article.\n * DOI: https://doi.org/10.1007/11744023_34.\n * @param image - Image to process.\n * @param origin - Keypoint coordinates.\n * @param threshold - FAST threshold.\n * @param circlePoints - Coordinates of the points on the circle.\n * @returns Score of the corner.\n */\nexport function getFastScore(image, origin, threshold, circlePoints) {\n    const currentIntensity = image.getValueByPoint(origin, 0);\n    let brighterSum = 0;\n    let darkerSum = 0;\n    for (const point of circlePoints) {\n        const pointIntensity = image.getValue(origin.column + point.column, origin.row + point.row, 0);\n        if (pointIntensity >= currentIntensity + threshold) {\n            brighterSum += Math.abs(pointIntensity - currentIntensity) - threshold; // circle point is lighter\n        }\n        else if (pointIntensity <= currentIntensity - threshold) {\n            darkerSum += Math.abs(currentIntensity - pointIntensity) - threshold; // circle point is darker\n        }\n    }\n    return Math.max(brighterSum, darkerSum);\n}\n//# sourceMappingURL=getFastScore.js.map","export const DISCRETE_LAPLACE_4 = [\n    [0, 1, 0],\n    [1, -4, 1],\n    [0, 1, 0],\n];\nexport const DISCRETE_LAPLACE_8 = [\n    [1, 1, 1],\n    [1, -8, 1],\n    [1, 1, 1],\n];\nexport const SOBEL_X = [\n    [-1, 0, 1],\n    [-2, 0, 2],\n    [-1, 0, 1],\n];\nexport const SOBEL_Y = [\n    [-1, -2, -1],\n    [0, 0, 0],\n    [1, 2, 1],\n];\nexport const SCHARR_X = [\n    [3, 0, -3],\n    [10, 0, -10],\n    [3, 0, -3],\n];\nexport const SCHARR_Y = [\n    [3, 10, 3],\n    [0, 0, 0],\n    [-3, -10, -3],\n];\nexport const PREWITT_X = [\n    [1, 0, -1],\n    [1, 0, -1],\n    [1, 0, -1],\n];\nexport const PREWITT_Y = [\n    [1, 1, 1],\n    [0, 0, 0],\n    [-1, -1, -1],\n];\nexport const ROBERTS_X = [\n    [0, 1],\n    [-1, 0],\n];\nexport const ROBERTS_Y = [\n    [1, 0],\n    [0, -1],\n];\nexport const SECOND_DERIVATIVE = [\n    [-1, -2, 0, 2, 1],\n    [-2, -4, 0, 4, 2],\n    [0, 0, 0, 0, 0],\n    [1, 2, 0, -2, -1],\n    [2, 4, 0, -4, -2],\n];\nexport const SECOND_DERIVATIVE_INV = [\n    [1, 2, 0, -2, -1],\n    [2, 4, 0, -4, -2],\n    [0, 0, 0, 0, 0],\n    [-2, -4, 0, 4, 2],\n    [-1, -2, 0, 2, 1],\n];\n//# sourceMappingURL=kernels.js.map","import { EigenvalueDecomposition, Matrix, WrapperMatrix1D } from 'ml-matrix';\nimport { SOBEL_X, SOBEL_Y } from '../../utils/constants/kernels.js';\n/**\n * Get the Harris score of a corner. The idea behind the algorithm is that a\n * slight shift of a window around a corner along x and y shoud result in\n * a very different image.\n *\n * We distinguish 3 cases:\n * - the score is highly negative: you have an edge\n * - the abolute value of the score is small: the region is flat\n * - the score is highly positive: you have a corner.\n * @see {@link https://en.wikipedia.org/wiki/Harris_corner_detector}\n * @param image - Image to which the corner belongs. It must be a greyscale image with only one channel.\n * @param origin - Center of the window, where the corner should be.\n * @param options - Get Harris score options.\n * @returns The Harris score.\n */\nexport function getHarrisScore(image, origin, options = {}) {\n    const { windowSize = 7, harrisConstant = 0.04 } = options;\n    if (!(windowSize % 2)) {\n        throw new TypeError('windowSize must be an odd integer');\n    }\n    const cropOrigin = {\n        row: origin.row - (windowSize - 1) / 2,\n        column: origin.column - (windowSize - 1) / 2,\n    };\n    const window = image.crop({\n        origin: cropOrigin,\n        width: windowSize,\n        height: windowSize,\n    });\n    const xDerivative = window.gradientFilter({ kernelX: SOBEL_X });\n    const yDerivative = window.gradientFilter({ kernelY: SOBEL_Y });\n    const xMatrix = new WrapperMatrix1D(xDerivative.getRawImage().data, {\n        rows: xDerivative.height,\n    });\n    const yMatrix = new WrapperMatrix1D(yDerivative.getRawImage().data, {\n        rows: yDerivative.height,\n    });\n    const xx = xMatrix.mmul(xMatrix);\n    const xy = yMatrix.mmul(xMatrix);\n    const yy = yMatrix.mmul(yMatrix);\n    const xxSum = xx.sum();\n    const xySum = xy.sum();\n    const yySum = yy.sum();\n    const structureTensor = new Matrix([\n        [xxSum, xySum],\n        [xySum, yySum],\n    ]);\n    const eigenValues = new EigenvalueDecomposition(structureTensor)\n        .realEigenvalues;\n    return (eigenValues[0] * eigenValues[1] -\n        harrisConstant * (eigenValues[0] + eigenValues[1]) ** 2);\n}\n//# sourceMappingURL=getHarrisScore.js.map","/**\n * Determine wether a pixel in an image is a corner according to the FAST algorithm.\n * @param origin - Pixel to process.\n * @param image - Image to process.\n * @param circlePoints - Coordinates of the points on the circle.\n * @param compassPoints - Compass points for quick test.\n * @param options - Is FAST keypoint options.\n * @returns Whether the current pixel is a corner or not.\n */\nexport function isFastKeypoint(origin, image, circlePoints, compassPoints, options = {}) {\n    const { nbContiguousPixels = 12, threshold = 20 } = options;\n    const currentIntensity = image.getValueByPoint(origin, 0);\n    let brighter = 0;\n    let darker = 0;\n    // quick test to exlude non corners\n    if (nbContiguousPixels >= 12) {\n        for (const point of compassPoints) {\n            const pointIntensity = image.getValue(origin.column + point.column, origin.row + point.row, 0);\n            if (currentIntensity - pointIntensity > threshold) {\n                darker++;\n            }\n            else if (pointIntensity - currentIntensity > threshold) {\n                brighter++;\n            }\n        }\n        if (darker < 3 && brighter < 3)\n            return false;\n    }\n    // determine whether points on circle are darker or brighter\n    const comparisonArray = [];\n    for (const point of circlePoints) {\n        const pointIntensity = image.getValue(origin.column + point.column, origin.row + point.row, 0);\n        if (currentIntensity + threshold <= pointIntensity) {\n            comparisonArray.push(-1); // circle point is lighter\n        }\n        else if (pointIntensity <= currentIntensity - threshold) {\n            comparisonArray.push(1); // circle point is darker\n        }\n        else {\n            comparisonArray.push(0); // circle point is similar\n        }\n    }\n    // compute number of repeating and touching values\n    let currentLength = 1;\n    const counterArray = [];\n    for (let i = 0; i < comparisonArray.length; i++) {\n        const currentValue = comparisonArray[i];\n        const nextValue = comparisonArray[(i + 1) % comparisonArray.length];\n        if (currentValue === nextValue) {\n            if (i === comparisonArray.length - 1) {\n                if (counterArray.length === 0) {\n                    counterArray.push(currentLength);\n                }\n                else {\n                    counterArray[0] += currentLength;\n                }\n            }\n            else {\n                currentLength++;\n            }\n        }\n        else {\n            counterArray.push(currentLength);\n            currentLength = 1;\n        }\n    }\n    if (Math.max(...counterArray) >= nbContiguousPixels) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n//# sourceMappingURL=isFastKeypoint.js.map","import { match } from 'ts-pattern';\nimport { getCirclePoints, getCompassPoints, } from '../../utils/geometry/getCirclePoints.js';\nimport { getIndex } from '../../utils/getIndex.js';\nimport { surroundingPixels } from '../../utils/surroundingPixels.js';\nimport checkProcessable from '../../utils/validators/checkProcessable.js';\nimport { getFastScore } from './getFastScore.js';\nimport { getHarrisScore } from './getHarrisScore.js';\nimport { isFastKeypoint } from './isFastKeypoint.js';\n/**\n * Find the features in a GREY image according to the FAST (Features from Accelerated Segment Test) algorithm.\n * Based on the paper Machine Learning for High-Speed Corner Detection.\n * DOI: https://doi.org/10.1007/11744023_34.\n * @param image - The image to process.\n * @param options - Get FAST keypoints options.\n * @returns The FAST keypoints.\n */\nexport function getFastKeypoints(image, options = {}) {\n    const { fastRadius = 3, scoreAlgorithm = 'FAST', harrisScoreOptions, } = options;\n    const circlePoints = getCirclePoints(fastRadius);\n    const compassPoints = getCompassPoints(fastRadius);\n    const { maxNbFeatures = 500, nbContiguousPixels = (3 / 4) * circlePoints.length, threshold = 20, nonMaxSuppression = true, } = options;\n    checkProcessable(image, {\n        channels: [1],\n        alpha: false,\n    });\n    const getScore = match(scoreAlgorithm)\n        .with('HARRIS', () => {\n        return (image, corner) => getHarrisScore(image, corner, harrisScoreOptions);\n    })\n        .with('FAST', () => {\n        return (image, corner) => getFastScore(image, corner, threshold, circlePoints);\n    })\n        .exhaustive();\n    const allKeypoints = [];\n    const scoreArray = new Float64Array(image.size).fill(Number.NEGATIVE_INFINITY);\n    for (let row = 0; row < image.height; row++) {\n        for (let column = 0; column < image.width; column++) {\n            const corner = { row, column };\n            if (isFastKeypoint(corner, image, circlePoints, compassPoints, {\n                nbContiguousPixels,\n                threshold,\n            })) {\n                const score = getScore(image, corner);\n                scoreArray[getIndex(corner.column, corner.row, image, 0)] = score;\n                allKeypoints.push({ origin: corner, score });\n            }\n        }\n    }\n    let keypoints = [];\n    if (!nonMaxSuppression) {\n        keypoints = allKeypoints;\n    }\n    else {\n        // Non-Maximal Suppression\n        for (const keypoint of allKeypoints) {\n            const currentScore = scoreArray[getIndex(keypoint.origin.column, keypoint.origin.row, image, 0)];\n            for (let i = 0; i < surroundingPixels.length; i++) {\n                const neighbour = surroundingPixels[i];\n                const neighbourScore = scoreArray[getIndex(keypoint.origin.column + neighbour.column, keypoint.origin.row + neighbour.row, image, 0)];\n                if (neighbourScore > currentScore)\n                    break;\n                if (i === surroundingPixels.length - 1) {\n                    keypoints.push(keypoint);\n                }\n            }\n        }\n    }\n    keypoints.sort((a, b) => b.score - a.score);\n    return keypoints.slice(0, maxNbFeatures);\n}\n//# sourceMappingURL=getFastKeypoints.js.map","import { getFilledCirclePoints } from '../../utils/geometry/getCirclePoints.js';\nimport { checkBorderDistance } from '../utils/checkBorderDistance.js';\n/**\n * Compute the pq order intensity moment of the circular patch with given radius in the image,\n * relatively to the origin defined in the options.\n * Original article: {@link https://doi.org/10.1006/cviu.1998.0719}.\n * @see {@link https://en.wikipedia.org/wiki/Image_moment}\n * @param image - Image to process.\n * @param p - Order along x.\n * @param q - Order along y.\n * @param options - Get intensity moment options.\n * @returns The intensity moment of order pq of the circular window relative to the center.\n */\nexport function getPatchIntensityMoment(image, p, q, options = {}) {\n    const { center: origin = image.getCoordinates('center'), radius = 3 } = options;\n    if (!checkBorderDistance(image, origin, radius)) {\n        throw new RangeError(`desired patch is too close to image border`);\n    }\n    const moment = new Array(image.channels).fill(0);\n    const relativeCirclePoints = getFilledCirclePoints(radius);\n    for (const point of relativeCirclePoints) {\n        for (let channel = 0; channel < image.channels; channel++) {\n            const intensity = image.getValue(point.column + origin.column, point.row + origin.row, channel);\n            moment[channel] += point.column ** p * point.row ** q * intensity;\n        }\n    }\n    return moment;\n}\n//# sourceMappingURL=getPatchIntensityMoment.js.map","import { getPatchIntensityMoment } from './getPatchIntensityMoment.js';\n/**\n * Compute the intensity centroid of the circular patch in an image for each channel relatively to the center of the image.\n * Original article: {@link https://doi.org/10.1006/cviu.1998.0719}.\n * @see {@link https://en.wikipedia.org/wiki/Image_moment}\n * @param image - Image to process.\n * @param options - Patch intensity centroid options.\n * @returns The intensity centroid of each channel of the image.\n */\nexport function getPatchIntensityCentroid(image, options = {}) {\n    const moment10 = getPatchIntensityMoment(image, 1, 0, options);\n    const moment01 = getPatchIntensityMoment(image, 0, 1, options);\n    const moment00 = getPatchIntensityMoment(image, 0, 0, options);\n    const centroid = [];\n    for (let channel = 0; channel < image.channels; channel++) {\n        if (moment00[channel] === 0) {\n            centroid.push({\n                column: 0,\n                row: 0,\n            });\n        }\n        else {\n            centroid.push({\n                column: moment10[channel] / moment00[channel],\n                row: moment01[channel] / moment00[channel],\n            });\n        }\n    }\n    return centroid;\n}\n//# sourceMappingURL=getPatchIntensityCentroid.js.map","import { getClockwiseAngle } from '../../maskAnalysis/utils/getAngle.js';\nimport { toDegrees } from '../../utils/geometry/angles.js';\nimport { getRadius } from '../../utils/getRadius.js';\nimport { checkBorderDistance } from '../utils/checkBorderDistance.js';\nimport { getFastKeypoints } from './getFastKeypoints.js';\nimport { getPatchIntensityCentroid } from './getPatchIntensityCentroid.js';\n/**\n * Find the oriented FAST features in a GREY image.\n * How to add orientation to FAST is described in: http://www.gwylab.com/download/ORB_2012.pdf\n * Basically, the intensity centroid of the window around the corner is computed and the\n * orientation is given by the vector from the center to the intensity centroid.\n * @param image - The image to process.\n * @param options - Get oriented FAST keypoints options.\n * @returns The oriented FAST keypoints.\n */\nexport function getOrientedFastKeypoints(image, options = {}) {\n    const { centroidPatchDiameter: windowSize = 7 } = options;\n    const fastKeypoints = getFastKeypoints(image, options);\n    const radius = getRadius(windowSize);\n    // handle edge cases: remove keypoints too close to border\n    const keypoints = [];\n    for (const keypoint of fastKeypoints) {\n        if (checkBorderDistance(image, keypoint.origin, radius)) {\n            keypoints.push(keypoint);\n        }\n    }\n    const orientedFastKeypoints = [];\n    for (const keypoint of keypoints) {\n        const centroid = getPatchIntensityCentroid(image, {\n            center: keypoint.origin,\n            radius,\n        })[0];\n        const angle = toDegrees(getClockwiseAngle({ column: 0, row: 0 }, centroid));\n        orientedFastKeypoints.push({ ...keypoint, angle });\n    }\n    return orientedFastKeypoints;\n}\n//# sourceMappingURL=getOrientedFastKeypoints.js.map","import { sum } from '../../utils/geometry/points.js';\n/**\n * Compare the intensity of two pixels of a GREY image.\n * @param image - Source image of the pixels.\n * @param p1 - First point.\n * @param p2 - Second point.\n * @param options - Options.\n * @returns Wether p1 is darker that p2.\n */\nexport function compareIntensity(image, p1, p2, options = {}) {\n    const { origin = image.getCoordinates('center') } = options;\n    const absoluteP1 = sum(p1, origin);\n    const absoluteP2 = sum(p2, origin);\n    const intensity1 = image.getValueByPoint(absoluteP1, 0);\n    const intensity2 = image.getValueByPoint(absoluteP2, 0);\n    return intensity1 < intensity2;\n}\n//# sourceMappingURL=compareIntensity.js.map","import { isAnyArray } from 'is-any-array';\n/**\n * Calculates the median of an array.\n * @param input - Array containing values\n * @param options\n * @returns - median\n */\nexport function xMedian(input, options = {}) {\n    if (!isAnyArray(input)) {\n        throw new TypeError('input must be an array');\n    }\n    if (input.length === 0) {\n        throw new TypeError('input must not be empty');\n    }\n    const { exact = false } = options || {};\n    const array = input.slice();\n    const middleIndex = calcMiddle(0, array.length - 1);\n    const median = quickSelect(array, middleIndex);\n    if (array.length % 2 === 1 || !exact) {\n        return median;\n    }\n    const medianNext = quickSelect(array, middleIndex + 1);\n    return (median + medianNext) / 2;\n}\nfunction quickSelect(array, middleIndex) {\n    let low = 0;\n    let high = array.length - 1;\n    let middle = 0;\n    let currentLow = 0;\n    let currentHigh = 0;\n    while (true) {\n        if (high <= low) {\n            return array[middleIndex];\n        }\n        if (high === low + 1) {\n            if (array[low] > array[high]) {\n                swap(array, low, high);\n            }\n            return array[middleIndex];\n        }\n        // Find median of low, middle and high items; swap into position low\n        middle = calcMiddle(low, high);\n        if (array[middle] > array[high])\n            swap(array, middle, high);\n        if (array[low] > array[high])\n            swap(array, low, high);\n        if (array[middle] > array[low])\n            swap(array, middle, low);\n        // Swap low item (now in position middle) into position (low+1)\n        swap(array, middle, low + 1);\n        // Nibble from each end towards middle, swapping items when stuck\n        currentLow = low + 1;\n        currentHigh = high;\n        while (true) {\n            do\n                currentLow++;\n            while (array[low] > array[currentLow]);\n            do\n                currentHigh--;\n            while (array[currentHigh] > array[low]);\n            if (currentHigh < currentLow) {\n                break;\n            }\n            swap(array, currentLow, currentHigh);\n        }\n        // Swap middle item (in position low) back into correct position\n        swap(array, low, currentHigh);\n        // Re-set active partition\n        if (currentHigh <= middleIndex) {\n            low = currentLow;\n        }\n        if (currentHigh >= middleIndex) {\n            high = currentHigh - 1;\n        }\n    }\n}\nfunction swap(array, i, j) {\n    const temp = array[j];\n    array[j] = array[i];\n    array[i] = temp;\n}\nfunction calcMiddle(i, j) {\n    return Math.floor((i + j) / 2);\n}\n//# sourceMappingURL=xMedian.js.map","import { isAnyArray } from 'is-any-array';\n/**\n * Checks if the input is a non-empty array of numbers.\n * Only checks the first element.\n * @param input - Array to check.\n * @param options - Additional checks.\n */\nexport function xCheck(input, options = {}) {\n    const { minLength } = options;\n    if (!isAnyArray(input)) {\n        throw new TypeError('input must be an array');\n    }\n    if (input.length === 0) {\n        throw new TypeError('input must not be empty');\n    }\n    if (typeof input[0] !== 'number') {\n        throw new TypeError('input must contain numbers');\n    }\n    if (minLength && input.length < minLength) {\n        throw new Error(`input must have a length of at least ${minLength}`);\n    }\n}\n//# sourceMappingURL=xCheck.js.map","/**\n * Returns the closest index of a `target`\n * @param array - array of numbers\n * @param target - target\n * @param options\n * @returns - closest index\n */\nexport function xFindClosestIndex(array, target, options = {}) {\n    const { sorted = true } = options;\n    if (sorted) {\n        let low = 0;\n        let high = array.length - 1;\n        let middle = 0;\n        while (high - low > 1) {\n            middle = low + ((high - low) >> 1);\n            if (array[middle] < target) {\n                low = middle;\n            }\n            else if (array[middle] > target) {\n                high = middle;\n            }\n            else {\n                return middle;\n            }\n        }\n        if (low < array.length - 1) {\n            if (Math.abs(target - array[low]) < Math.abs(array[low + 1] - target)) {\n                return low;\n            }\n            else {\n                return low + 1;\n            }\n        }\n        else {\n            return low;\n        }\n    }\n    else {\n        let index = 0;\n        let diff = Number.POSITIVE_INFINITY;\n        for (let i = 0; i < array.length; i++) {\n            const currentDiff = Math.abs(array[i] - target);\n            if (currentDiff < diff) {\n                diff = currentDiff;\n                index = i;\n            }\n        }\n        return index;\n    }\n}\n//# sourceMappingURL=xFindClosestIndex.js.map","import { xFindClosestIndex } from \"./xFindClosestIndex.js\";\n/**\n * Returns an object with {fromIndex, toIndex} for a specific from / to\n * @param x - array of numbers\n * @param options - Options\n */\nexport function xGetFromToIndex(x, options = {}) {\n    let { fromIndex, toIndex } = options;\n    const { from, to } = options;\n    if (fromIndex === undefined) {\n        if (from !== undefined) {\n            fromIndex = xFindClosestIndex(x, from);\n        }\n        else {\n            fromIndex = 0;\n        }\n    }\n    if (toIndex === undefined) {\n        if (to !== undefined) {\n            toIndex = xFindClosestIndex(x, to);\n        }\n        else {\n            toIndex = x.length - 1;\n        }\n    }\n    if (fromIndex < 0)\n        fromIndex = 0;\n    if (toIndex < 0)\n        toIndex = 0;\n    if (fromIndex >= x.length)\n        fromIndex = x.length - 1;\n    if (toIndex >= x.length)\n        toIndex = x.length - 1;\n    if (fromIndex > toIndex)\n        [fromIndex, toIndex] = [toIndex, fromIndex];\n    return { fromIndex, toIndex };\n}\n//# sourceMappingURL=xGetFromToIndex.js.map","import { xCheck } from \"./xCheck.js\";\nimport { xGetFromToIndex } from \"./xGetFromToIndex.js\";\n/**\n * Computes the mean value of an array of values.\n * @param array - array of numbers\n * @param options - options\n */\nexport function xMean(array, options = {}) {\n    xCheck(array);\n    const { fromIndex, toIndex } = xGetFromToIndex(array, options);\n    let sumValue = array[fromIndex];\n    for (let i = fromIndex + 1; i <= toIndex; i++) {\n        sumValue += array[i];\n    }\n    return sumValue / (toIndex - fromIndex + 1);\n}\n//# sourceMappingURL=xMean.js.map","import { isAnyArray } from 'is-any-array';\nimport { xMean } from \"./xMean.js\";\n/**\n * Finds the variance of the data\n * @param values - the values of the array\n * @param options - options\n * @returns variance\n */\nexport function xVariance(values, options = {}) {\n    if (!isAnyArray(values)) {\n        throw new TypeError('input must be an array');\n    }\n    const { unbiased = true, mean = xMean(values) } = options;\n    let sqrError = 0;\n    for (const value of values) {\n        const x = value - mean;\n        sqrError += x * x;\n    }\n    if (unbiased) {\n        return sqrError / (values.length - 1);\n    }\n    else {\n        return sqrError / values.length;\n    }\n}\n//# sourceMappingURL=xVariance.js.map","'use strict';\n\nfunction FFT(size) {\n  this.size = size | 0;\n  if (this.size <= 1 || (this.size & (this.size - 1)) !== 0)\n    throw new Error('FFT size must be a power of two and bigger than 1');\n\n  this._csize = size << 1;\n\n  // NOTE: Use of `var` is intentional for old V8 versions\n  var table = new Array(this.size * 2);\n  for (var i = 0; i < table.length; i += 2) {\n    const angle = Math.PI * i / this.size;\n    table[i] = Math.cos(angle);\n    table[i + 1] = -Math.sin(angle);\n  }\n  this.table = table;\n\n  // Find size's power of two\n  var power = 0;\n  for (var t = 1; this.size > t; t <<= 1)\n    power++;\n\n  // Calculate initial step's width:\n  //   * If we are full radix-4 - it is 2x smaller to give inital len=8\n  //   * Otherwise it is the same as `power` to give len=4\n  this._width = power % 2 === 0 ? power - 1 : power;\n\n  // Pre-compute bit-reversal patterns\n  this._bitrev = new Array(1 << this._width);\n  for (var j = 0; j < this._bitrev.length; j++) {\n    this._bitrev[j] = 0;\n    for (var shift = 0; shift < this._width; shift += 2) {\n      var revShift = this._width - shift - 2;\n      this._bitrev[j] |= ((j >>> shift) & 3) << revShift;\n    }\n  }\n\n  this._out = null;\n  this._data = null;\n  this._inv = 0;\n}\nmodule.exports = FFT;\n\nFFT.prototype.fromComplexArray = function fromComplexArray(complex, storage) {\n  var res = storage || new Array(complex.length >>> 1);\n  for (var i = 0; i < complex.length; i += 2)\n    res[i >>> 1] = complex[i];\n  return res;\n};\n\nFFT.prototype.createComplexArray = function createComplexArray() {\n  const res = new Array(this._csize);\n  for (var i = 0; i < res.length; i++)\n    res[i] = 0;\n  return res;\n};\n\nFFT.prototype.toComplexArray = function toComplexArray(input, storage) {\n  var res = storage || this.createComplexArray();\n  for (var i = 0; i < res.length; i += 2) {\n    res[i] = input[i >>> 1];\n    res[i + 1] = 0;\n  }\n  return res;\n};\n\nFFT.prototype.completeSpectrum = function completeSpectrum(spectrum) {\n  var size = this._csize;\n  var half = size >>> 1;\n  for (var i = 2; i < half; i += 2) {\n    spectrum[size - i] = spectrum[i];\n    spectrum[size - i + 1] = -spectrum[i + 1];\n  }\n};\n\nFFT.prototype.transform = function transform(out, data) {\n  if (out === data)\n    throw new Error('Input and output buffers must be different');\n\n  this._out = out;\n  this._data = data;\n  this._inv = 0;\n  this._transform4();\n  this._out = null;\n  this._data = null;\n};\n\nFFT.prototype.realTransform = function realTransform(out, data) {\n  if (out === data)\n    throw new Error('Input and output buffers must be different');\n\n  this._out = out;\n  this._data = data;\n  this._inv = 0;\n  this._realTransform4();\n  this._out = null;\n  this._data = null;\n};\n\nFFT.prototype.inverseTransform = function inverseTransform(out, data) {\n  if (out === data)\n    throw new Error('Input and output buffers must be different');\n\n  this._out = out;\n  this._data = data;\n  this._inv = 1;\n  this._transform4();\n  for (var i = 0; i < out.length; i++)\n    out[i] /= this.size;\n  this._out = null;\n  this._data = null;\n};\n\n// radix-4 implementation\n//\n// NOTE: Uses of `var` are intentional for older V8 version that do not\n// support both `let compound assignments` and `const phi`\nFFT.prototype._transform4 = function _transform4() {\n  var out = this._out;\n  var size = this._csize;\n\n  // Initial step (permute and transform)\n  var width = this._width;\n  var step = 1 << width;\n  var len = (size / step) << 1;\n\n  var outOff;\n  var t;\n  var bitrev = this._bitrev;\n  if (len === 4) {\n    for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n      const off = bitrev[t];\n      this._singleTransform2(outOff, off, step);\n    }\n  } else {\n    // len === 8\n    for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n      const off = bitrev[t];\n      this._singleTransform4(outOff, off, step);\n    }\n  }\n\n  // Loop through steps in decreasing order\n  var inv = this._inv ? -1 : 1;\n  var table = this.table;\n  for (step >>= 2; step >= 2; step >>= 2) {\n    len = (size / step) << 1;\n    var quarterLen = len >>> 2;\n\n    // Loop through offsets in the data\n    for (outOff = 0; outOff < size; outOff += len) {\n      // Full case\n      var limit = outOff + quarterLen;\n      for (var i = outOff, k = 0; i < limit; i += 2, k += step) {\n        const A = i;\n        const B = A + quarterLen;\n        const C = B + quarterLen;\n        const D = C + quarterLen;\n\n        // Original values\n        const Ar = out[A];\n        const Ai = out[A + 1];\n        const Br = out[B];\n        const Bi = out[B + 1];\n        const Cr = out[C];\n        const Ci = out[C + 1];\n        const Dr = out[D];\n        const Di = out[D + 1];\n\n        // Middle values\n        const MAr = Ar;\n        const MAi = Ai;\n\n        const tableBr = table[k];\n        const tableBi = inv * table[k + 1];\n        const MBr = Br * tableBr - Bi * tableBi;\n        const MBi = Br * tableBi + Bi * tableBr;\n\n        const tableCr = table[2 * k];\n        const tableCi = inv * table[2 * k + 1];\n        const MCr = Cr * tableCr - Ci * tableCi;\n        const MCi = Cr * tableCi + Ci * tableCr;\n\n        const tableDr = table[3 * k];\n        const tableDi = inv * table[3 * k + 1];\n        const MDr = Dr * tableDr - Di * tableDi;\n        const MDi = Dr * tableDi + Di * tableDr;\n\n        // Pre-Final values\n        const T0r = MAr + MCr;\n        const T0i = MAi + MCi;\n        const T1r = MAr - MCr;\n        const T1i = MAi - MCi;\n        const T2r = MBr + MDr;\n        const T2i = MBi + MDi;\n        const T3r = inv * (MBr - MDr);\n        const T3i = inv * (MBi - MDi);\n\n        // Final values\n        const FAr = T0r + T2r;\n        const FAi = T0i + T2i;\n\n        const FCr = T0r - T2r;\n        const FCi = T0i - T2i;\n\n        const FBr = T1r + T3i;\n        const FBi = T1i - T3r;\n\n        const FDr = T1r - T3i;\n        const FDi = T1i + T3r;\n\n        out[A] = FAr;\n        out[A + 1] = FAi;\n        out[B] = FBr;\n        out[B + 1] = FBi;\n        out[C] = FCr;\n        out[C + 1] = FCi;\n        out[D] = FDr;\n        out[D + 1] = FDi;\n      }\n    }\n  }\n};\n\n// radix-2 implementation\n//\n// NOTE: Only called for len=4\nFFT.prototype._singleTransform2 = function _singleTransform2(outOff, off,\n                                                             step) {\n  const out = this._out;\n  const data = this._data;\n\n  const evenR = data[off];\n  const evenI = data[off + 1];\n  const oddR = data[off + step];\n  const oddI = data[off + step + 1];\n\n  const leftR = evenR + oddR;\n  const leftI = evenI + oddI;\n  const rightR = evenR - oddR;\n  const rightI = evenI - oddI;\n\n  out[outOff] = leftR;\n  out[outOff + 1] = leftI;\n  out[outOff + 2] = rightR;\n  out[outOff + 3] = rightI;\n};\n\n// radix-4\n//\n// NOTE: Only called for len=8\nFFT.prototype._singleTransform4 = function _singleTransform4(outOff, off,\n                                                             step) {\n  const out = this._out;\n  const data = this._data;\n  const inv = this._inv ? -1 : 1;\n  const step2 = step * 2;\n  const step3 = step * 3;\n\n  // Original values\n  const Ar = data[off];\n  const Ai = data[off + 1];\n  const Br = data[off + step];\n  const Bi = data[off + step + 1];\n  const Cr = data[off + step2];\n  const Ci = data[off + step2 + 1];\n  const Dr = data[off + step3];\n  const Di = data[off + step3 + 1];\n\n  // Pre-Final values\n  const T0r = Ar + Cr;\n  const T0i = Ai + Ci;\n  const T1r = Ar - Cr;\n  const T1i = Ai - Ci;\n  const T2r = Br + Dr;\n  const T2i = Bi + Di;\n  const T3r = inv * (Br - Dr);\n  const T3i = inv * (Bi - Di);\n\n  // Final values\n  const FAr = T0r + T2r;\n  const FAi = T0i + T2i;\n\n  const FBr = T1r + T3i;\n  const FBi = T1i - T3r;\n\n  const FCr = T0r - T2r;\n  const FCi = T0i - T2i;\n\n  const FDr = T1r - T3i;\n  const FDi = T1i + T3r;\n\n  out[outOff] = FAr;\n  out[outOff + 1] = FAi;\n  out[outOff + 2] = FBr;\n  out[outOff + 3] = FBi;\n  out[outOff + 4] = FCr;\n  out[outOff + 5] = FCi;\n  out[outOff + 6] = FDr;\n  out[outOff + 7] = FDi;\n};\n\n// Real input radix-4 implementation\nFFT.prototype._realTransform4 = function _realTransform4() {\n  var out = this._out;\n  var size = this._csize;\n\n  // Initial step (permute and transform)\n  var width = this._width;\n  var step = 1 << width;\n  var len = (size / step) << 1;\n\n  var outOff;\n  var t;\n  var bitrev = this._bitrev;\n  if (len === 4) {\n    for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n      const off = bitrev[t];\n      this._singleRealTransform2(outOff, off >>> 1, step >>> 1);\n    }\n  } else {\n    // len === 8\n    for (outOff = 0, t = 0; outOff < size; outOff += len, t++) {\n      const off = bitrev[t];\n      this._singleRealTransform4(outOff, off >>> 1, step >>> 1);\n    }\n  }\n\n  // Loop through steps in decreasing order\n  var inv = this._inv ? -1 : 1;\n  var table = this.table;\n  for (step >>= 2; step >= 2; step >>= 2) {\n    len = (size / step) << 1;\n    var halfLen = len >>> 1;\n    var quarterLen = halfLen >>> 1;\n    var hquarterLen = quarterLen >>> 1;\n\n    // Loop through offsets in the data\n    for (outOff = 0; outOff < size; outOff += len) {\n      for (var i = 0, k = 0; i <= hquarterLen; i += 2, k += step) {\n        var A = outOff + i;\n        var B = A + quarterLen;\n        var C = B + quarterLen;\n        var D = C + quarterLen;\n\n        // Original values\n        var Ar = out[A];\n        var Ai = out[A + 1];\n        var Br = out[B];\n        var Bi = out[B + 1];\n        var Cr = out[C];\n        var Ci = out[C + 1];\n        var Dr = out[D];\n        var Di = out[D + 1];\n\n        // Middle values\n        var MAr = Ar;\n        var MAi = Ai;\n\n        var tableBr = table[k];\n        var tableBi = inv * table[k + 1];\n        var MBr = Br * tableBr - Bi * tableBi;\n        var MBi = Br * tableBi + Bi * tableBr;\n\n        var tableCr = table[2 * k];\n        var tableCi = inv * table[2 * k + 1];\n        var MCr = Cr * tableCr - Ci * tableCi;\n        var MCi = Cr * tableCi + Ci * tableCr;\n\n        var tableDr = table[3 * k];\n        var tableDi = inv * table[3 * k + 1];\n        var MDr = Dr * tableDr - Di * tableDi;\n        var MDi = Dr * tableDi + Di * tableDr;\n\n        // Pre-Final values\n        var T0r = MAr + MCr;\n        var T0i = MAi + MCi;\n        var T1r = MAr - MCr;\n        var T1i = MAi - MCi;\n        var T2r = MBr + MDr;\n        var T2i = MBi + MDi;\n        var T3r = inv * (MBr - MDr);\n        var T3i = inv * (MBi - MDi);\n\n        // Final values\n        var FAr = T0r + T2r;\n        var FAi = T0i + T2i;\n\n        var FBr = T1r + T3i;\n        var FBi = T1i - T3r;\n\n        out[A] = FAr;\n        out[A + 1] = FAi;\n        out[B] = FBr;\n        out[B + 1] = FBi;\n\n        // Output final middle point\n        if (i === 0) {\n          var FCr = T0r - T2r;\n          var FCi = T0i - T2i;\n          out[C] = FCr;\n          out[C + 1] = FCi;\n          continue;\n        }\n\n        // Do not overwrite ourselves\n        if (i === hquarterLen)\n          continue;\n\n        // In the flipped case:\n        // MAi = -MAi\n        // MBr=-MBi, MBi=-MBr\n        // MCr=-MCr\n        // MDr=MDi, MDi=MDr\n        var ST0r = T1r;\n        var ST0i = -T1i;\n        var ST1r = T0r;\n        var ST1i = -T0i;\n        var ST2r = -inv * T3i;\n        var ST2i = -inv * T3r;\n        var ST3r = -inv * T2i;\n        var ST3i = -inv * T2r;\n\n        var SFAr = ST0r + ST2r;\n        var SFAi = ST0i + ST2i;\n\n        var SFBr = ST1r + ST3i;\n        var SFBi = ST1i - ST3r;\n\n        var SA = outOff + quarterLen - i;\n        var SB = outOff + halfLen - i;\n\n        out[SA] = SFAr;\n        out[SA + 1] = SFAi;\n        out[SB] = SFBr;\n        out[SB + 1] = SFBi;\n      }\n    }\n  }\n};\n\n// radix-2 implementation\n//\n// NOTE: Only called for len=4\nFFT.prototype._singleRealTransform2 = function _singleRealTransform2(outOff,\n                                                                     off,\n                                                                     step) {\n  const out = this._out;\n  const data = this._data;\n\n  const evenR = data[off];\n  const oddR = data[off + step];\n\n  const leftR = evenR + oddR;\n  const rightR = evenR - oddR;\n\n  out[outOff] = leftR;\n  out[outOff + 1] = 0;\n  out[outOff + 2] = rightR;\n  out[outOff + 3] = 0;\n};\n\n// radix-4\n//\n// NOTE: Only called for len=8\nFFT.prototype._singleRealTransform4 = function _singleRealTransform4(outOff,\n                                                                     off,\n                                                                     step) {\n  const out = this._out;\n  const data = this._data;\n  const inv = this._inv ? -1 : 1;\n  const step2 = step * 2;\n  const step3 = step * 3;\n\n  // Original values\n  const Ar = data[off];\n  const Br = data[off + step];\n  const Cr = data[off + step2];\n  const Dr = data[off + step3];\n\n  // Pre-Final values\n  const T0r = Ar + Cr;\n  const T1r = Ar - Cr;\n  const T2r = Br + Dr;\n  const T3r = inv * (Br - Dr);\n\n  // Final values\n  const FAr = T0r + T2r;\n\n  const FBr = T1r;\n  const FBi = -T3r;\n\n  const FCr = T0r - T2r;\n\n  const FDr = T1r;\n  const FDi = T3r;\n\n  out[outOff] = FAr;\n  out[outOff + 1] = 0;\n  out[outOff + 2] = FBr;\n  out[outOff + 3] = FBi;\n  out[outOff + 4] = FCr;\n  out[outOff + 5] = 0;\n  out[outOff + 6] = FDr;\n  out[outOff + 7] = FDi;\n};\n","const LOOP = 8;\nconst FLOAT_MUL = 1 / 16777216;\nconst sh1 = 15;\nconst sh2 = 18;\nconst sh3 = 11;\nfunction multiplyUint32(n, m) {\n    n >>>= 0;\n    m >>>= 0;\n    const nlo = n & 0xffff;\n    const nhi = n - nlo;\n    return (((nhi * m) >>> 0) + nlo * m) >>> 0;\n}\nexport class XSadd {\n    random;\n    state;\n    /**\n     * create an instance of XSadd with the specified seed\n     * @param [seed=Date.now()]\n     */\n    constructor(seed = Date.now()) {\n        this.state = new Uint32Array(4);\n        this.init(seed);\n        this.random = this.getFloat.bind(this);\n    }\n    /**\n     * Returns a 32-bit integer r (0 <= r < 2^32)\n     */\n    getUint32() {\n        this.nextState();\n        return (this.state[3] + this.state[2]) >>> 0;\n    }\n    /**\n     * Returns a floating point number r (0.0 <= r < 1.0)\n     */\n    getFloat() {\n        return (this.getUint32() >>> 8) * FLOAT_MUL;\n    }\n    init(seed) {\n        if (!Number.isInteger(seed)) {\n            throw new TypeError(\"seed must be an integer\");\n        }\n        this.state[0] = seed;\n        this.state[1] = 0;\n        this.state[2] = 0;\n        this.state[3] = 0;\n        for (let i = 1; i < LOOP; i++) {\n            this.state[i & 3] ^=\n                (i +\n                    multiplyUint32(1812433253, this.state[(i - 1) & 3] ^ ((this.state[(i - 1) & 3] >>> 30) >>> 0))) >>>\n                    0;\n        }\n        this.periodCertification();\n        for (let i = 0; i < LOOP; i++) {\n            this.nextState();\n        }\n    }\n    periodCertification() {\n        if (this.state[0] === 0 &&\n            this.state[1] === 0 &&\n            this.state[2] === 0 &&\n            this.state[3] === 0) {\n            this.state[0] = 88; // X\n            this.state[1] = 83; // S\n            this.state[2] = 65; // A\n            this.state[3] = 68; // D\n        }\n    }\n    nextState() {\n        let t = this.state[0];\n        t ^= t << sh1;\n        t ^= t >>> sh2;\n        t ^= this.state[3] << sh3;\n        this.state[0] = this.state[1];\n        this.state[1] = this.state[2];\n        this.state[2] = this.state[3];\n        this.state[3] = t;\n    }\n}\n//# sourceMappingURL=XSadd.js.map","import { XSadd } from 'ml-xsadd';\n/**\n * Create a random array of numbers of a specific length.\n * @param options\n * @returns - array of random floats normally distributed\n */\nexport function createRandomArray(options = {}) {\n    const { mean = 0, standardDeviation = 1, length = 1000, range = 1, seed, distribution = 'normal', } = options;\n    const generator = new XSadd(seed);\n    const returnArray = new Float64Array(length);\n    switch (distribution) {\n        case 'normal': {\n            const gaussianGenerator = new GaussianGenerator(mean, standardDeviation, generator);\n            for (let i = 0; i < length; i++) {\n                returnArray[i] = gaussianGenerator.generateGaussian();\n            }\n            break;\n        }\n        case 'uniform': {\n            for (let i = 0; i < length; i++) {\n                returnArray[i] = (generator.random() - 0.5) * range + mean;\n            }\n            break;\n        }\n        default: {\n            throw new Error(`unknown distribution: ${String(distribution)}`);\n        }\n    }\n    return returnArray;\n}\nclass GaussianGenerator {\n    #spare = 0;\n    #hasSpare = false;\n    #mean;\n    #standardDeviation;\n    #generator;\n    constructor(mean, standardDeviation, generator) {\n        this.#mean = mean;\n        this.#standardDeviation = standardDeviation;\n        this.#generator = generator;\n    }\n    generateGaussian() {\n        let val, u, v, s;\n        if (this.#hasSpare) {\n            this.#hasSpare = false;\n            val = this.#spare * this.#standardDeviation + this.#mean;\n        }\n        else {\n            do {\n                u = this.#generator.random() * 2 - 1;\n                v = this.#generator.random() * 2 - 1;\n                s = u * u + v * v;\n            } while (s >= 1 || s === 0);\n            s = Math.sqrt((-2 * Math.log(s)) / s);\n            this.#spare = v * s;\n            this.#hasSpare = true;\n            val = this.#mean + this.#standardDeviation * u * s;\n        }\n        return val;\n    }\n}\n//# sourceMappingURL=createRandomArray.js.map","import { xMean } from \"../x/index.js\";\n/**\n * Finds the covariance of the points.\n * @param data\n * @param options\n * @returns the covariance\n */\nexport function xyCovariance(data, options = {}) {\n    const { x, y } = data;\n    const { unbiased = true } = options;\n    const meanX = xMean(x);\n    const meanY = xMean(y);\n    let error = 0;\n    for (let i = 0; i < x.length; i++) {\n        error += (x[i] - meanX) * (y[i] - meanY);\n    }\n    if (unbiased) {\n        return error / (x.length - 1);\n    }\n    else {\n        return error / x.length;\n    }\n}\n//# sourceMappingURL=xyCovariance.js.map","/**\n * Asserts that value is truthy.\n * @param value - Value to check.\n * @param message - Optional error message to throw.\n */\nexport function assert(value, message) {\n    if (!value) {\n        throw new Error(message || 'unreachable');\n    }\n}\n/**\n * Makes sure that all cases are handled\n * @param x - cases of value to check\n */\nexport function assertUnreachable(x) {\n    throw new Error(`unreachable: ${String(x)}`);\n}\n//# sourceMappingURL=assert.js.map","import { assert } from './validators/assert.js';\n/**\n * Get the clamp function for an image (depends on the image bit depth).\n * @param image - The image for which the clamp function is needed.\n * @returns The clamp function.\n */\nexport function getClamp(image) {\n    if (image.maxValue === 255) {\n        return clamp255;\n    }\n    else {\n        assert(image.maxValue === 65535);\n        return clamp65535;\n    }\n}\n/**\n * Clamp value for 8-bit images.\n * @param value - Value to clamp.\n * @returns The clamped value.\n */\nfunction clamp255(value) {\n    return Math.min(Math.max(value, 0), 255);\n}\n/**\n * Clamp value for 16-bit images.\n * @param value - Value to clamp.\n * @returns The clamped value.\n */\nfunction clamp65535(value) {\n    return Math.min(Math.max(value, 0), 65535);\n}\n/**\n * Get a function that clamps a value to a given range.\n * @param min - Lower threshold.\n * @param max - Upper threshold.\n * @returns The clamping function.\n */\nexport function getClampFromTo(min, max) {\n    return function clamp(value) {\n        return Math.max(Math.min(value, max), min);\n    };\n}\n//# sourceMappingURL=clamp.js.map","import { createRandomArray } from 'ml-spectra-processing';\nimport { getClampFromTo } from '../../utils/clamp.js';\n/**\n * Get the coordinates of random points inside of the given dimensions, spread with a\n * gaussian distribution around the center of the dimensions.\n * The reference point with coordinates (0,0) is the center of the patch.\n * @param width - Width in which the points should be.\n * @param height - Height in which the points should be.\n * @param options - Get gaussian points options.\n * @returns An array of random points with a gaussian distribution.\n */\nexport function getGaussianPoints(width, height, options = {}) {\n    const { nbPoints = 1024, xSeed = 0, ySeed = 1, sigma } = options;\n    const xCoordinates = getGaussianValues(width, xSeed, nbPoints, sigma);\n    const yCoordinates = getGaussianValues(height, ySeed, nbPoints, sigma);\n    const points = [];\n    for (let i = 0; i < nbPoints; i++) {\n        points.push({ column: xCoordinates[i], row: yCoordinates[i] });\n    }\n    return points;\n}\n/**\n * Generate an array of values\n * that follow a gaussian distribution with a mean value of zero.\n * @param size - Specifies the width of the gaussian distribution.\n * @param seed - Seed for the random generator.\n * @param nbValues - Number of values wanted.\n * @param sigma - The standard deviation. The default value is the optimal SD for BRIEF.\n * @returns Array of values with gaussian distribution.\n */\nexport function getGaussianValues(size, seed, nbValues, sigma = size / 5) {\n    const width = (size - 1) / 2;\n    const array = createRandomArray({\n        distribution: 'normal',\n        seed,\n        length: nbValues,\n        standardDeviation: sigma,\n        mean: 0,\n    });\n    const clamp = getClampFromTo(-width, width);\n    return array.map((value) => {\n        const rounded = Math.round(value);\n        return clamp(rounded);\n    });\n}\n//# sourceMappingURL=getGaussianPoints.js.map","/**\n * Crop the source image to given dimensions around the origin.\n * @param image - Source image.\n * @param origin - Center point for the crop.\n * @param patchSize - Size of the returned image.\n * @returns The square image around the origin extracted from the source image.\n */\nexport function extractSquareImage(image, origin, patchSize) {\n    const cropOffset = (patchSize - 1) / 2;\n    const cropOrigin = {\n        column: origin.column - cropOffset,\n        row: origin.row - cropOffset,\n    };\n    return image.crop({\n        origin: cropOrigin,\n        width: patchSize,\n        height: patchSize,\n    });\n}\n//# sourceMappingURL=extractSquareImage.js.map","import { getRadius } from '../../../utils/getRadius.js';\nimport { checkBorderDistance } from '../../utils/checkBorderDistance.js';\nimport { extractSquareImage } from '../../utils/extractSquareImage.js';\n/**\n * Get the patch around the keypoint with given size.\n * @param image - Image from which to extract the patch.\n * @param keypoint - Keypoint around which to extract the patch.\n * @param options - Get keypoint patch options.\n * @returns The patch around the keypoint.\n */\nexport function getKeypointPatch(image, keypoint, options = {}) {\n    const { patchSize = 31 } = options;\n    // crop smallest square surrounding the tilted patch of the keypoint\n    // we have to handle the fact that this square can have even dimensions\n    const radAngle = (keypoint.angle * Math.PI) / 180;\n    const rawWidth = Math.floor(patchSize * (Math.abs(Math.cos(radAngle)) + Math.abs(Math.sin(radAngle))));\n    const cropWidth = rawWidth % 2 ? rawWidth : rawWidth + 1;\n    // we are not allowing keypoints that are too close to the border of the image\n    const borderDistance = getRadius(cropWidth);\n    if (!checkBorderDistance(image, keypoint.origin, borderDistance)) {\n        throw new RangeError('keypoint is too close to border for given patch size');\n    }\n    const cropped = extractSquareImage(image, keypoint.origin, cropWidth);\n    const rotated = cropped.transformRotate(-keypoint.angle, {\n        center: 'center',\n        interpolationType: 'nearest',\n    });\n    const cropOrigin = rotated.getCoordinates('center');\n    const result = extractSquareImage(rotated, cropOrigin, patchSize);\n    return result;\n}\n//# sourceMappingURL=getKeypointPatch.js.map","import checkProcessable from '../../utils/validators/checkProcessable.js';\nimport { compareIntensity } from '../utils/compareIntensity.js';\nimport { getGaussianPoints } from '../utils/getGaussianPoints.js';\nimport { getKeypointPatch } from './utils/getKeypointPatch.js';\n/**\n * Generate the rBRIEF descriptors for the desired keypoints of an image.\n * The rBRIEF descriptors are presented in these articles:\n * - ORB article: DOI: 10.1109/ICCV.2011.6126544\n * - rBRIEF article: DOI: 10.1007/978-3-642-15561-1_56.\n * @param image - Source image of the keypoints.\n * @param keypoints - Keypoints for which the descriptors are wanted.\n * @param options - Get rotated BRIEF descriptors options.\n * @returns The descriptors for the given keypoints.\n */\nexport function getBriefDescriptors(image, keypoints, options = {}) {\n    const { patchSize = 31, descriptorLength = 256, smoothingOptions = {\n        sigma: Math.sqrt(2),\n        size: Math.min(image.height, image.width, 9),\n    }, pointsDistributionOptions, } = options;\n    checkProcessable(image, {\n        alpha: false,\n        colorModel: 'GREY',\n    });\n    if (!(patchSize % 2)) {\n        throw new TypeError('patchSize must be an odd integer');\n    }\n    if (Math.min(image.width, image.height) < patchSize) {\n        throw new RangeError(`image is too small for patchSize = ${patchSize}`);\n    }\n    const gaussianPoints = getGaussianPoints(patchSize, patchSize, {\n        ...pointsDistributionOptions,\n        nbPoints: descriptorLength * 2,\n    });\n    const smoothed = image.gaussianBlur(smoothingOptions);\n    const descriptors = [];\n    const filteredKeypoints = [];\n    for (const keypoint of keypoints) {\n        let patch;\n        try {\n            patch = getKeypointPatch(smoothed, keypoint, { patchSize });\n        }\n        catch {\n            continue;\n        }\n        if (patch === null)\n            continue;\n        const descriptor = new Uint8Array(descriptorLength);\n        for (let i = 0; i < descriptorLength; i++) {\n            const p1 = gaussianPoints[i];\n            const p2 = gaussianPoints[i + descriptorLength];\n            descriptor[i] = Number(compareIntensity(patch, p1, p2));\n        }\n        descriptors.push(descriptor);\n        filteredKeypoints.push(keypoint);\n    }\n    return { keypoints: filteredKeypoints, descriptors };\n}\n//# sourceMappingURL=getBriefDescriptors.js.map","import { getBestKeypointsInRadius } from '../keypoints/getBestKeypointsInRadius.js';\nimport { getOrientedFastKeypoints } from '../keypoints/getOrientedFastKeypoints.js';\nimport { getBriefDescriptors } from './getBriefDescriptors.js';\n/**\n * Get the keypoints and corresponding descriptors for an image.\n * @param image - Image to process.\n * @param options - Get brief options.\n * @returns The Brief (keypoints and corresponding descriptors).\n */\nexport function getBrief(image, options = {}) {\n    const { centroidPatchDiameter = 15, bestKptRadius = 10, minScore } = options;\n    const allSourceKeypoints = getOrientedFastKeypoints(image, {\n        centroidPatchDiameter,\n    });\n    const sourceKeypoints = getBestKeypointsInRadius(allSourceKeypoints, bestKptRadius);\n    const brief = getBriefDescriptors(image, sourceKeypoints);\n    if (minScore) {\n        for (let i = 0; i < brief.keypoints.length; i++) {\n            if (brief.keypoints[i].score < minScore) {\n                return {\n                    keypoints: brief.keypoints.slice(0, i - 1),\n                    descriptors: brief.descriptors.slice(0, i - 1),\n                };\n            }\n        }\n    }\n    return brief;\n}\n//# sourceMappingURL=getBrief.js.map","/**\n * Compute the pq order intensity moment of the image\n * relatively to the origin defined in the options.\n * Original article: {@link https://doi.org/10.1006/cviu.1998.0719}.\n * @see {@link https://en.wikipedia.org/wiki/Image_moment}\n * @param image - Image to process. Should have an odd number of rows and columns.\n * @param p - Order along x.\n * @param q - Order along y.\n * @param options - Get intensity moment options.\n * @returns The intensity moment of order pq.\n */\nexport function getIntensityMoment(image, p, q, options = {}) {\n    const { origin = image.getCoordinates('center') } = options;\n    const moment = new Array(image.channels).fill(0);\n    for (let row = 0; row < image.height; row++) {\n        for (let column = 0; column < image.width; column++) {\n            const xDistance = column - origin.column;\n            const yDistance = row - origin.row;\n            for (let channel = 0; channel < image.channels; channel++) {\n                const intensity = image.getValue(column, row, channel);\n                moment[channel] += xDistance ** p * yDistance ** q * intensity;\n            }\n        }\n    }\n    return moment;\n}\n//# sourceMappingURL=getIntensityMoment.js.map","import { getIntensityMoment } from './getIntensityMoment.js';\n/**\n * Compute the intensity centroid of an image for each channel relatively to the center of the image.\n * Original article: {@link https://doi.org/10.1006/cviu.1998.0719}.\n * @see {@link https://en.wikipedia.org/wiki/Image_moment}\n * @param image - Image to process.\n * @returns The intensity centroid of each channel of the image.\n */\nexport function getIntensityCentroid(image) {\n    const moment10 = getIntensityMoment(image, 1, 0);\n    const moment01 = getIntensityMoment(image, 0, 1);\n    const moment00 = getIntensityMoment(image, 0, 0);\n    const centroid = [];\n    for (let channel = 0; channel < image.channels; channel++) {\n        if (moment00[channel] === 0) {\n            centroid.push({\n                column: 0,\n                row: 0,\n            });\n        }\n        else {\n            centroid.push({\n                column: moment10[channel] / moment00[channel],\n                row: moment01[channel] / moment00[channel],\n            });\n        }\n    }\n    return centroid;\n}\n//# sourceMappingURL=getIntensityCentroid.js.map","/**\n * Compute the Hamming distance between two bit strings.\n * @see {@link https://en.wikipedia.org/wiki/Hamming_distance}\n * @param descriptor1 - First bit string.\n * @param descriptor2 - Second bit string.\n * @returns The Hamming distance.\n */\nexport function getHammingDistance(descriptor1, descriptor2) {\n    let sum = 0;\n    for (let i = 0; i < descriptor1.length; i++) {\n        sum += descriptor1[i] ^ descriptor2[i];\n    }\n    return sum;\n}\n//# sourceMappingURL=getHammingDistance.js.map","import { getHammingDistance } from './getHammingDistance.js';\n/**\n * Find the best match for each of the source descriptors using brute force matching.\n * @param source - Source descriptors.\n * @param destination - Destination descriptors.\n * @param options - Brute force amtch options.\n * @returns The best match for each source descriptor.\n */\nexport function bruteForceOneMatch(source, destination, options = {}) {\n    const { sort = !!options.nbBestMatches, nbBestMatches = source.length } = options;\n    const matches = [];\n    for (let sourceIndex = 0; sourceIndex < source.length; sourceIndex++) {\n        let minDistance = Number.POSITIVE_INFINITY;\n        let index = 0;\n        for (let destinationIndex = 0; destinationIndex < destination.length; destinationIndex++) {\n            const distance = getHammingDistance(source[sourceIndex], destination[destinationIndex]);\n            if (distance < minDistance) {\n                minDistance = distance;\n                index = destinationIndex;\n            }\n        }\n        matches.push({\n            sourceIndex,\n            destinationIndex: index,\n            distance: minDistance,\n        });\n    }\n    if (sort) {\n        matches.sort((a, b) => a.distance - b.distance);\n    }\n    return matches.slice(0, nbBestMatches);\n}\n//# sourceMappingURL=bruteForceMatch.js.map","/**\n * Sort array of matches by source index and then destination index.\n * @param matches - Array of matches to sort.\n * @returns Sorted copy of the array of matches.\n */\nexport function sortBySourceDest(matches) {\n    const sorted = matches.slice();\n    sorted.sort((match1, match2) => {\n        if (match1.sourceIndex < match2.sourceIndex)\n            return -1;\n        if (match1.sourceIndex > match2.sourceIndex)\n            return 1;\n        return match1.destinationIndex - match2.destinationIndex;\n    });\n    return sorted;\n}\n/**\n * Sort array of matches by destination index and then source index.\n * @param matches - Array of matches to sort.\n * @returns Sorted copy of the array of matches.\n */\nexport function sortByDestSource(matches) {\n    const sorted = matches.slice();\n    sorted.sort((match1, match2) => {\n        if (match1.destinationIndex < match2.destinationIndex)\n            return -1;\n        if (match1.destinationIndex > match2.destinationIndex)\n            return 1;\n        return match1.sourceIndex - match2.sourceIndex;\n    });\n    return sorted;\n}\n//# sourceMappingURL=sortBySourceDest.js.map","import { sortByDestSource, sortBySourceDest, } from '../utils/sortBySourceDest.js';\nimport { bruteForceOneMatch } from './bruteForceMatch.js';\n/**\n * Get the crosscheck matches from the source and destination descriptors.\n * @param source - Source descriptors.\n * @param destination - Destination descriptors.\n * @returns The array of crossckeck matches.\n */\nexport function getCrosscheckMatches(source, destination) {\n    const srcMatches = bruteForceOneMatch(source, destination);\n    const dstMatches = bruteForceOneMatch(destination, source);\n    return crosscheck(srcMatches, dstMatches);\n}\n/**\n * Return the indices of pairs the keypoints that are mutually the best match.\n * This means that if B is the best match for A, A should be the best match for B.\n * The distance of the resulting matches is the maximum distance between the two.\n * @param srcDstMatches - Best matches computed from source do destination.\n * @param dstSrcMatches - Best matches computed from destination to source.\n * @returns The pairs of keypoints that are mutually the best match.\n */\nexport function crosscheck(srcDstMatches, dstSrcMatches) {\n    const result = [];\n    const sortedSrcDst = sortBySourceDest(srcDstMatches);\n    const sortedDstSrc = sortByDestSource(dstSrcMatches);\n    let pointer1 = 0;\n    let pointer2 = 0;\n    while (pointer1 < sortedSrcDst.length && pointer2 < sortedDstSrc.length) {\n        const match1 = sortedSrcDst[pointer1];\n        const match2 = sortedDstSrc[pointer2];\n        if (match1.sourceIndex > match2.destinationIndex) {\n            pointer2++;\n        }\n        else if (match1.sourceIndex < match2.destinationIndex) {\n            pointer1++;\n        }\n        else if (match1.destinationIndex > match2.sourceIndex) {\n            pointer2++;\n        }\n        else if (match1.destinationIndex < match2.sourceIndex) {\n            pointer1++;\n        }\n        else {\n            result.push({\n                distance: Math.max(match1.distance, match2.distance),\n                sourceIndex: match1.sourceIndex,\n                destinationIndex: match1.destinationIndex,\n            });\n            pointer1++;\n            pointer2++;\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=getCrosscheckMatches.js.map","/**\n * Validate an array of channels.\n * @param channels - Array of channels.\n * @param image - The image being processed.\n */\nexport function validateChannels(channels, image) {\n    for (const channel of channels) {\n        validateChannel(channel, image);\n    }\n}\n/**\n * Validates that a channel index passed by the user is within range and is an integer.\n * @param channel - Channel index to validate.\n * @param image - The image being processed.\n */\nexport function validateChannel(channel, image) {\n    if (!Number.isInteger(channel) || channel >= image.channels || channel < 0) {\n        throw new RangeError(`invalid channel: ${channel}. It must be a positive integer smaller than ${image.channels}`);\n    }\n}\n/**\n * Validates that array of svalues passed by the user are positive and within range.\n * @param values - Array of values to validate.\n * @param image - Image from which the values come.\n */\nexport function validateValues(values, image) {\n    for (const value of values) {\n        validateValue(value, image);\n    }\n}\n/**\n * Validates that a value passed by the user is positive and within range.\n * @param value - Value to validate.\n * @param image - Image from which the value comes.\n */\nexport function validateValue(value, image) {\n    if (value > image.maxValue || value < 0) {\n        throw new RangeError(`invalid value: ${value}. It must be a positive value smaller than ${image.maxValue + 1}`);\n    }\n}\n/**\n * Validate that two images are compatible for comparison functions.\n * @param image - First image.\n * @param other - Second image.\n */\nexport function validateForComparison(image, other) {\n    if (image.width !== other.width || image.height !== other.height) {\n        throw new RangeError('both images must have the same size');\n    }\n    if (image.alpha !== other.alpha || image.bitDepth !== other.bitDepth) {\n        throw new RangeError('both images must have the same alpha and bitDepth');\n    }\n    if (image.channels !== other.channels) {\n        throw new RangeError('both images must have the same number of channels');\n    }\n}\n/**\n * Checks if the given color is valid.\n * @param color - Color to check.\n * @param image - Image.\n */\nexport function validateColor(color, image) {\n    validateChannel(color.length - 1, image);\n    validateValues(color, image);\n}\n//# sourceMappingURL=validators.js.map","import { getOutputImage } from '../utils/getOutputImage.js';\nimport { validateChannels } from '../utils/validators/validators.js';\n/**\n *\n * Divides image pixels by a certain value.\n * @param image - image to which division will be applied.\n * @param value - Value by which each pixel will be divided.\n * @param options - Divide options\n * @returns image.\n */\nexport function divide(image, value, options = {}) {\n    const { channels = new Array(image.channels).fill(0).map((value, index) => index), } = options;\n    validateChannels(channels, image);\n    if (value === 0) {\n        throw new TypeError(`Cannot divide by 0`);\n    }\n    const newImage = getOutputImage(image, options, { clone: true });\n    if (channels.length === 0) {\n        return newImage;\n    }\n    for (const channel of channels) {\n        for (let row = 0; row < newImage.height; row++) {\n            for (let column = 0; column < newImage.width; column++) {\n                const newIntensity = newImage.getValue(column, row, channel) / value;\n                newImage.setClampedValue(column, row, channel, newIntensity);\n            }\n        }\n    }\n    return newImage;\n}\n//# sourceMappingURL=divide.js.map","/**\n * Compute the Root Mean Square Error (RMSE) between two images. It is just the square root of the MSE.\n * @see {@link https://en.wikipedia.org/wiki/Root-mean-square_deviation}\n * @param image - First image.\n * @param otherImage - Second image.\n * @returns RMSE of the two images.\n */\nexport function computeRmse(image, otherImage) {\n    const globalMse = computeMse(image, otherImage);\n    return Math.sqrt(globalMse);\n}\n/**\n * Compute the Mean Square Error (MSE) between two images.\n * The input images can have any number of channels.\n * @param image - First image.\n * @param otherImage - Second image.\n * @returns MSE of the two images.\n */\nexport function computeMse(image, otherImage) {\n    const difference = image.subtract(otherImage, { absolute: true });\n    let sum = 0;\n    for (let i = 0; i < image.size; i++) {\n        for (let channel = 0; channel < image.channels; channel++) {\n            const value = difference.getValueByIndex(i, channel);\n            sum += value ** 2;\n        }\n    }\n    return sum / (image.size * image.channels);\n}\n//# sourceMappingURL=computeRmse.js.map","import { computeRmse } from './computeRmse.js';\n/**\n * Compute the Peak signal-to-noise ratio (PSNR) between two images.\n * The larger the PSNR, the more similar the images.\n * @see {@link https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio}\n * @param image - First image.\n * @param otherImage - Second image.\n * @returns PSNR of the two images in decibels.\n */\nexport function computePsnr(image, otherImage) {\n    const rmsePixel = computeRmse(image, otherImage);\n    return 20 * Math.log10(image.maxValue / (rmsePixel + Number.MIN_VALUE));\n}\n//# sourceMappingURL=computePsnr.js.map","import { match } from 'ts-pattern';\n/**\n * Get the default color for a given color model.\n * The color is black for images and 1 for masks.\n * @param image - The used image.\n * @returns Default color.\n */\nexport function getDefaultColor(image) {\n    return match(image.colorModel)\n        .with('GREY', () => [0])\n        .with('GREYA', () => [0, image.maxValue])\n        .with('RGB', () => [0, 0, 0])\n        .with('RGBA', () => [0, 0, 0, image.maxValue])\n        .with('BINARY', () => [1])\n        .exhaustive();\n}\n//# sourceMappingURL=getDefaultColor.js.map","import { Image } from '../Image.js';\nimport { getDefaultColor } from './getDefaultColor.js';\nimport { assert } from './validators/assert.js';\n/**\n * Blend the given pixel with the pixel at the specified location in the image.\n * @param image - The image with which to blend.\n * @param column - Column of the target pixel.\n * @param row - Row of the target pixel.\n * @param color - Color with which to blend the image pixel. Default: `Opaque black`.\n */\nexport function setBlendedPixel(image, column, row, color) {\n    color = color ?? getDefaultColor(image);\n    if (!image.alpha) {\n        image.setPixel(column, row, color);\n    }\n    else {\n        assert(image instanceof Image);\n        const sourceAlpha = color.at(-1);\n        if (sourceAlpha === image.maxValue) {\n            image.setPixel(column, row, color);\n            return;\n        }\n        const targetAlpha = image.getValue(column, row, image.channels - 1);\n        const newAlpha = sourceAlpha + targetAlpha * (1 - sourceAlpha / image.maxValue);\n        image.setValue(column, row, image.channels - 1, newAlpha);\n        for (let component = 0; component < image.components; component++) {\n            const sourceComponent = color[component];\n            const targetComponent = image.getValue(column, row, component);\n            const newComponent = (sourceComponent * sourceAlpha +\n                targetComponent * targetAlpha * (1 - sourceAlpha / image.maxValue)) /\n                newAlpha;\n            image.setValue(column, row, component, newComponent);\n        }\n    }\n}\n//# sourceMappingURL=setBlendedPixel.js.map","import { setBlendedPixel } from './setBlendedPixel.js';\n/**\n * Blend the given pixel with the pixel at the specified location in the image if the pixel is in image's bounds.\n * @param image - The image with which to blend.\n * @param column - Column of the target pixel.\n * @param row - Row of the target pixel.\n * @param color - Color with which to blend the image pixel. Default: `Opaque black`.\n */\nexport function setBlendedVisiblePixel(image, column, row, color) {\n    if (column >= 0 && column < image.width && row >= 0 && row < image.height) {\n        setBlendedPixel(image, column, row, color);\n    }\n}\n//# sourceMappingURL=setBlendedVisiblePixel.js.map","/**\n * Round a point to the nearest integer.\n * @param point - Point to round.\n * @returns The rounded point.\n */\nexport function roundPoint(point) {\n    return {\n        row: Math.round(point.row),\n        column: Math.round(point.column),\n    };\n}\n//# sourceMappingURL=roundPoint.js.map","import { circle } from 'bresenham-zingl';\nimport { getDefaultColor } from '../utils/getDefaultColor.js';\nimport { getOutputImage } from '../utils/getOutputImage.js';\nimport { setBlendedVisiblePixel } from '../utils/setBlendedVisiblePixel.js';\nimport checkProcessable from '../utils/validators/checkProcessable.js';\nimport { validateColor } from '../utils/validators/validators.js';\nimport { roundPoint } from './utils/roundPoint.js';\n/**\n * Draw a circle defined by center and radius.\n * @param image - Image to process.\n * @param center - Circle center point.\n * @param radius - Circle radius.\n * @param options - Draw circle options.\n * @returns The original drawn image.\n */\nexport function drawCircleOnImage(image, center, radius, options = {}) {\n    const newImage = getOutputImage(image, options, { clone: true });\n    const { strokeColor = getDefaultColor(newImage), fillColor } = options;\n    validateColor(strokeColor, newImage);\n    checkProcessable(newImage, {\n        bitDepth: [8, 16],\n    });\n    if (radius < 0) {\n        throw new RangeError('circle radius must be positive');\n    }\n    center = roundPoint(center);\n    radius = Math.round(radius);\n    if (radius === 0) {\n        setBlendedVisiblePixel(newImage, center.column, center.row, strokeColor);\n        return newImage;\n    }\n    if (!fillColor) {\n        circle(center.column, center.row, radius, (column, row) => {\n            setBlendedVisiblePixel(newImage, column, row, strokeColor);\n        });\n    }\n    else {\n        if (radius === 1) {\n            setBlendedVisiblePixel(newImage, center.column, center.row, fillColor);\n        }\n        //Starting points for the top and bottom row of the circle.\n        let prevRow = center.row + radius;\n        let index = 0;\n        circle(center.column, center.row, radius, (column, row) => {\n            setBlendedVisiblePixel(newImage, column, row, strokeColor);\n            // Filling the first line of the circle.\n            if (index === 0) {\n                newImage.drawLine({ row, column: column - 1 }, {\n                    row,\n                    column: center.column - (column - center.column - 1),\n                }, { strokeColor: fillColor, out: newImage });\n            }\n            // The algorithm used is Bresenham's circle algorithm (@link https://www.geeksforgeeks.org/bresenhams-circle-drawing-algorithm/) to find points that constitute the circle outline. However, in this algorithm The circle is divided in 4 parts instead of 8: top, right, bottom and left.\n            // The algorithm draws a point per quadrant until the circle is complete.\n            // We use bottom (index % 4 === 1, quadrant 2) point of the outline to fill the circle with color.\n            // Filling half of the circle.\n            if (index % 4 === 1 && prevRow !== row) {\n                // For quadrant 2, column < center.column\n                newImage.drawLine({ row, column: column + 1 }, {\n                    row,\n                    column: center.column - (column - center.column + 1),\n                }, { strokeColor: fillColor, out: newImage });\n                prevRow = row;\n                // Filling top half of the circle.\n                newImage.drawLine({ row: center.row - (row - center.row), column: column + 1 }, {\n                    row: center.row - (row - center.row),\n                    column: center.column - (column - center.column + 1),\n                }, { strokeColor: fillColor, out: newImage });\n            }\n            index++;\n        });\n    }\n    return newImage;\n}\n//# sourceMappingURL=drawCircleOnImage.js.map","import { line } from 'bresenham-zingl';\nimport { getDefaultColor } from '../utils/getDefaultColor.js';\nimport { getOutputImage } from '../utils/getOutputImage.js';\nimport { setBlendedVisiblePixel } from '../utils/setBlendedVisiblePixel.js';\nimport checkProcessable from '../utils/validators/checkProcessable.js';\nimport { validateColor } from '../utils/validators/validators.js';\n/**\n * Draw a line defined by two points onto an image.\n * @param image - Image to process.\n * @param from - Line starting point.\n * @param to - Line ending point.\n * @param options - Draw Line options.\n * @returns The mask with the line drawing.\n */\nexport function drawLineOnImage(image, from, to, options = {}) {\n    const newImage = getOutputImage(image, options, { clone: true });\n    const { strokeColor = getDefaultColor(newImage), origin = { column: 0, row: 0 }, } = options;\n    validateColor(strokeColor, newImage);\n    checkProcessable(newImage, {\n        bitDepth: [8, 16],\n    });\n    line(Math.round(origin.column + from.column), Math.round(origin.row + from.row), Math.round(origin.column + to.column), Math.round(origin.row + to.row), (column, row) => {\n        setBlendedVisiblePixel(newImage, column, row, strokeColor);\n    });\n    return newImage;\n}\n//# sourceMappingURL=drawLineOnImage.js.map","import { line } from 'bresenham-zingl';\nimport { maskToOutputMask } from '../utils/getOutputImage.js';\n/**\n * Draw a line defined by two points onto a mask.\n * @param mask - Mask to process.\n * @param from - Line starting point.\n * @param to - Line ending point.\n * @param options - Draw Line options.\n * @returns The mask with the line drawing.\n */\nexport function drawLineOnMask(mask, from, to, options = {}) {\n    const { origin = { column: 0, row: 0 } } = options;\n    const newMask = maskToOutputMask(mask, options, { clone: true });\n    line(Math.round(origin.column + from.column), Math.round(origin.row + from.row), Math.round(origin.column + to.column), Math.round(origin.row + to.row), (column, row) => {\n        newMask.setVisiblePixel(column, row, [1]);\n    });\n    return newMask;\n}\n//# sourceMappingURL=drawLineOnMask.js.map","import { getDefaultColor } from '../utils/getDefaultColor.js';\nimport { getOutputImage } from '../utils/getOutputImage.js';\nimport checkProcessable from '../utils/validators/checkProcessable.js';\nimport { validateColor } from '../utils/validators/validators.js';\n/**\n * Draw a polyline defined by an array of points on an image.\n * @param image - Image to process.\n * @param points - Polyline array of points.\n * @param options - Draw polyline options.\n * @returns The image with the polyline drawing.\n */\nexport function drawPolylineOnImage(image, points, options = {}) {\n    const { strokeColor: color = getDefaultColor(image), origin = { column: 0, row: 0 }, } = options;\n    checkProcessable(image, {\n        bitDepth: [8, 16],\n    });\n    const newImage = getOutputImage(image, options, { clone: true });\n    validateColor(color, newImage);\n    for (let i = 0; i < points.length - 1; i++) {\n        const from = points[i];\n        const to = points[i + 1];\n        newImage.drawLine(from, to, { out: newImage, strokeColor: color, origin });\n    }\n    return newImage;\n}\n//# sourceMappingURL=drawPolylineOnImage.js.map","import { maskToOutputMask } from '../utils/getOutputImage.js';\n/**\n * Draw a polyline defined by an array of points on an image.\n * @param mask - Mask to process.\n * @param points - Polyline array of points.\n * @param options - Draw polyline options.\n * @returns The mask with the polyline drawing.\n */\nexport function drawPolylineOnMask(mask, points, options = {}) {\n    const newImage = maskToOutputMask(mask, options, { clone: true });\n    for (let i = 0; i < points.length - 1; i++) {\n        const from = points[i];\n        const to = points[i + 1];\n        newImage.drawLine(from, to, { out: newImage, origin: options.origin });\n    }\n    return newImage;\n}\n//# sourceMappingURL=drawPolylineOnMask.js.map","\"use strict\"\n\nmodule.exports = twoProduct\n\nvar SPLITTER = +(Math.pow(2, 27) + 1.0)\n\nfunction twoProduct(a, b, result) {\n  var x = a * b\n\n  var c = SPLITTER * a\n  var abig = c - a\n  var ahi = c - abig\n  var alo = a - ahi\n\n  var d = SPLITTER * b\n  var bbig = d - b\n  var bhi = d - bbig\n  var blo = b - bhi\n\n  var err1 = x - (ahi * bhi)\n  var err2 = err1 - (alo * bhi)\n  var err3 = err2 - (ahi * blo)\n\n  var y = alo * blo - err3\n\n  if(result) {\n    result[0] = y\n    result[1] = x\n    return result\n  }\n\n  return [ y, x ]\n}","\"use strict\"\n\nmodule.exports = linearExpansionSum\n\n//Easy case: Add two scalars\nfunction scalarScalar(a, b) {\n  var x = a + b\n  var bv = x - a\n  var av = x - bv\n  var br = b - bv\n  var ar = a - av\n  var y = ar + br\n  if(y) {\n    return [y, x]\n  }\n  return [x]\n}\n\nfunction linearExpansionSum(e, f) {\n  var ne = e.length|0\n  var nf = f.length|0\n  if(ne === 1 && nf === 1) {\n    return scalarScalar(e[0], f[0])\n  }\n  var n = ne + nf\n  var g = new Array(n)\n  var count = 0\n  var eptr = 0\n  var fptr = 0\n  var abs = Math.abs\n  var ei = e[eptr]\n  var ea = abs(ei)\n  var fi = f[fptr]\n  var fa = abs(fi)\n  var a, b\n  if(ea < fa) {\n    b = ei\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n      ea = abs(ei)\n    }\n  } else {\n    b = fi\n    fptr += 1\n    if(fptr < nf) {\n      fi = f[fptr]\n      fa = abs(fi)\n    }\n  }\n  if((eptr < ne && ea < fa) || (fptr >= nf)) {\n    a = ei\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n      ea = abs(ei)\n    }\n  } else {\n    a = fi\n    fptr += 1\n    if(fptr < nf) {\n      fi = f[fptr]\n      fa = abs(fi)\n    }\n  }\n  var x = a + b\n  var bv = x - a\n  var y = b - bv\n  var q0 = y\n  var q1 = x\n  var _x, _bv, _av, _br, _ar\n  while(eptr < ne && fptr < nf) {\n    if(ea < fa) {\n      a = ei\n      eptr += 1\n      if(eptr < ne) {\n        ei = e[eptr]\n        ea = abs(ei)\n      }\n    } else {\n      a = fi\n      fptr += 1\n      if(fptr < nf) {\n        fi = f[fptr]\n        fa = abs(fi)\n      }\n    }\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    }\n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n  }\n  while(eptr < ne) {\n    a = ei\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    }\n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n    }\n  }\n  while(fptr < nf) {\n    a = fi\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    } \n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n    fptr += 1\n    if(fptr < nf) {\n      fi = f[fptr]\n    }\n  }\n  if(q0) {\n    g[count++] = q0\n  }\n  if(q1) {\n    g[count++] = q1\n  }\n  if(!count) {\n    g[count++] = 0.0  \n  }\n  g.length = count\n  return g\n}","\"use strict\"\n\nmodule.exports = fastTwoSum\n\nfunction fastTwoSum(a, b, result) {\n\tvar x = a + b\n\tvar bv = x - a\n\tvar av = x - bv\n\tvar br = b - bv\n\tvar ar = a - av\n\tif(result) {\n\t\tresult[0] = ar + br\n\t\tresult[1] = x\n\t\treturn result\n\t}\n\treturn [ar+br, x]\n}","\"use strict\"\n\nvar twoProduct = require(\"two-product\")\nvar twoSum = require(\"two-sum\")\n\nmodule.exports = scaleLinearExpansion\n\nfunction scaleLinearExpansion(e, scale) {\n  var n = e.length\n  if(n === 1) {\n    var ts = twoProduct(e[0], scale)\n    if(ts[0]) {\n      return ts\n    }\n    return [ ts[1] ]\n  }\n  var g = new Array(2 * n)\n  var q = [0.1, 0.1]\n  var t = [0.1, 0.1]\n  var count = 0\n  twoProduct(e[0], scale, q)\n  if(q[0]) {\n    g[count++] = q[0]\n  }\n  for(var i=1; i<n; ++i) {\n    twoProduct(e[i], scale, t)\n    var pq = q[1]\n    twoSum(pq, t[0], q)\n    if(q[0]) {\n      g[count++] = q[0]\n    }\n    var a = t[1]\n    var b = q[1]\n    var x = a + b\n    var bv = x - a\n    var y = b - bv\n    q[1] = x\n    if(y) {\n      g[count++] = y\n    }\n  }\n  if(q[1]) {\n    g[count++] = q[1]\n  }\n  if(count === 0) {\n    g[count++] = 0.0\n  }\n  g.length = count\n  return g\n}","\"use strict\"\n\nmodule.exports = robustSubtract\n\n//Easy case: Add two scalars\nfunction scalarScalar(a, b) {\n  var x = a + b\n  var bv = x - a\n  var av = x - bv\n  var br = b - bv\n  var ar = a - av\n  var y = ar + br\n  if(y) {\n    return [y, x]\n  }\n  return [x]\n}\n\nfunction robustSubtract(e, f) {\n  var ne = e.length|0\n  var nf = f.length|0\n  if(ne === 1 && nf === 1) {\n    return scalarScalar(e[0], -f[0])\n  }\n  var n = ne + nf\n  var g = new Array(n)\n  var count = 0\n  var eptr = 0\n  var fptr = 0\n  var abs = Math.abs\n  var ei = e[eptr]\n  var ea = abs(ei)\n  var fi = -f[fptr]\n  var fa = abs(fi)\n  var a, b\n  if(ea < fa) {\n    b = ei\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n      ea = abs(ei)\n    }\n  } else {\n    b = fi\n    fptr += 1\n    if(fptr < nf) {\n      fi = -f[fptr]\n      fa = abs(fi)\n    }\n  }\n  if((eptr < ne && ea < fa) || (fptr >= nf)) {\n    a = ei\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n      ea = abs(ei)\n    }\n  } else {\n    a = fi\n    fptr += 1\n    if(fptr < nf) {\n      fi = -f[fptr]\n      fa = abs(fi)\n    }\n  }\n  var x = a + b\n  var bv = x - a\n  var y = b - bv\n  var q0 = y\n  var q1 = x\n  var _x, _bv, _av, _br, _ar\n  while(eptr < ne && fptr < nf) {\n    if(ea < fa) {\n      a = ei\n      eptr += 1\n      if(eptr < ne) {\n        ei = e[eptr]\n        ea = abs(ei)\n      }\n    } else {\n      a = fi\n      fptr += 1\n      if(fptr < nf) {\n        fi = -f[fptr]\n        fa = abs(fi)\n      }\n    }\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    }\n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n  }\n  while(eptr < ne) {\n    a = ei\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    }\n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n    eptr += 1\n    if(eptr < ne) {\n      ei = e[eptr]\n    }\n  }\n  while(fptr < nf) {\n    a = fi\n    b = q0\n    x = a + b\n    bv = x - a\n    y = b - bv\n    if(y) {\n      g[count++] = y\n    } \n    _x = q1 + x\n    _bv = _x - q1\n    _av = _x - _bv\n    _br = x - _bv\n    _ar = q1 - _av\n    q0 = _ar + _br\n    q1 = _x\n    fptr += 1\n    if(fptr < nf) {\n      fi = -f[fptr]\n    }\n  }\n  if(q0) {\n    g[count++] = q0\n  }\n  if(q1) {\n    g[count++] = q1\n  }\n  if(!count) {\n    g[count++] = 0.0  \n  }\n  g.length = count\n  return g\n}","\"use strict\"\n\nvar twoProduct = require(\"two-product\")\nvar robustSum = require(\"robust-sum\")\nvar robustScale = require(\"robust-scale\")\nvar robustSubtract = require(\"robust-subtract\")\n\nvar NUM_EXPAND = 5\n\nvar EPSILON     = 1.1102230246251565e-16\nvar ERRBOUND3   = (3.0 + 16.0 * EPSILON) * EPSILON\nvar ERRBOUND4   = (7.0 + 56.0 * EPSILON) * EPSILON\n\nfunction orientation_3(sum, prod, scale, sub) {\n  return function orientation3Exact(m0, m1, m2) {\n    var p = sum(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])))\n    var n = sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0]))\n    var d = sub(p, n)\n    return d[d.length - 1]\n  }\n}\n\nfunction orientation_4(sum, prod, scale, sub) {\n  return function orientation4Exact(m0, m1, m2, m3) {\n    var p = sum(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))))\n    var n = sum(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), sum(scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))))\n    var d = sub(p, n)\n    return d[d.length - 1]\n  }\n}\n\nfunction orientation_5(sum, prod, scale, sub) {\n  return function orientation5Exact(m0, m1, m2, m3, m4) {\n    var p = sum(sum(sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m2[2]), sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), -m3[2]), scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m4[2]))), m1[3]), sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m3[2]), scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m4[2]))), -m2[3]), scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m4[2]))), m3[3]))), sum(scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), -m4[3]), sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m3[2]), scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m4[2]))), m0[3]), scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m3[2]), scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), m4[2]))), -m1[3])))), sum(sum(scale(sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m4[2]))), m3[3]), sum(scale(sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))), -m4[3]), scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), m0[3]))), sum(scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), -m1[3]), sum(scale(sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))), m2[3]), scale(sum(scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))), -m3[3])))))\n    var n = sum(sum(sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m2[2]), sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), -m3[2]), scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m4[2]))), m0[3]), scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m3[2]), scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), m4[2]))), -m2[3])), sum(scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m4[2]))), m3[3]), scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), -m4[3]))), sum(sum(scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m4[2]))), m0[3]), scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m4[2]))), -m1[3])), sum(scale(sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m4[2]))), m2[3]), scale(sum(scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))), -m4[3]))))\n    var d = sub(p, n)\n    return d[d.length - 1]\n  }\n}\n\nfunction orientation(n) {\n  var fn =\n    n === 3 ? orientation_3 :\n    n === 4 ? orientation_4 : orientation_5\n\n  return fn(robustSum, twoProduct, robustScale, robustSubtract)\n}\n\nvar orientation3Exact = orientation(3)\nvar orientation4Exact = orientation(4)\n\nvar CACHED = [\n  function orientation0() { return 0 },\n  function orientation1() { return 0 },\n  function orientation2(a, b) {\n    return b[0] - a[0]\n  },\n  function orientation3(a, b, c) {\n    var l = (a[1] - c[1]) * (b[0] - c[0])\n    var r = (a[0] - c[0]) * (b[1] - c[1])\n    var det = l - r\n    var s\n    if(l > 0) {\n      if(r <= 0) {\n        return det\n      } else {\n        s = l + r\n      }\n    } else if(l < 0) {\n      if(r >= 0) {\n        return det\n      } else {\n        s = -(l + r)\n      }\n    } else {\n      return det\n    }\n    var tol = ERRBOUND3 * s\n    if(det >= tol || det <= -tol) {\n      return det\n    }\n    return orientation3Exact(a, b, c)\n  },\n  function orientation4(a,b,c,d) {\n    var adx = a[0] - d[0]\n    var bdx = b[0] - d[0]\n    var cdx = c[0] - d[0]\n    var ady = a[1] - d[1]\n    var bdy = b[1] - d[1]\n    var cdy = c[1] - d[1]\n    var adz = a[2] - d[2]\n    var bdz = b[2] - d[2]\n    var cdz = c[2] - d[2]\n    var bdxcdy = bdx * cdy\n    var cdxbdy = cdx * bdy\n    var cdxady = cdx * ady\n    var adxcdy = adx * cdy\n    var adxbdy = adx * bdy\n    var bdxady = bdx * ady\n    var det = adz * (bdxcdy - cdxbdy)\n            + bdz * (cdxady - adxcdy)\n            + cdz * (adxbdy - bdxady)\n    var permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz)\n                  + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz)\n                  + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz)\n    var tol = ERRBOUND4 * permanent\n    if ((det > tol) || (-det > tol)) {\n      return det\n    }\n    return orientation4Exact(a,b,c,d)\n  }\n]\n\nfunction slowOrient(args) {\n  var proc = CACHED[args.length]\n  if(!proc) {\n    proc = CACHED[args.length] = orientation(args.length)\n  }\n  return proc.apply(undefined, args)\n}\n\nfunction proc (slow, o0, o1, o2, o3, o4, o5) {\n  return function getOrientation(a0, a1, a2, a3, a4) {\n    switch (arguments.length) {\n      case 0:\n      case 1:\n        return 0;\n      case 2:\n        return o2(a0, a1)\n      case 3:\n        return o3(a0, a1, a2)\n      case 4:\n        return o4(a0, a1, a2, a3)\n      case 5:\n        return o5(a0, a1, a2, a3, a4)\n    }\n\n    var s = new Array(arguments.length)\n    for (var i = 0; i < arguments.length; ++i) {\n      s[i] = arguments[i]\n    }\n    return slow(s)\n  }\n}\n\nfunction generateOrientationProc() {\n  while(CACHED.length <= NUM_EXPAND) {\n    CACHED.push(orientation(CACHED.length))\n  }\n  module.exports = proc.apply(undefined, [slowOrient].concat(CACHED))\n  for(var i=0; i<=NUM_EXPAND; ++i) {\n    module.exports[i] = CACHED[i]\n  }\n}\n\ngenerateOrientationProc()","module.exports = robustPointInPolygon\n\nvar orient = require('robust-orientation')\n\nfunction robustPointInPolygon(vs, point) {\n  var x = point[0]\n  var y = point[1]\n  var n = vs.length\n  var inside = 1\n  var lim = n\n  for(var i = 0, j = n-1; i<lim; j=i++) {\n    var a = vs[i]\n    var b = vs[j]\n    var yi = a[1]\n    var yj = b[1]\n    if(yj < yi) {\n      if(yj < y && y < yi) {\n        var s = orient(a, b, point)\n        if(s === 0) {\n          return 0\n        } else {\n          inside ^= (0 < s)|0\n        }\n      } else if(y === yi) {\n        var c = vs[(i+1)%n]\n        var yk = c[1]\n        if(yi < yk) {\n          var s = orient(a, b, point)\n          if(s === 0) {\n            return 0\n          } else {\n            inside ^= (0 < s)|0\n          }\n        }\n      }\n    } else if(yi < yj) {\n      if(yi < y && y < yj) {\n        var s = orient(a, b, point)\n        if(s === 0) {\n          return 0\n        } else {\n          inside ^= (s < 0)|0\n        }\n      } else if(y === yi) {\n        var c = vs[(i+1)%n]\n        var yk = c[1]\n        if(yk < yi) {\n          var s = orient(a, b, point)\n          if(s === 0) {\n            return 0\n          } else {\n            inside ^= (s < 0)|0\n          }\n        }\n      }\n    } else if(y === yi) {\n      var x0 = Math.min(a[0], b[0])\n      var x1 = Math.max(a[0], b[0])\n      if(i === 0) {\n        while(j>0) {\n          var k = (j+n-1)%n\n          var p = vs[k]\n          if(p[1] !== y) {\n            break\n          }\n          var px = p[0]\n          x0 = Math.min(x0, px)\n          x1 = Math.max(x1, px)\n          j = k\n        }\n        if(j === 0) {\n          if(x0 <= x && x <= x1) {\n            return 0\n          }\n          return 1 \n        }\n        lim = j+1\n      }\n      var y0 = vs[(j+n-1)%n][1]\n      while(i+1<lim) {\n        var p = vs[i+1]\n        if(p[1] !== y) {\n          break\n        }\n        var px = p[0]\n        x0 = Math.min(x0, px)\n        x1 = Math.max(x1, px)\n        i += 1\n      }\n      if(x0 <= x && x <= x1) {\n        return 0\n      }\n      var y1 = vs[(i+1)%n][1]\n      if(x < x0 && (y0 < y !== y1 < y)) {\n        inside ^= 1\n      }\n    }\n  }\n  return 2 * inside - 1\n}","/**\n * Convert object points into array points.\n * @param points - Array of points as objects.\n * @returns Array of points as arrays.\n */\nexport function arrayPointsToObjects(points) {\n    const result = [];\n    for (const point of points) {\n        result.push([point.column, point.row]);\n    }\n    return result;\n}\n//# sourceMappingURL=arrayPointsToObjects.js.map","import robustPointInPolygon from 'robust-point-in-polygon';\nimport { arrayPointsToObjects } from '../utils/arrayPointsToObjects.js';\nimport { getOutputImage } from '../utils/getOutputImage.js';\nimport { setBlendedVisiblePixel } from '../utils/setBlendedVisiblePixel.js';\nimport checkProcessable from '../utils/validators/checkProcessable.js';\nimport { validateColor } from '../utils/validators/validators.js';\nimport { deleteDuplicates } from './utils/deleteDuplicates.js';\n/**\n * Draw a polygon defined by an array of points onto an image.\n * @param image - Image to process.\n * @param points - Polygon vertices.\n * @param options - Draw Line options.\n * @returns The image with the polygon drawing.\n */\nexport function drawPolygonOnImage(image, points, options = {}) {\n    const { fillColor, origin = { column: 0, row: 0 }, ...otherOptions } = options;\n    checkProcessable(image, {\n        bitDepth: [8, 16],\n    });\n    const newImage = getOutputImage(image, options, { clone: true });\n    if (fillColor === undefined) {\n        return newImage.drawPolyline([...points, points[0]], {\n            origin,\n            ...otherOptions,\n        });\n    }\n    else {\n        validateColor(fillColor, newImage);\n        const filteredPoints = deleteDuplicates(points);\n        const arrayPoints = arrayPointsToObjects(filteredPoints);\n        for (let row = 0; row < newImage.height; row++) {\n            for (let column = 0; column < newImage.width; column++) {\n                if (robustPointInPolygon(arrayPoints, [column, row]) === -1) {\n                    setBlendedVisiblePixel(newImage, Math.round(origin.column) + column, Math.round(origin.row) + row, fillColor);\n                }\n            }\n        }\n    }\n    return newImage.drawPolyline([...points, points[0]], {\n        origin,\n        ...otherOptions,\n    });\n}\n//# sourceMappingURL=drawPolygonOnImage.js.map","import robustPointInPolygon from 'robust-point-in-polygon';\nimport { arrayPointsToObjects } from '../utils/arrayPointsToObjects.js';\nimport { maskToOutputMask } from '../utils/getOutputImage.js';\nimport { deleteDuplicates } from './utils/deleteDuplicates.js';\n/**\n * Draw a polygon defined by an array of points on a mask.\n * @param mask - Mask to process.\n * @param points - Polygon vertices.\n * @param options - Draw Line options.\n * @returns The mask with the polygon drawing.\n */\nexport function drawPolygonOnMask(mask, points, options = {}) {\n    const { filled = false, origin = { column: 0, row: 0 }, ...otherOptions } = options;\n    const newMask = maskToOutputMask(mask, options, { clone: true });\n    if (!filled) {\n        return newMask.drawPolyline([...points, points[0]], {\n            origin,\n            ...otherOptions,\n        });\n    }\n    const filteredPoints = deleteDuplicates(points);\n    const arrayPoints = arrayPointsToObjects(filteredPoints);\n    for (let row = 0; row < newMask.height; row++) {\n        for (let column = 0; column < newMask.width; column++) {\n            if (robustPointInPolygon(arrayPoints, [column, row]) === -1) {\n                newMask.setBit(Math.round(origin.column) + column, Math.round(origin.row) + row, 1);\n            }\n        }\n    }\n    return newMask.drawPolyline([...points, points[0]], {\n        origin,\n        ...otherOptions,\n    });\n}\n//# sourceMappingURL=drawPolygonOnMask.js.map","import { Image } from '../Image.js';\nimport { getDefaultColor } from '../utils/getDefaultColor.js';\nimport { getOutputImage, maskToOutputMask } from '../utils/getOutputImage.js';\nimport { setBlendedVisiblePixel } from '../utils/setBlendedVisiblePixel.js';\nimport checkProcessable from '../utils/validators/checkProcessable.js';\nimport { validateColor } from \"../utils/validators/validators.js\";\n/**\n * Draw a rectangle defined by position of the top-left corner, width and height.\n * @param image - Image to process.\n * @param options - Draw rectangle options.\n * @returns The image with the rectangle drawing.\n */\nexport function drawRectangle(image, options = {}) {\n    const { width: rectangleWidth = image.width, height: rectangleHeight = image.height, origin = { column: 0, row: 0 }, strokeColor = getDefaultColor(image), fillColor, } = options;\n    const width = Math.round(rectangleWidth);\n    const height = Math.round(rectangleHeight);\n    const column = Math.round(origin.column);\n    const row = Math.round(origin.row);\n    let newImage;\n    if (image instanceof Image) {\n        checkProcessable(image, {\n            bitDepth: [8, 16],\n        });\n        validateColor(strokeColor, image);\n        if (fillColor) {\n            validateColor(fillColor, image);\n        }\n        newImage = getOutputImage(image, options, { clone: true });\n    }\n    else {\n        newImage = maskToOutputMask(image, options, { clone: true });\n    }\n    for (let currentColumn = column; currentColumn < column + width; currentColumn++) {\n        setBlendedVisiblePixel(newImage, currentColumn, row, strokeColor);\n        setBlendedVisiblePixel(newImage, currentColumn, row + height - 1, strokeColor);\n    }\n    for (let currentRow = row + 1; currentRow < row + height - 1; currentRow++) {\n        setBlendedVisiblePixel(newImage, column, currentRow, strokeColor);\n        setBlendedVisiblePixel(newImage, column + width - 1, currentRow, strokeColor);\n    }\n    if (fillColor) {\n        for (let currentRow = row + 1; currentRow < row + height - 1; currentRow++) {\n            for (let currentColumn = column + 1; currentColumn < column + width - 1; currentColumn++) {\n                setBlendedVisiblePixel(newImage, currentColumn, currentRow, fillColor);\n            }\n        }\n    }\n    return newImage;\n}\n//# sourceMappingURL=drawRectangle.js.map","import { Image } from '../Image.js';\nimport { getDefaultColor } from '../utils/getDefaultColor.js';\nimport { getOutputImage, maskToOutputMask } from '../utils/getOutputImage.js';\nimport { setBlendedVisiblePixel } from '../utils/setBlendedVisiblePixel.js';\nimport checkProcessable from '../utils/validators/checkProcessable.js';\nimport { validateColor } from '../utils/validators/validators.js';\n/**\n * Draw a set of points on an image or a mask.\n * @param image - The image on which to draw the points.\n * @param points - Array of points.\n * @param options - Draw points on Image options.\n * @returns New mask.\n */\nexport function drawPoints(image, points, options = {}) {\n    const { color = getDefaultColor(image), origin = { row: 0, column: 0 } } = options;\n    let newImage;\n    if (image instanceof Image) {\n        newImage = getOutputImage(image, options, { clone: true });\n        validateColor(color, newImage);\n    }\n    else {\n        newImage = maskToOutputMask(image, options, { clone: true });\n    }\n    checkProcessable(newImage, {\n        bitDepth: [1, 8, 16],\n    });\n    for (const point of points) {\n        setBlendedVisiblePixel(newImage, Math.round(origin.column + point.column), Math.round(origin.row + point.row), color);\n    }\n    return newImage;\n}\n//# sourceMappingURL=drawPoints.js.map","import { getDefaultColor } from '../utils/getDefaultColor.js';\nimport { getOutputImage } from '../utils/getOutputImage.js';\nimport checkProcessable from '../utils/validators/checkProcessable.js';\nimport { validateColor } from '../utils/validators/validators.js';\n/**\n * Draw a marker on the image.\n * @param image - Image to process.\n * @param point - Marker center point.\n * @param options - Draw marker options.\n * @returns The image with the marker drawing.\n */\nexport function drawMarker(image, point, options) {\n    const newImage = getOutputImage(image, options, { clone: true });\n    const { strokeColor = getDefaultColor(newImage), fillColor, shape = 'cross', size: markerSize = 1, } = options;\n    const size = Math.round(markerSize);\n    validateColor(strokeColor, newImage);\n    if (fillColor) {\n        validateColor(fillColor, newImage);\n    }\n    checkProcessable(newImage, {\n        bitDepth: [8, 16],\n    });\n    if (shape === 'circle') {\n        newImage.drawCircle(point, size, {\n            strokeColor,\n            fillColor,\n            out: newImage,\n        });\n    }\n    if (shape === 'triangle') {\n        const points = [\n            { row: point.row - size, column: point.column },\n            { row: point.row, column: point.column + size },\n            { row: point.row, column: point.column - size },\n        ];\n        newImage.drawPolygon(points, {\n            strokeColor,\n            fillColor,\n            out: newImage,\n        });\n    }\n    if (shape === 'cross') {\n        newImage.drawLine({ row: point.row - size, column: point.column }, { row: point.row + size, column: point.column }, { strokeColor, out: newImage });\n        newImage.drawLine({ row: point.row, column: point.column - size }, { row: point.row, column: point.column + size }, { strokeColor, out: newImage });\n    }\n    if (shape === 'square') {\n        const origin = {\n            row: point.row - (size - 1) / 2,\n            column: point.column - (size - 1) / 2,\n        };\n        newImage.drawRectangle({\n            origin,\n            width: size,\n            height: size,\n            strokeColor,\n            fillColor,\n            out: newImage,\n        });\n    }\n    return newImage;\n}\n//# sourceMappingURL=drawMarker.js.map","import { getOutputImage } from '../utils/getOutputImage.js';\nimport { drawMarker } from './drawMarker.js';\n/**\n * Draw markers on the image.\n * @param image - Image to process.\n * @param points - Markers center points.\n * @param options - Draw marker options.\n * @returns The image with the markers drawing.\n */\nexport function drawMarkers(image, points, options = {}) {\n    const newImage = getOutputImage(image, options, { clone: true });\n    for (const point of points) {\n        drawMarker(newImage, point, { ...options, out: newImage });\n    }\n    return newImage;\n}\n//# sourceMappingURL=drawMarkers.js.map","import { maskToOutputMask } from '../utils/getOutputImage.js';\n/**\n * Perform an AND operation on two masks.\n * @param mask - First mask.\n * @param otherMask - Second mask.\n * @param options - And options.\n * @returns AND of the two masks.\n */\nexport function and(mask, otherMask, options) {\n    const newMask = maskToOutputMask(mask, options);\n    if (mask.width !== otherMask.width || mask.height !== otherMask.height) {\n        throw new RangeError('both masks must have the same size');\n    }\n    for (let i = 0; i < newMask.size; i++) {\n        if (mask.getBitByIndex(i) && otherMask.getBitByIndex(i)) {\n            newMask.setBitByIndex(i, 1);\n        }\n        else {\n            newMask.setBitByIndex(i, 0);\n        }\n    }\n    return newMask;\n}\n//# sourceMappingURL=and.js.map","export function checkSize(size) {\n  if (!Number.isInteger(size) || size < 1) {\n    throw new TypeError(`size must be a positive integer. Got ${size}`);\n  }\n}\n\nexport function checkKernel(kernel) {\n  if (kernel.length === 0 || kernel.length % 2 !== 1) {\n    throw new RangeError(\n      `kernel must have an odd positive length. Got ${kernel.length}`\n    );\n  }\n}\n\nexport function checkBorderType(borderType) {\n  if (borderType !== 'CONSTANT' && borderType !== 'CUT') {\n    throw new RangeError(`unexpected border type: ${borderType}`);\n  }\n}\n\nexport function checkInputLength(actual, expected) {\n  if (actual !== expected) {\n    throw new RangeError(\n      `input length (${actual}) does not match setup size (${expected})`\n    );\n  }\n}\n\nexport function createArray(len) {\n  const array = [];\n  for (var i = 0; i < len; i++) {\n    array.push(0);\n  }\n  return array;\n}\n","import {\n  checkSize,\n  checkKernel,\n  checkBorderType,\n  checkInputLength,\n  createArray\n} from './utils';\n\nexport class DirectConvolution {\n  constructor(size, kernel, borderType = 'CONSTANT') {\n    checkSize(size);\n    checkKernel(kernel);\n    checkBorderType(borderType);\n\n    this.size = size;\n    this.kernelOffset = (kernel.length - 1) / 2;\n    this.outputSize =\n      borderType === 'CONSTANT' ? size : size - 2 * this.kernelOffset;\n    this.output = createArray(this.outputSize);\n    this.kernel = kernel;\n    this.kernelSize = kernel.length;\n    this.borderType = borderType;\n  }\n\n  convolve(input) {\n    checkInputLength(input.length, this.size);\n    this.output.fill(0);\n    if (this.borderType === 'CONSTANT') {\n      this._convolutionBorder0(input);\n    } else {\n      this._convolutionBorderCut(input);\n    }\n    return this.output;\n  }\n\n  _convolutionBorder0(input) {\n    for (let i = 0; i < this.size; i++) {\n      for (let j = 0; j < this.kernelSize; j++) {\n        this.output[i] +=\n          interpolateInput(input, i - this.kernelOffset + j) * this.kernel[j];\n      }\n    }\n  }\n\n  _convolutionBorderCut(input) {\n    for (let i = this.kernelOffset; i < this.size - this.kernelOffset; i++) {\n      const index = i - this.kernelOffset;\n      for (let j = 0; j < this.kernelSize; j++) {\n        this.output[index] += input[index + j] * this.kernel[j];\n      }\n    }\n  }\n}\n\nexport function directConvolution(input, kernel, borderType) {\n  return new DirectConvolution(input.length, kernel, borderType).convolve(\n    input\n  );\n}\n\nfunction interpolateInput(input, idx) {\n  if (idx < 0) return 0;\n  else if (idx >= input.length) return 0;\n  return input[idx];\n}\n","export * from './directConvolution';\nexport * from './fftConvolution';\n\nexport const BorderType = {\n  CONSTANT: 'CONSTANT',\n  CUT: 'CUT'\n};\n","import { match } from 'ts-pattern';\nexport const BorderType = {\n    CONSTANT: 'constant',\n    REPLICATE: 'replicate',\n    REFLECT: 'reflect',\n    WRAP: 'wrap',\n    REFLECT_101: 'reflect101',\n};\n/**\n * Pick the border interpolation algorithm.\n * The different algorithms are illustrated here:\n * @see {@link https://vovkos.github.io/doxyrest-showcase/opencv/sphinx_rtd_theme/enum_cv_BorderTypes.html}\n * @param type - The border type.\n * @param value - A pixel value if BorderType.CONSTANT is used.\n * @returns The border interpolation function.\n */\nexport function getBorderInterpolation(type, value) {\n    return match(type)\n        .with('constant', () => getInterpolateConstant(value))\n        .with('replicate', () => interpolateReplicate)\n        .with('reflect', () => interpolateReflect)\n        .with('reflect101', () => interpolateReflect101)\n        .with('wrap', () => interpolateWrap)\n        .exhaustive();\n}\nfunction checkRange(point, length) {\n    if (point <= 0 - length || point >= length + length - 1) {\n        throw new RangeError('border must be smaller than the original image');\n    }\n}\nfunction getInterpolateConstant(value) {\n    return function interpolateConstant(column, row, channel, image) {\n        const newColumn = interpolateConstantPoint(column, image.width);\n        const newRow = interpolateConstantPoint(row, image.height);\n        if (newColumn === -1 || newRow === -1) {\n            return value;\n        }\n        return image.getValue(newColumn, newRow, channel);\n    };\n}\n/**\n * Interpolate using a constant point.\n * @param point - The point to interpolate.\n * @param length  - The length of the image.\n * @returns The interpolated point.\n */\nexport function interpolateConstantPoint(point, length) {\n    if (point >= 0 && point < length) {\n        return point;\n    }\n    return -1;\n}\nfunction interpolateReplicate(column, row, channel, image) {\n    return image.getValue(interpolateReplicatePoint(column, image.width), interpolateReplicatePoint(row, image.height), channel);\n}\n/**\n * Interpolate by replicating the border.\n * @param point - The point to interpolate.\n * @param length - The length of the image.\n * @returns The interpolated point.\n */\nexport function interpolateReplicatePoint(point, length) {\n    if (point >= 0 && point < length) {\n        return point;\n    }\n    checkRange(point, length);\n    if (point < 0) {\n        return 0;\n    }\n    else {\n        return length - 1;\n    }\n}\nfunction interpolateReflect(column, row, channel, image) {\n    return image.getValue(interpolateReflectPoint(column, image.width), interpolateReflectPoint(row, image.height), channel);\n}\n/**\n * Interpolate by reflecting the border.\n * @param point - The point to interpolate.\n * @param length - The length of the image.\n * @returns The interpolated point.\n */\nexport function interpolateReflectPoint(point, length) {\n    if (point >= 0 && point < length) {\n        return point;\n    }\n    checkRange(point, length);\n    if (point < 0) {\n        return -1 - point;\n    }\n    else {\n        return length + length - 1 - point;\n    }\n}\nfunction interpolateWrap(column, row, channel, image) {\n    return image.getValue(interpolateWrapPoint(column, image.width), interpolateWrapPoint(row, image.height), channel);\n}\n/**\n * Interpolate by wrapping the border.\n * @param point - The point to interpolate.\n * @param length - The length of the image.\n * @returns The interpolated point.\n */\nexport function interpolateWrapPoint(point, length) {\n    if (point >= 0 && point < length) {\n        return point;\n    }\n    checkRange(point, length);\n    if (point < 0) {\n        return length + point;\n    }\n    else {\n        return point - length;\n    }\n}\nfunction interpolateReflect101(column, row, channel, image) {\n    return image.getValue(interpolateReflect101Point(column, image.width), interpolateReflect101Point(row, image.height), channel);\n}\n/**\n * Interpolate by reflecting the border.\n * @param point - The point to interpolate.\n * @param length - The length of the image.\n * @returns The interpolated point.\n */\nexport function interpolateReflect101Point(point, length) {\n    if (point >= 0 && point < length) {\n        return point;\n    }\n    checkRange(point, length);\n    if (point < 0) {\n        return 0 - point;\n    }\n    else {\n        return length + length - 2 - point;\n    }\n}\n//# sourceMappingURL=interpolateBorder.js.map","import { Image } from '../Image.js';\nimport { getBorderInterpolation } from '../utils/interpolateBorder.js';\n/**\n * Extend the borders of an image according to the given border type.\n * @param image - Image to extend.\n * @param options - Options.\n * @returns A copy of the image with extended borders.\n */\nexport function extendBorders(image, options) {\n    const { horizontal, vertical, borderType = 'reflect101', borderValue = 0, } = options;\n    const interpolateBorder = getBorderInterpolation(borderType, borderValue);\n    const newImage = Image.createFrom(image, {\n        width: image.width + 2 * horizontal,\n        height: image.height + 2 * vertical,\n    });\n    image.copyTo(newImage, {\n        origin: {\n            column: horizontal,\n            row: vertical,\n        },\n        out: newImage,\n    });\n    // Top strip\n    for (let row = 0; row < vertical; row++) {\n        for (let col = 0; col < newImage.width; col++) {\n            for (let channel = 0; channel < image.channels; channel++) {\n                const newValue = interpolateBorder(col - horizontal, row - vertical, channel, image);\n                newImage.setValue(col, row, channel, newValue);\n            }\n        }\n    }\n    // Bottom strip\n    for (let row = newImage.height - vertical; row < newImage.height; row++) {\n        for (let col = 0; col < newImage.width; col++) {\n            for (let channel = 0; channel < image.channels; channel++) {\n                const newValue = interpolateBorder(col - horizontal, row - vertical, channel, image);\n                newImage.setValue(col, row, channel, newValue);\n            }\n        }\n    }\n    // Left strip\n    for (let row = vertical; row < newImage.height - vertical; row++) {\n        for (let col = 0; col < horizontal; col++) {\n            for (let channel = 0; channel < image.channels; channel++) {\n                const newValue = interpolateBorder(col - horizontal, row - vertical, channel, image);\n                newImage.setValue(col, row, channel, newValue);\n            }\n        }\n    }\n    // Right strip\n    for (let row = vertical; row < newImage.height - vertical; row++) {\n        for (let col = newImage.width - horizontal; col < newImage.width; col++) {\n            for (let channel = 0; channel < image.channels; channel++) {\n                const newValue = interpolateBorder(col - horizontal, row - vertical, channel, image);\n                newImage.setValue(col, row, channel, newValue);\n            }\n        }\n    }\n    return newImage;\n}\n//# sourceMappingURL=extendBorders.js.map","/**\n * Round a pixel value.\n * @param value - Value of the pixel.\n * @returns The rounded value.\n */\nexport function round(value) {\n    const integer = Math.trunc(value);\n    const decimal = value - integer;\n    if (decimal < 0.5) {\n        return integer;\n    }\n    else if (decimal > 0.5) {\n        return integer + 1;\n    }\n    else {\n        return integer % 2 === 0 ? integer : integer + 1;\n    }\n}\n//# sourceMappingURL=round.js.map","import { BorderType as ConvolutionBorderType, DirectConvolution, } from 'ml-convolution';\nimport { Image } from '../Image.js';\nimport { extendBorders } from '../operations/extendBorders.js';\nimport { getClamp } from '../utils/clamp.js';\nimport { getIndex } from '../utils/getIndex.js';\nimport { getOutputImage } from '../utils/getOutputImage.js';\nimport { getBorderInterpolation } from '../utils/interpolateBorder.js';\nimport { round } from '../utils/round.js';\n/**\n * Apply a direct convolution on an image using the specified kernel. The convolution corresponds of a weighted average of the surrounding pixels, the weights being defined in the kernel.\n * @param image - The image to process.\n * @param kernel - Kernel to use for the convolution. Should be a 2D matrix with odd number of rows and columns.\n * @param options - Convolution options.\n * @returns The convoluted image.\n */\nexport function directConvolution(image, kernel, options = {}) {\n    const { borderType = 'reflect101', borderValue = 0 } = options;\n    const convolutedData = rawDirectConvolution(image, kernel, {\n        borderType,\n        borderValue,\n    });\n    const newImage = getOutputImage(image, options);\n    const clamp = getClamp(newImage);\n    for (let i = 0; i < image.size; i++) {\n        for (let channel = 0; channel < image.channels; channel++) {\n            const dataIndex = i * image.channels + channel;\n            const newValue = round(clamp(convolutedData[dataIndex]));\n            newImage.setValueByIndex(i, channel, newValue);\n        }\n    }\n    return newImage;\n}\n/**\n * Compute direct convolution of an image and return an array with the raw values.\n * @param image - Image to process.\n * @param kernel - 2D kernel used for the convolution.\n * @param options - Convolution options.\n * @returns Array with the raw convoluted values.\n */\nexport function rawDirectConvolution(image, kernel, options = {}) {\n    const { borderType = 'reflect101', borderValue = 0 } = options;\n    const interpolateBorder = getBorderInterpolation(borderType, borderValue);\n    const result = new Float64Array(image.size * image.channels);\n    for (let channel = 0; channel < image.channels; channel++) {\n        for (let row = 0; row < image.height; row++) {\n            for (let column = 0; column < image.width; column++) {\n                const index = getIndex(column, row, image, channel);\n                result[index] = computeConvolutionValue(column, row, channel, image, kernel, interpolateBorder, { returnRawValue: true });\n            }\n        }\n    }\n    return result;\n}\n/**\n * Compute the separable convolution of an image.\n * @param image - Image to convolute.\n * @param kernelX - Kernel along x axis.\n * @param kernelY - Kernel along y axis.\n * @param options - Convolution options.\n * @returns The convoluted image.\n */\nexport function separableConvolution(image, kernelX, kernelY, options = {}) {\n    const { normalize, borderType = 'reflect101', borderValue = 0 } = options;\n    if (normalize) {\n        [kernelX, kernelY] = normalizeSeparatedKernel(kernelX, kernelY);\n    }\n    const doubleKernelOffsetX = kernelX.length - 1;\n    const kernelOffsetX = doubleKernelOffsetX / 2;\n    const doubleKernelOffsetY = kernelY.length - 1;\n    const kernelOffsetY = doubleKernelOffsetY / 2;\n    const extendedImage = extendBorders(image, {\n        horizontal: kernelOffsetX,\n        vertical: kernelOffsetY,\n        borderType,\n        borderValue,\n    });\n    const newImage = Image.createFrom(image);\n    const clamp = getClamp(newImage);\n    const rowConvolution = new DirectConvolution(extendedImage.width, kernelX, ConvolutionBorderType.CUT);\n    const columnConvolution = new DirectConvolution(extendedImage.height, kernelY, ConvolutionBorderType.CUT);\n    const rowData = new Float64Array(extendedImage.width);\n    const columnData = new Float64Array(extendedImage.height);\n    const convolvedData = new Float64Array(\n    // Use `image.width` because convolution with BorderType.CUT reduces the size of the convolved data.\n    image.width * extendedImage.height);\n    for (let channel = 0; channel < extendedImage.channels; channel++) {\n        for (let row = 0; row < extendedImage.height; row++) {\n            for (let column = 0; column < extendedImage.width; column++) {\n                rowData[column] = extendedImage.getValue(column, row, channel);\n            }\n            const convolvedRow = rowConvolution.convolve(rowData);\n            for (let column = 0; column < image.width; column++) {\n                convolvedData[row * image.width + column] = convolvedRow[column];\n            }\n        }\n        for (let column = 0; column < image.width; column++) {\n            for (let row = 0; row < extendedImage.height; row++) {\n                columnData[row] = convolvedData[row * image.width + column];\n            }\n            const convolvedColumn = columnConvolution.convolve(columnData);\n            for (let row = 0; row < image.height; row++) {\n                newImage.setValue(column, row, channel, round(clamp(convolvedColumn[row])));\n            }\n        }\n    }\n    return newImage;\n}\n/**\n * Compute the convolution of a value of a pixel in an image.\n * @param column - Column of the pixel.\n * @param row - Row of the pixel.\n * @param channel - Channel to process.\n * @param image - Image to process.\n * @param kernel - Kernel for the convolutions.\n * @param interpolateBorder - Function to interpolate the border pixels.\n * @param options - Compute convolution value options.\n * @returns The convoluted value.\n */\nexport function computeConvolutionValue(column, row, channel, image, kernel, interpolateBorder, options = {}) {\n    let { clamp } = options;\n    const { returnRawValue = false } = options;\n    if (returnRawValue) {\n        clamp = undefined;\n    }\n    let val = 0;\n    const kernelWidth = kernel[0].length;\n    const kernelHeight = kernel.length;\n    const kernelOffsetX = (kernelWidth - 1) / 2;\n    const kernelOffsetY = (kernelHeight - 1) / 2;\n    for (let kY = 0; kY < kernelHeight; kY++) {\n        for (let kX = 0; kX < kernelWidth; kX++) {\n            const kernelValue = kernel[kY][kX];\n            val +=\n                kernelValue *\n                    interpolateBorder(column + kX - kernelOffsetX, row + kY - kernelOffsetY, channel, image);\n        }\n    }\n    if (!clamp) {\n        return val;\n    }\n    else {\n        return round(clamp(val));\n    }\n}\n/**\n * Normalize a separated kernel.\n * @param kernelX - Horizontal component of the separated kernel.\n * @param kernelY - Vertical component of the separated kernel.\n * @returns The normalized kernel.\n */\nfunction normalizeSeparatedKernel(kernelX, kernelY) {\n    const sumKernelX = kernelX.reduce((prev, current) => prev + current, 0);\n    const sumKernelY = kernelY.reduce((prev, current) => prev + current, 0);\n    const prod = sumKernelX * sumKernelY;\n    if (prod < 0) {\n        throw new RangeError('this separated kernel cannot be normalized');\n    }\n    const factor = 1 / Math.sqrt(Math.abs(prod));\n    return [kernelX.map((v) => v * factor), kernelY.map((v) => v * factor)];\n}\n//# sourceMappingURL=convolution.js.map","import { separableConvolution } from './convolution.js';\n/**\n * Blur an image. The pixel in the center becomes an average of the surrounding ones.\n * @param image - Image to blur.\n * @param options - Blur options.\n * @returns The blurred image.\n */\nexport function blur(image, options) {\n    const { width, height } = options;\n    if (width < 1 || width % 2 === 0) {\n        throw new RangeError(`Invalid property \"width\". Must be an odd number greater than 0. Received ${width}.`);\n    }\n    if (height < 1 || height % 2 === 0) {\n        throw new RangeError(`Invalid property \"height\". Must be an odd number greater than 0. Received ${height}.`);\n    }\n    const kernelX = new Array(width).fill(1);\n    const kernelY = new Array(height).fill(1);\n    return separableConvolution(image, kernelX, kernelY, {\n        normalize: true,\n        ...options,\n    });\n}\n//# sourceMappingURL=blur.js.map","import { match } from 'ts-pattern';\nimport { PREWITT_X, PREWITT_Y, SCHARR_X, SCHARR_Y, SOBEL_X, SOBEL_Y, } from '../utils/constants/kernels.js';\nexport const DerivativeFilter = {\n    SOBEL: 'sobel',\n    SCHARR: 'scharr',\n    PREWITT: 'prewitt',\n    // todo: handle even sized kernels to implement Roberts' filter\n    // for 2x2 matrices, the current pixel corresponds to the top-left\n    //  ROBERTS = 'roberts',\n};\n/**\n * Apply a derivative filter to an image.\n * @param image - Image to process.\n * @param options - Derivative filter options.\n * @returns The processed image.\n */\nexport function derivativeFilter(image, options = {}) {\n    const { filter = 'sobel' } = options;\n    const kernels = match(filter)\n        .with('sobel', () => ({ kernelX: SOBEL_X, kernelY: SOBEL_Y }))\n        .with('scharr', () => ({ kernelX: SCHARR_X, kernelY: SCHARR_Y }))\n        .with('prewitt', () => ({ kernelX: PREWITT_X, kernelY: PREWITT_Y }))\n        .exhaustive();\n    return image.gradientFilter({ ...kernels, ...options });\n}\n//# sourceMappingURL=derivativeFilter.js.map","export const ImageColorModel = {\n    GREY: 'GREY',\n    GREYA: 'GREYA',\n    RGB: 'RGB',\n    RGBA: 'RGBA',\n    BINARY: 'BINARY',\n};\nexport const colorModels = {\n    GREY: {\n        components: 1,\n        alpha: false,\n        channels: 1,\n    },\n    GREYA: {\n        components: 1,\n        alpha: true,\n        channels: 2,\n    },\n    RGB: {\n        components: 3,\n        alpha: false,\n        channels: 3,\n    },\n    RGBA: {\n        components: 3,\n        alpha: true,\n        channels: 4,\n    },\n    BINARY: {\n        components: 1,\n        alpha: false,\n        channels: 1,\n    },\n};\n//# sourceMappingURL=colorModels.js.map","import { ImageColorModel } from '../utils/constants/colorModels.js';\nimport checkProcessable from '../utils/validators/checkProcessable.js';\n/**\n * Increase the contrast of an image by spanning each channel on the range [0, image.maxValue].\n * This algorithm is based on the level algorithm.\n * @param image - The image to enhance.\n * @param options - Increase contrast options.\n * @returns The enhanced image.\n */\nexport function increaseContrast(image, options = {}) {\n    const { uniform = false } = options;\n    checkProcessable(image, {\n        bitDepth: [8, 16],\n    });\n    const minMax = image.minMax();\n    let min = minMax.min;\n    let max = minMax.max;\n    if (uniform) {\n        let maxDiffIndex = -1;\n        let previousDiff = -1;\n        for (let i = 0; i < minMax.max.length; i++) {\n            const difference = minMax.max[i] - minMax.min[i];\n            if (difference > previousDiff) {\n                maxDiffIndex = i;\n                previousDiff = difference;\n            }\n        }\n        min = minMax.min[maxDiffIndex];\n        max = minMax.max[maxDiffIndex];\n    }\n    let channels = new Array(image.components)\n        .fill(0)\n        .map((value, index) => index);\n    if (image.colorModel === ImageColorModel.GREYA) {\n        channels = [0];\n    }\n    else if (image.colorModel === ImageColorModel.RGBA) {\n        channels = [0, 1, 2];\n    }\n    return image.level({\n        inputMin: min,\n        inputMax: max,\n        outputMin: 0,\n        outputMax: image.maxValue,\n        channels,\n        ...options,\n    });\n}\n//# sourceMappingURL=increaseContrast.js.map","import { getRadius } from '../utils/getRadius.js';\nimport { separableConvolution } from './convolution.js';\n/**\n * Apply a gaussian filter to an image.\n * @param image - Image to blur.\n * @param options - Gaussian blur options.\n * @returns The blurred image.\n */\nexport function gaussianBlur(image, options) {\n    if ('sigma' in options) {\n        const { sigma, size = getSize(sigma), borderType } = options;\n        const radius = getRadius(size);\n        const kernel = getKernel(radius, sigma);\n        return separableConvolution(image, kernel, kernel, {\n            borderType,\n        });\n    }\n    else if ('sigmaX' in options && 'sigmaY' in options) {\n        const { sigmaX, sigmaY, sizeX = getSize(sigmaX), sizeY = getSize(sigmaY), borderType, } = options;\n        const radiusX = getRadius(sizeX);\n        const radiusY = getRadius(sizeY);\n        const kernelX = getKernel(radiusX, sigmaX);\n        const kernelY = getKernel(radiusY, sigmaY);\n        return separableConvolution(image, kernelX, kernelY, {\n            borderType,\n        });\n    }\n    else {\n        throw new TypeError('you must either define sigma or sigmaX and sigmaY in the options argument');\n    }\n}\nfunction getKernel(radius, sigma) {\n    const n = radius * 2 + 1;\n    const kernel = new Array(n);\n    // TODO: check if sigma can really be 0 or undefined.\n    const sigmaX = sigma || ((n - 1) * 0.5 - 1) * 0.3 + 0.8;\n    const scale2X = -0.5 / (sigmaX * sigmaX);\n    let sum = 0;\n    for (let i = 0; i < n; i++) {\n        const x = i - radius;\n        const t = Math.exp(scale2X * x * x);\n        kernel[i] = t;\n        sum += t;\n    }\n    for (let i = 0; i < n; i++) {\n        kernel[i] /= sum;\n    }\n    return kernel;\n}\nfunction getSize(sigma) {\n    return 2 * Math.ceil(2 * sigma) + 1;\n}\n//# sourceMappingURL=gaussianBlur.js.map","import { Image } from '../Image.js';\nimport checkProcessable from '../utils/validators/checkProcessable.js';\n/**\n * Apply a gradient filter to an image.\n * @param image - The image to process.\n * @param options - Gradient filter options.\n * @returns The gradient image.\n */\nexport function gradientFilter(image, options) {\n    const { borderType = 'replicate', borderValue = 0 } = options;\n    checkProcessable(image, {\n        bitDepth: [8, 16],\n        colorModel: 'GREY',\n    });\n    if ('kernelX' in options && 'kernelY' in options) {\n        const { kernelX, kernelY } = options;\n        const gradientX = image.rawDirectConvolution(kernelX, {\n            borderType,\n            borderValue,\n        });\n        const gradientY = image.rawDirectConvolution(kernelY, {\n            borderType,\n            borderValue,\n        });\n        const gradient = new Image(image.width, image.height, {\n            colorModel: 'GREY',\n        });\n        for (let i = 0; i < image.size; i++) {\n            gradient.setValueByIndex(i, 0, Math.hypot(gradientX[i], gradientY[i]));\n        }\n        return gradient;\n    }\n    else if ('kernelX' in options) {\n        return image.directConvolution(options.kernelX, {\n            borderType,\n            borderValue,\n        });\n    }\n    else if ('kernelY' in options) {\n        return image.directConvolution(options.kernelY, {\n            borderType,\n            borderValue,\n        });\n    }\n    else {\n        throw new TypeError(`kernelX and KernelY are not defined`);\n    }\n}\n//# sourceMappingURL=gradientFilter.js.map","import { getOutputImage } from '../utils/getOutputImage.js';\nimport checkProcessable from '../utils/validators/checkProcessable.js';\nimport { validateChannels } from '../utils/validators/validators.js';\n/**\n * Calculate a new image that is the hypotenuse between the current image and the otherImage.\n * @param image - First image to process.\n * @param otherImage - Second image.\n * @param options - Hypotenuse options.\n * @returns Hypotenuse of the two images.\n */\nexport function hypotenuse(image, otherImage, options = {}) {\n    const { channels = new Array(image.components).fill(0).map((value, index) => index), } = options;\n    checkProcessable(image, {\n        bitDepth: [8, 16],\n    });\n    if (image.width !== otherImage.width || image.height !== otherImage.height) {\n        throw new RangeError('both images must have the same size');\n    }\n    if (image.alpha !== otherImage.alpha ||\n        image.bitDepth !== otherImage.bitDepth) {\n        throw new RangeError('both images must have the same alpha and bitDepth');\n    }\n    if (image.channels !== otherImage.channels) {\n        throw new RangeError('both images must have the same number of channels');\n    }\n    validateChannels(channels, image);\n    const newImage = getOutputImage(image, {}, { clone: true });\n    for (const channel of channels) {\n        for (let i = 0; i < image.size; i++) {\n            const value = Math.hypot(image.getValueByIndex(i, channel), otherImage.getValueByIndex(i, channel));\n            newImage.setValueByIndex(i, channel, Math.min(value, newImage.maxValue));\n        }\n    }\n    return newImage;\n}\n//# sourceMappingURL=hypotenuse.js.map","import { Image } from '../Image.js';\nimport { getOutputImage, maskToOutputImage } from '../utils/getOutputImage.js';\n/**\n * Convert image to a different color model.\n * @param image - Image to convert.\n * @param colorModel - New color model.\n * @param options - Convert color options.\n * @returns The converted image.\n */\nexport function convertColor(image, colorModel, options = {}) {\n    const canConvert = new Map([\n        ['GREY', ['GREYA', 'RGB', 'RGBA']],\n        ['GREYA', ['GREY', 'RGB', 'RGBA']],\n        ['RGB', ['GREY', 'GREYA', 'RGBA']],\n        ['RGBA', ['GREY', 'GREYA', 'RGB']],\n        ['BINARY', ['GREY', 'RGB', 'RGBA']],\n    ]);\n    if (image.colorModel === colorModel && colorModel !== 'BINARY') {\n        return getOutputImage(image, { out: options.out }, { clone: true });\n    }\n    const canConvertTo = canConvert.get(image.colorModel);\n    if (!canConvertTo?.includes(colorModel)) {\n        throw new RangeError(`conversion from ${image.colorModel} to ${colorModel} not implemented`);\n    }\n    if (image instanceof Image) {\n        const output = getOutputImage(image, options, {\n            newParameters: { colorModel },\n        });\n        if (image.colorModel === 'GREY' || image.colorModel === 'GREYA') {\n            convertGreyToAny(image, output);\n        }\n        if (image.colorModel === 'RGB' || image.colorModel === 'RGBA') {\n            if (colorModel === 'RGB' || colorModel === 'RGBA') {\n                convertRgbToRgb(image, output);\n            }\n            else {\n                // GREYA or GREY\n                convertRgbToGrey(image, output);\n            }\n        }\n        if (!image.alpha && output.alpha) {\n            output.fillAlpha(output.maxValue);\n        }\n        if (image.alpha && output.alpha) {\n            copyAlpha(image, output);\n        }\n        return output;\n    }\n    else if (colorModel === 'GREY') {\n        const output = maskToOutputImage(image, options);\n        convertBinaryToGrey(image, output);\n        return output;\n    }\n    else {\n        const img = new Image(image.width, image.height, {\n            colorModel,\n        });\n        convertBinaryToRgb(image, img);\n        return img;\n    }\n}\n/**\n * Copy alpha channel of source to dest.\n * @param source - Source image.\n * @param dest - Destination image.\n */\nexport function copyAlpha(source, dest) {\n    if (source.size !== dest.size) {\n        throw new RangeError('source and destination have different sizes');\n    }\n    if (!source.alpha) {\n        throw new RangeError('source image does not have alpha');\n    }\n    if (!dest.alpha) {\n        throw new RangeError('destination does not have alpha');\n    }\n    for (let i = 0; i < dest.size; i++) {\n        dest.setValueByIndex(i, dest.channels - 1, source.getValueByIndex(i, source.channels - 1));\n    }\n}\n/**\n * Convert grey image to other color model.\n * @param image - Image to convert.\n * @param newImage - Converted image.\n */\nfunction convertGreyToAny(image, newImage) {\n    for (let i = 0; i < image.size; i++) {\n        for (let j = 0; j < newImage.components; j++) {\n            newImage.setValueByIndex(i, j, image.getValueByIndex(i, 0));\n        }\n    }\n}\n/**\n * Convert RGB image to RGB. Allows to use convert with an RGB target whatever the image color model is.\n * @param image - Image to convert.\n * @param newImage - Converted image.\n */\nfunction convertRgbToRgb(image, newImage) {\n    for (let i = 0; i < image.size; i++) {\n        for (let j = 0; j < 3; j++) {\n            newImage.setValueByIndex(i, j, image.getValueByIndex(i, j));\n        }\n    }\n}\n/**\n * Convert RGB image to GREY.\n * @param image - Image to convert.\n * @param newImage - Converted image.\n */\nfunction convertRgbToGrey(image, newImage) {\n    for (let i = 0; i < image.size; i++) {\n        const r = image.getValueByIndex(i, 0);\n        const g = image.getValueByIndex(i, 1);\n        const b = image.getValueByIndex(i, 2);\n        newImage.setValueByIndex(i, 0, Math.round(0.299 * r + 0.587 * g + 0.114 * b));\n    }\n}\n/**\n * Convert Mask to GREY.\n * @param mask - Mask to convert.\n * @param newImage - Converted image.\n */\nexport function convertBinaryToGrey(mask, newImage) {\n    for (let i = 0; i < mask.size; i++) {\n        newImage.setValueByIndex(i, 0, mask.getBitByIndex(i) ? newImage.maxValue : 0);\n    }\n}\n/**\n * Convert mask to RGB or RGBA.\n * @param mask - Mask to convert.\n * @param newImage - Converted image.\n */\nexport function convertBinaryToRgb(mask, newImage) {\n    const black = new Array(newImage.components).fill(0);\n    const white = new Array(newImage.components).fill(newImage.maxValue);\n    if (newImage.alpha) {\n        black.push(newImage.maxValue);\n        white.push(newImage.maxValue);\n    }\n    for (let i = 0; i < mask.size; i++) {\n        newImage.setPixelByIndex(i, mask.getBitByIndex(i) ? white : black);\n    }\n}\n//# sourceMappingURL=convertColor.js.map","import { getOutputImage } from '../utils/getOutputImage.js';\n/**\n * Convert the bit depth of an image.\n * @param image - Image to convert.\n * @param newBitDepth - Bit depth to convert to.\n * @param options - Convert bit depth options.\n * @returns Converted image.\n */\nexport function convertBitDepth(image, newBitDepth, options = {}) {\n    if (image.bitDepth === newBitDepth) {\n        return getOutputImage(image, options, { clone: true });\n    }\n    if (newBitDepth !== 8 && newBitDepth !== 16) {\n        throw new RangeError(`This image bit depth is not supported: ${newBitDepth}`);\n    }\n    // Get the output image first - this handles the out option\n    const newImage = getOutputImage(image, options, {\n        clone: false,\n        newParameters: {\n            bitDepth: newBitDepth,\n            colorModel: image.colorModel,\n        },\n    });\n    return newBitDepth === 8\n        ? convertToUint8(image, newImage)\n        : convertToUint16(image, newImage);\n}\n/**\n * Convert bit depth to 16 bits.\n * @param image - Image to convert.\n * @param targetImage - Target image to write to.\n * @returns Converted image.\n */\nfunction convertToUint16(image, targetImage) {\n    for (let i = 0; i < image.size; i++) {\n        for (let j = 0; j < targetImage.channels; j++) {\n            targetImage.setValueByIndex(i, j, image.getValueByIndex(i, j) << 8);\n        }\n    }\n    return targetImage;\n}\n/**\n * Convert bit depth to 8 bits.\n * @param image - Image to convert.\n * @param targetImage - Target image to write to.\n * @returns Converted image.\n */\nfunction convertToUint8(image, targetImage) {\n    for (let i = 0; i < image.size; i++) {\n        for (let j = 0; j < targetImage.channels; j++) {\n            targetImage.setValueByIndex(i, j, image.getValueByIndex(i, j) >> 8);\n        }\n    }\n    return targetImage;\n}\n//# sourceMappingURL=convertBitDepth.js.map","/**\n * Check that the coordinates of a point are integers.\n * @param point - Point to check.\n * @param name - Specify name of the point to include in the error message.\n */\nexport function checkPointIsInteger(point, name = 'Point') {\n    if (!Number.isInteger(point.row) || !Number.isInteger(point.column)) {\n        throw new TypeError(`${name} row and column must be integers`);\n    }\n}\n//# sourceMappingURL=checkPointIsInteger.js.map","import { Image } from '../Image.js';\nimport { assert } from '../utils/validators/assert.js';\nimport { checkPointIsInteger } from '../utils/validators/checkPointIsInteger.js';\n/**\n * Extract the pixels of an image, as specified in a mask.\n * @param image - The image to process.\n * @param mask - The mask defining which pixels to keep.\n * @param options - Extract options.\n * @returns The extracted image.\n */\nexport function extract(image, mask, options = {}) {\n    const { origin = { row: 0, column: 0 } } = options;\n    const { row, column } = origin;\n    assert(row < image.height &&\n        column < image.width &&\n        row + mask.width > 0 &&\n        column + mask.height > 0, 'extract: image and mask have no overlap');\n    checkPointIsInteger(origin, 'Origin');\n    const resultWidth = Math.min(image.width, mask.width + column) - Math.max(0, column);\n    const resultHeight = Math.min(image.height, mask.height + row) - Math.max(0, row);\n    let newImage = new Image(resultWidth, resultHeight, {\n        colorModel: image.colorModel,\n        origin,\n    });\n    if (newImage.alpha) {\n        newImage = newImage.fillAlpha(0);\n    }\n    const imageStartRow = Math.max(0, row);\n    const imageStartColumn = Math.max(0, column);\n    const maskStartRow = row < 0 ? -row : 0;\n    const maskStartColumn = column < 0 ? -column : 0;\n    for (let resultRow = 0; resultRow < resultHeight; resultRow++) {\n        for (let resultColumn = 0; resultColumn < resultWidth; resultColumn++) {\n            if (mask.getBit(maskStartColumn + resultColumn, maskStartRow + resultRow)) {\n                newImage.setPixel(resultColumn, resultRow, image.getPixel(imageStartColumn + resultColumn, imageStartRow + resultRow));\n            }\n        }\n    }\n    return newImage;\n}\n//# sourceMappingURL=extract.js.map","import { Image } from '../Image.js';\n/**\n * Inverse of split. Merges multiple single-channel images into one.\n * @param images - An array of single-channel images.\n * @returns The merged image.\n */\nexport function merge(images) {\n    const channels = images.length;\n    let colorModel;\n    switch (channels) {\n        case 2: {\n            colorModel = 'GREYA';\n            break;\n        }\n        case 3: {\n            colorModel = 'RGB';\n            break;\n        }\n        case 4: {\n            colorModel = 'RGBA';\n            break;\n        }\n        default: {\n            throw new RangeError(`merge expects an array of two to four images. Received ${channels}`);\n        }\n    }\n    const first = images[0];\n    if (first.channels !== 1) {\n        throw new RangeError(`each image must have one channel. Received ${first.channels}`);\n    }\n    for (let i = 1; i < channels; i++) {\n        const img = images[i];\n        if (img.channels !== 1) {\n            throw new RangeError(`each image must have one channel. Received ${img.channels}`);\n        }\n        if (img.width !== first.width ||\n            img.height !== first.height ||\n            img.bitDepth !== first.bitDepth) {\n            throw new RangeError('all images must have the same width, height and bitDepth');\n        }\n    }\n    const newImage = Image.createFrom(first, { colorModel });\n    for (let c = 0; c < channels; c++) {\n        const img = images[c];\n        for (let i = 0; i < newImage.size; i++) {\n            newImage.setValueByIndex(i, c, img.getValueByIndex(i, 0));\n        }\n    }\n    return newImage;\n}\n//# sourceMappingURL=merge.js.map","import { Image } from '../Image.js';\n/**\n * Create an array of single-channel images based on a multi-channel image.\n * @param image - The image with many channels.\n * @returns Array of single-channel images.\n */\nexport function split(image) {\n    const result = [];\n    for (let c = 0; c < image.channels; c++) {\n        const channel = Image.createFrom(image, {\n            colorModel: 'GREY',\n        });\n        for (let i = 0; i < channel.size; i++) {\n            channel.setValueByIndex(i, 0, image.getValueByIndex(i, c));\n        }\n        result.push(channel);\n    }\n    return result;\n}\n//# sourceMappingURL=split.js.map","/*\n * * see http://rsb.info.nih.gov/ij/developer/source/ij/process/AutoThresholder.java.html.\n * Huang: Implements Huang's fuzzy thresholding method: Huang, L-K & Wang, M-J J (1995),\n * \"Image thresholding by minimizing the measure of fuzziness\", Pattern Recognition 28(1): 41-51\n */\n/**\n * Return a threshold for a histogram using Huang algorithm.\n * @param histogram - Image histogram.\n * @returns The threshold.\n */\nexport default function huang(histogram) {\n    /* Determine the first non-zero bin */\n    let firstBin = 0;\n    for (let ih = 0; ih < histogram.length; ih++) {\n        if (histogram[ih] !== 0) {\n            firstBin = ih;\n            break;\n        }\n    }\n    /* Determine the last non-zero bin */\n    let lastBin = histogram.length - 1;\n    for (let ih = histogram.length - 1; ih >= firstBin; ih--) {\n        if (histogram[ih] !== 0) {\n            lastBin = ih;\n            break;\n        }\n    }\n    const term = 1 / (lastBin - firstBin);\n    const mu0 = new Array(histogram.length);\n    let sumPix = 0;\n    let numPix = 0;\n    for (let ih = firstBin; ih < histogram.length; ih++) {\n        sumPix += ih * histogram[ih];\n        numPix += histogram[ih];\n        mu0[ih] = sumPix / numPix;\n    }\n    const mu1 = new Array(histogram.length);\n    sumPix = 0;\n    numPix = 0;\n    for (let ih = lastBin; ih > 0; ih--) {\n        sumPix += ih * histogram[ih];\n        numPix += histogram[ih];\n        mu1[ih - 1] = sumPix / numPix;\n    }\n    /* Determine the threshold that minimizes the fuzzy entropy*/\n    let threshold = -1;\n    let minEnt = Number.MAX_VALUE;\n    for (let it = 0; it < histogram.length; it++) {\n        let ent = 0;\n        let muX;\n        for (let ih = 0; ih <= it; ih++) {\n            /* Equation (4) in Ref. 1 */\n            muX = 1 / (1 + term * Math.abs(ih - mu0[it]));\n            if (!(muX < 1e-6 || muX > 0.999999)) {\n                /* Equation (6) & (8) in Ref. 1 */\n                ent +=\n                    histogram[ih] *\n                        (-muX * Math.log(muX) - (1 - muX) * Math.log(1 - muX));\n            }\n        }\n        for (let ih = it + 1; ih < histogram.length; ih++) {\n            /* Equation (4) in Ref. 1 */\n            muX = 1 / (1 + term * Math.abs(ih - mu1[it]));\n            if (!(muX < 1e-6 || muX > 0.999999)) {\n                /* Equation (6) & (8) in Ref. 1 */\n                ent +=\n                    histogram[ih] *\n                        (-muX * Math.log(muX) - (1 - muX) * Math.log(1 - muX));\n            }\n        }\n        if (ent < minEnt) {\n            minEnt = ent;\n            threshold = it;\n        }\n    }\n    return threshold;\n}\n//# sourceMappingURL=huang.js.map","/*\n *\n * see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java\n * Intermodes: This assumes a bimodal histogram. Implements the thresholding Prewitt, JMS & Mendelsohn, ML (1966),\n * \"The analysis of cell images\", Annals of the NewYork Academy of Sciences 128: 1035-1053\n *\n */\nimport { assert } from '../../utils/validators/assert.js';\n/**\n * Return a threshold for a histogram using Intermodes algorithm.\n * @param histogram - Image histogram.\n * @returns The threshold.\n */\nexport default function intermodes(histogram) {\n    const iHisto = histogram.slice();\n    let iter = 0;\n    while (!bimodalTest(iHisto)) {\n        // smooth with a 3 point running mean filter\n        let previous = 0;\n        let current = 0;\n        let next = iHisto[0];\n        for (let i = 0; i < histogram.length - 1; i++) {\n            previous = current;\n            current = next;\n            next = iHisto[i + 1];\n            iHisto[i] = (previous + current + next) / 3;\n        }\n        iHisto[histogram.length - 1] = (current + next) / 3;\n        iter++;\n        assert(iter < 1000, 'Intermodes threshold not found after 1000 iterations');\n    }\n    // The threshold is the mean between the two peaks.\n    let tt = 0;\n    for (let i = 1; i < histogram.length - 1; i++) {\n        if (iHisto[i - 1] < iHisto[i] && iHisto[i + 1] < iHisto[i]) {\n            tt += i;\n        }\n    }\n    return Math.floor(tt / 2);\n}\nfunction bimodalTest(iHisto) {\n    let b = false;\n    let modes = 0;\n    for (let k = 1; k < iHisto.length - 1; k++) {\n        if (iHisto[k - 1] < iHisto[k] && iHisto[k + 1] < iHisto[k]) {\n            modes++;\n            if (modes > 2) {\n                return false;\n            }\n        }\n    }\n    if (modes === 2) {\n        b = true;\n    }\n    return b;\n}\n//# sourceMappingURL=intermodes.js.map","/*\n * see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java\n * Isodata: Ridler, TW & Calvard, S (1978), \"Picture thresholding using an iterative selection method\"\n * IEEE Transactions on Systems, Man and Cybernetics 8: 630-632.\n *\n */\nimport { assert } from '../../utils/validators/assert.js';\n/**\n * Return a threshold for a histogram using Isodata algorithm.\n * @param histogram - Image histogram.\n * @returns The threshold.\n */\nexport default function isodata(histogram) {\n    let l; // the average grey value of pixels with intensities < g\n    let toth; // the the average grey value of pixels with intensities > g\n    let totl; // the total the average grey value of pixels with intensities < g\n    let h; // the average grey value of pixels with intensities > g\n    let g = 0; // threshold value\n    for (let i = 1; i < histogram.length; i++) {\n        if (histogram[i] > 0) {\n            g = i + 1;\n            break;\n        }\n    }\n    while (true) {\n        l = 0;\n        totl = 0;\n        for (let i = 0; i < g; i++) {\n            totl = totl + histogram[i];\n            l = l + histogram[i] * i;\n        }\n        h = 0;\n        toth = 0;\n        for (let i = g + 1; i < histogram.length; i++) {\n            toth += histogram[i];\n            h += histogram[i] * i;\n        }\n        if (totl > 0 && toth > 0) {\n            l /= totl;\n            h /= toth;\n            if (g === Math.round((l + h) / 2)) {\n                break;\n            }\n        }\n        g++;\n        assert(g <= histogram.length - 2, 'Threshold not found');\n    }\n    return g;\n}\n//# sourceMappingURL=isodata.js.map","/*\n * see http://rsb.info.nih.gov/ij/developer/source/ij/process/AutoThresholder.java.html\n * The method is present in: Implements Li's Minimum Cross Entropy thresholding method\n * This implementation is based on the iterative version (Ref. 2nd reference below) of the algorithm.\n *  1) Li, CH & Lee, CK (1993), \"Minimum Cross Entropy Thresholding\", Pattern Recognition 26(4): 61 625\n *  2) Li, CH & Tam, PKS (1998), \"An Iterative Algorithm for Minimum Cross Entropy Thresholding\",\n *     Pattern Recognition Letters 18(8): 771-776\n *  3) Sezgin, M & Sankur, B (2004), \"Survey over Image Thresholding Techniques and Quantitative Performance\n *     Evaluation\",Journal of Electronic Imaging 13(1): 146-165\n * @param histogram - the histogram of the image\n * @param total - the number of pixels in the image\n * @returns {number} - the threshold\n */\n/**\n * Return a threshold for a histogram using Li algorithm.\n * @param histogram - Image histogram.\n * @param total - Number of pixels in the image.\n * @returns The threshold.\n */\nexport default function li(histogram, total) {\n    let threshold;\n    let sumBack; /* sum of the background pixels at a given threshold */\n    let sumObj; /* sum of the object pixels at a given threshold */\n    let numBack; /* number of background pixels at a given threshold */\n    let numObj; /* number of object pixels at a given threshold */\n    let oldThresh;\n    let newThresh;\n    let meanBack; /* mean of the background pixels at a given threshold */\n    let meanObj; /* mean of the object pixels at a given threshold */\n    let mean; /* mean gray-level in the image */\n    const tolerance = 0.5; /* threshold tolerance */\n    let temp;\n    /* Calculate the mean gray-level */\n    mean = 0;\n    for (let ih = 0; ih < histogram.length; ih++) {\n        mean += ih * histogram[ih];\n    }\n    mean /= total;\n    /* Initial estimate */\n    newThresh = mean;\n    do {\n        oldThresh = newThresh;\n        threshold = (oldThresh + 0.5) | 0; /* range */\n        /* Calculate the means of background and object pixels */\n        /* Background */\n        sumBack = 0;\n        numBack = 0;\n        for (let ih = 0; ih <= threshold; ih++) {\n            sumBack += ih * histogram[ih];\n            numBack += histogram[ih];\n        }\n        meanBack = numBack === 0 ? 0 : sumBack / numBack;\n        /* Object */\n        sumObj = 0;\n        numObj = 0;\n        for (let ih = threshold + 1; ih < histogram.length; ih++) {\n            sumObj += ih * histogram[ih];\n            numObj += histogram[ih];\n        }\n        meanObj = numObj === 0 ? 0 : sumObj / numObj;\n        temp = (meanBack - meanObj) / (Math.log(meanBack) - Math.log(meanObj));\n        if (temp < -Number.EPSILON) {\n            newThresh = (temp - 0.5) | 0;\n        }\n        else {\n            newThresh = (temp + 0.5) | 0;\n        }\n        /*  Stop the iterations when the difference between the\n             new and old threshold values is less than the tolerance */\n    } while (Math.abs(newThresh - oldThresh) > tolerance);\n    return threshold;\n}\n//# sourceMappingURL=li.js.map","/*\n * see http://rsb.info.nih.gov/ij/developer/source/ij/process/AutoThresholder.java.html\n * The method is present in: Implements Kapur-Sahoo-Wong (Maximum Entropy) thresholding method:\n * Kapur, JN; Sahoo, PK & Wong, ACK (1985), \"A New Method for Gray-Level Picture Thresholding Using the Entropy of the Histogram\",\n * Graphical Models and Image Processing 29(3): 273-285\n * @param histogram - the histogram of the image\n *        total - the number of pixels in the image\n * @returns {number} - the threshold\n */\n/**\n * Return a threshold for a histogram using maximal enthropy algorithm.\n * @param histogram - Image histogram.\n * @param total - Number of pixels in the image.\n * @returns The threshold.\n */\nexport default function maxEntropy(histogram, total) {\n    const normHisto = new Array(histogram.length); // normalized histogram\n    for (let ih = 0; ih < histogram.length; ih++) {\n        normHisto[ih] = histogram[ih] / total;\n    }\n    const P1 = new Array(histogram.length); // cumulative normalized histogram\n    const P2 = new Array(histogram.length);\n    P1[0] = normHisto[0];\n    P2[0] = 1 - P1[0];\n    for (let ih = 1; ih < histogram.length; ih++) {\n        P1[ih] = P1[ih - 1] + normHisto[ih];\n        P2[ih] = 1 - P1[ih];\n    }\n    /* Determine the first non-zero bin */\n    let firstBin = 0;\n    for (let ih = 0; ih < histogram.length; ih++) {\n        if (Math.abs(P1[ih]) >= Number.EPSILON) {\n            firstBin = ih;\n            break;\n        }\n    }\n    /* Determine the last non-zero bin */\n    let lastBin = histogram.length - 1;\n    for (let ih = histogram.length - 1; ih >= firstBin; ih--) {\n        if (Math.abs(P2[ih]) >= Number.EPSILON) {\n            lastBin = ih;\n            break;\n        }\n    }\n    // Calculate the total entropy each gray-level\n    // and find the threshold that maximizes it\n    let threshold = -1;\n    let totEnt; // total entropy\n    let maxEnt = Number.MIN_VALUE; // max entropy\n    let entBack; // entropy of the background pixels at a given threshold\n    let entObj; // entropy of the object pixels at a given threshold\n    for (let it = firstBin; it <= lastBin; it++) {\n        /* Entropy of the background pixels */\n        entBack = 0;\n        for (let ih = 0; ih <= it; ih++) {\n            if (histogram[ih] !== 0) {\n                entBack -= (normHisto[ih] / P1[it]) * Math.log(normHisto[ih] / P1[it]);\n            }\n        }\n        /* Entropy of the object pixels */\n        entObj = 0;\n        for (let ih = it + 1; ih < histogram.length; ih++) {\n            if (histogram[ih] !== 0) {\n                entObj -= (normHisto[ih] / P2[it]) * Math.log(normHisto[ih] / P2[it]);\n            }\n        }\n        /* Total entropy */\n        totEnt = entBack + entObj;\n        if (maxEnt < totEnt) {\n            maxEnt = totEnt;\n            threshold = it;\n        }\n    }\n    return threshold;\n}\n//# sourceMappingURL=maxEntropy.js.map","/*\n * The method is present in: Uses the mean of grey levels as the threshold. It is described in:\n * Glasbey, CA (1993), \"An analysis of histogram-based thresholding algorithms\",\n * CVGIP: Graphical Models and Image Processing 55: 532-537\n * @param histogram - the histogram of the image\n * @param total - the number of pixels in the image\n * @returns {number} - the threshold\n */\n/**\n * Return a threshold for a histogram by making its average.\n * @param histogram - Image histogram.\n * @param total - Number of pixels in the image.\n * @returns The threshold.\n */\nexport default function mean(histogram, total) {\n    let sum = 0;\n    for (let i = 0; i < histogram.length; i++) {\n        sum += i * histogram[i];\n    }\n    return Math.floor(sum / total);\n}\n//# sourceMappingURL=mean.js.map","/*\n * see http://rsb.info.nih.gov/ij/developer/source/ij/process/AutoThresholder.java.html\n * The method is present in: An iterative implementation of Kittler and Illingworth's Minimum Error\n * thresholding:Kittler, J & Illingworth, J (1986), \"Minimum error thresholding\", Pattern Recognition 19: 41-47\n * @param histogram - the histogram of the image\n * @param total - the number of pixels in the image\n * @returns {number} - the threshold\n */\n/**\n * Return a threshold for a histogram using Li algorithm.\n * @param histogram - Image histogram.\n * @param total - Number of pixels in the image.\n * @returns The threshold.\n */\nexport default function minError(histogram, total) {\n    let threshold;\n    let Tprev = -2;\n    let mu, nu, p, q, sigma2, tau2, w0, w1, w2, sqterm, temp;\n    /* Calculate the mean gray-level */\n    let mean = 0;\n    for (let ih = 0; ih < histogram.length; ih++) {\n        mean += ih * histogram[ih];\n    }\n    mean /= total;\n    threshold = mean;\n    while (threshold !== Tprev) {\n        // Calculate some statistics.\n        const sumA1 = sumA(histogram, threshold);\n        const sumA2 = sumA(histogram, histogram.length - 1);\n        const sumB1 = sumB(histogram, threshold);\n        const sumB2 = sumB(histogram, histogram.length - 1);\n        const sumC1 = sumC(histogram, threshold);\n        const sumC2 = sumC(histogram, histogram.length - 1);\n        mu = sumB1 / sumA1;\n        nu = (sumB2 - sumB1) / (sumA2 - sumA1);\n        p = sumA1 / sumA2;\n        q = (sumA2 - sumA1) / sumA2;\n        sigma2 = sumC1 / sumA1 - mu * mu;\n        tau2 = (sumC2 - sumC1) / (sumA2 - sumA1) - nu * nu;\n        // The terms of the quadratic equation to be solved.\n        w0 = 1 / sigma2 - 1 / tau2;\n        w1 = mu / sigma2 - nu / tau2;\n        w2 =\n            (mu * mu) / sigma2 -\n                (nu * nu) / tau2 +\n                Math.log10((sigma2 * (q * q)) / (tau2 * (p * p)));\n        // If the next threshold would be imaginary, return with the current one.\n        sqterm = w1 * w1 - w0 * w2;\n        if (sqterm < 0) {\n            return threshold;\n        }\n        // The updated threshold is the integer part of the solution of the quadratic equation.\n        Tprev = threshold;\n        temp = (w1 + Math.sqrt(sqterm)) / w0;\n        if (Number.isNaN(temp)) {\n            threshold = Tprev;\n        }\n        else {\n            threshold = Math.floor(temp);\n        }\n    }\n    return threshold;\n}\n// aux func\nfunction sumA(y, j) {\n    let x = 0;\n    for (let i = 0; i <= j; i++) {\n        x += y[i];\n    }\n    return x;\n}\nfunction sumB(y, j) {\n    let x = 0;\n    for (let i = 0; i <= j; i++) {\n        x += i * y[i];\n    }\n    return x;\n}\nfunction sumC(y, j) {\n    let x = 0;\n    for (let i = 0; i <= j; i++) {\n        x += i * i * y[i];\n    }\n    return x;\n}\n//# sourceMappingURL=minError.js.map","// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java\n// J. M. S. Prewitt and M. L. Mendelsohn, \"The analysis of cell images,\" in\n// Annals of the New York Academy of Sciences, vol. 128, pp. 1035-1053, 1966.\n// ported to ImageJ plugin by G.Landini from Antti Niemisto's Matlab code (GPL)\n// Original Matlab code Copyright (C) 2004 Antti Niemisto\n// See http://www.cs.tut.fi/~ant/histthresh/ for an excellent slide presentation\n// and the original Matlab code\n/**\n * Return a threshold for a histogram.\n * @param histogram - Image histogram.\n * @returns The threshold.\n */\nexport default function minimum(histogram) {\n    if (histogram.length < 2) {\n        // validate that the histogram has at least two color values\n        return 0;\n    }\n    let iterations = 0; // number of iterations of the smoothing process\n    let threshold = -1;\n    let max = -1; // maximum color value with a greater number of pixels to 0\n    let histogramCopy = new Array(histogram.length); // a copy of the histogram\n    for (let i = 0; i < histogram.length; i++) {\n        histogramCopy[i] = histogram[i];\n        if (histogram[i] > 0) {\n            max = i;\n        }\n    }\n    while (!bimodalTest(histogramCopy)) {\n        histogramCopy = smoothed(histogramCopy);\n        iterations++;\n        if (iterations > 10000) {\n            // if they occur more than 10000 iterations it returns -1\n            return threshold;\n        }\n    }\n    for (let i = 1; i < max; i++) {\n        if (histogramCopy[i - 1] > histogramCopy[i] &&\n            histogramCopy[i + 1] >= histogramCopy[i]) {\n            threshold = i;\n            break;\n        }\n    }\n    return threshold;\n}\nfunction smoothed(histogram) {\n    // Smooth with a 3 point running mean filter\n    const auHistogram = new Array(histogram.length); // a copy of the histogram for the smoothing process\n    for (let i = 1; i < histogram.length - 1; i++) {\n        auHistogram[i] = (histogram[i - 1] + histogram[i] + histogram[i + 1]) / 3;\n    }\n    auHistogram[0] = (histogram[0] + histogram[1]) / 3;\n    auHistogram[histogram.length - 1] =\n        (histogram.at(-2) + histogram.at(-1)) / 3;\n    return auHistogram;\n}\nfunction bimodalTest(histogram) {\n    // It is responsible for determining if a histogram is bimodal\n    const len = histogram.length;\n    let isBimodal = false;\n    let peaks = 0;\n    for (let k = 1; k < len - 1; k++) {\n        if (histogram[k - 1] < histogram[k] && histogram[k + 1] < histogram[k]) {\n            peaks++;\n            if (peaks > 2) {\n                return false;\n            }\n        }\n    }\n    if (peaks === 2) {\n        isBimodal = true;\n    }\n    return isBimodal;\n}\n//# sourceMappingURL=minimum.js.map","// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java\n// W. Tsai, \"Moment-preserving thresholding: a new approach,\" Computer Vision,\n// Graphics, and Image Processing, vol. 29, pp. 377-393, 1985.\n// Ported to ImageJ plugin by G.Landini from the the open source project FOURIER 0.8\n// by M. Emre Celebi , Department of Computer Science, Louisiana State University in Shreveport\n// Shreveport, LA 71115, USA\n// http://sourceforge.net/projects/fourier-ipal\n// http://www.lsus.edu/faculty/~ecelebi/fourier.htm\n/**\n * Return a threshold for a histogram.\n * @param histogram - Image histogram.\n * @param total - Number of pixels in the image.\n * @returns The threshold.\n */\nexport default function moments(histogram, total) {\n    // moments\n    const m0 = 1;\n    let m1 = 0;\n    let m2 = 0;\n    let m3 = 0;\n    let sum = 0;\n    let threshold = -1;\n    const histogramLength = histogram.length;\n    const normalizedHistogram = [];\n    for (let i = 0; i < histogramLength; i++) {\n        normalizedHistogram.push(histogram[i] / total);\n    }\n    /* Calculate the first, second, and third order moments */\n    for (let i = 0; i < histogramLength; i++) {\n        m1 += i * normalizedHistogram[i];\n        m2 += i * i * normalizedHistogram[i];\n        m3 += i * i * i * normalizedHistogram[i];\n    }\n    /*\n       First 4 moments of the gray-level image should match the first 4 moments\n       of the target binary image. This leads to 4 equalities whose solutions\n       are given in the Appendix of Ref. 1\n       */\n    const cd = m0 * m2 - m1 * m1; // determinant of the matriz of hankel for moments 2x2\n    const c0 = (-m2 * m2 + m1 * m3) / cd;\n    const c1 = (m0 * -m3 + m2 * m1) / cd;\n    // new two gray values where z0<z1\n    const z0 = 0.5 * (-c1 - Math.sqrt(c1 * c1 - 4 * c0));\n    const z1 = 0.5 * (-c1 + Math.sqrt(c1 * c1 - 4 * c0));\n    const p0 = (z1 - m1) /\n        (z1 -\n            z0); /* Fraction of the object pixels in the target binary image (p0z0+p1z1=m1) */\n    // The threshold is the gray-level closest to the p0-tile of the normalized histogram\n    for (let i = 0; i < histogramLength; i++) {\n        sum += normalizedHistogram[i];\n        if (sum > p0) {\n            threshold = i;\n            break;\n        }\n    }\n    return threshold;\n}\n//# sourceMappingURL=moments.js.map","/*\n * The method is present in: Otsu, N (1979), \"A threshold selection method from gray-level histograms\", IEEE Trans. Sys., Man., Cyber. 9: 62-66\n * The Otsu implementation is based on: https://en.wikipedia.org/wiki/Otsu's_method\n * @param histogram - the histogram of the image\n * @returns {number} - the threshold\n */\n/**\n * Return a threshold for a histogram using Otsu algorithm.\n * @param histogramCounts - The image histogram.\n * @param total - Total number of pixels of the image.\n * @returns The threshold.\n */\nexport function otsu(histogramCounts, total) {\n    let sumB = 0;\n    let wB = 0;\n    let maximum = 0;\n    let level = 0;\n    let sum1 = 0;\n    for (let i = 0; i < histogramCounts.length; i++) {\n        sum1 += i * histogramCounts[i];\n    }\n    for (let ii = 0; ii < histogramCounts.length; ii++) {\n        wB = wB + histogramCounts[ii];\n        const wF = total - wB;\n        if (wB === 0 || wF === 0) {\n            continue;\n        }\n        sumB = sumB + ii * histogramCounts[ii];\n        const mF = (sum1 - sumB) / wF;\n        const between = wB * wF * (sumB / wB - mF) * (sumB / wB - mF);\n        if (between >= maximum) {\n            level = ii;\n            maximum = between;\n        }\n    }\n    return level;\n}\n//# sourceMappingURL=otsu.js.map","// See http://imagej.nih.gov/ij/download/tools/source/ij/process/AutoThresholder.java\n// W. Doyle, \"Operation useful for similarity-invariant pattern recognition,\"\n// Journal of the Association for Computing Machinery, vol. 9,pp. 259-267, 1962.\n// ported to ImageJ plugin by G.Landini from Antti Niemisto's Matlab code (GPL)\n// Original Matlab code Copyright (C) 2004 Antti Niemisto\n// See http://www.cs.tut.fi/~ant/histthresh/ for an excellent slide presentation\n// and the original Matlab code.\n/**\n * Return a threshold for a histogram using percentiles.\n * @param histogram - Image histogram.\n * @returns The threshold.\n */\nexport default function percentile(histogram) {\n    let threshold = -1;\n    const percentile = 0.5; // default fraction of foreground pixels\n    const avec = new Array(histogram.length);\n    const total = partialSum(histogram, histogram.length - 1);\n    let temp = 1;\n    for (let i = 0; i < histogram.length; i++) {\n        avec[i] = Math.abs(partialSum(histogram, i) / total - percentile);\n        if (avec[i] < temp) {\n            temp = avec[i];\n            threshold = i;\n        }\n    }\n    return threshold;\n}\nfunction partialSum(histogram, endIndex) {\n    let x = 0;\n    for (let i = 0; i <= endIndex; i++) {\n        x += histogram[i];\n    }\n    return x;\n}\n//# sourceMappingURL=percentile.js.map","// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java\n// Kapur J.N., Sahoo P.K., and Wong A.K.C. (1985) \"A New Method for\n// Gray-Level Picture Thresholding Using the Entropy of the Histogram\"\n// Graphical Models and Image Processing, 29(3): 273-285\n// M. Emre Celebi\n// 06.15.2007\n// Ported to ImageJ plugin by G.Landini from E Celebi's fourier_0.8 routines\n/**\n * Return a threshold for a histogram using its entropy.\n * @param histogram - The image histogram.\n * @param total - Total number of pixels of the image.\n * @returns The threshold.\n */\nexport default function renyiEntropy(histogram, total) {\n    let firstBin; // First non-zero bin\n    let lastBin; // last non-zero bin\n    const normHisto = new Array(histogram.length); // normalized histogram\n    const P1 = new Array(histogram.length); // accumulative normalized histogram\n    const P2 = new Array(histogram.length); // accumulative normalized histogram\n    // Entropy Variables\n    let threshold1 = 0;\n    let threshold2 = 0;\n    let threshold3 = 0;\n    let maxEnt1 = 0;\n    let maxEnt2 = 0;\n    let maxEnt3 = 0;\n    const alpha2 = 0.5;\n    const term2 = 1 / (1 - alpha2);\n    const alpha3 = 2;\n    const term3 = 1 / (1 - alpha3);\n    for (let ih = 0; ih < histogram.length; ih++) {\n        normHisto[ih] = histogram[ih] / total;\n    }\n    P1[0] = normHisto[0];\n    P2[0] = 1 - P1[0];\n    for (let ih = 1; ih < histogram.length; ih++) {\n        P1[ih] = P1[ih - 1] + normHisto[ih];\n        P2[ih] = 1 - P1[ih];\n    }\n    /* Determine the first non-zero bin */\n    firstBin = 0;\n    for (let ih = 0; ih < histogram.length; ih++) {\n        if (Math.abs(P1[ih]) >= Number.EPSILON) {\n            firstBin = ih;\n            break;\n        }\n    }\n    /* Determine the last non-zero bin */\n    lastBin = histogram.length - 1;\n    for (let ih = histogram.length - 1; ih >= firstBin; ih--) {\n        if (Math.abs(P2[ih]) >= Number.EPSILON) {\n            lastBin = ih;\n            break;\n        }\n    }\n    /* Maximum Entropy Thresholding - BEGIN */\n    /* ALPHA = 1.0 */\n    /* Calculate the total entropy each gray-level\n       and find the threshold that maximizes it\n       */\n    for (let it = firstBin; it <= lastBin; it++) {\n        /* Entropy of the background pixels */\n        let entBack1 = 0;\n        let entBack2 = 0;\n        let entBack3 = 0;\n        for (let ih = 0; ih <= it; ih++) {\n            if (histogram[ih] !== 0) {\n                entBack1 -= (normHisto[ih] / P1[it]) * Math.log(normHisto[ih] / P1[it]);\n            }\n            entBack2 += Math.sqrt(normHisto[ih] / P1[it]);\n            entBack3 += (normHisto[ih] * normHisto[ih]) / (P1[it] * P1[it]);\n        }\n        /* Entropy of the object pixels */\n        let entObj1 = 0;\n        let entObj2 = 0;\n        let entObj3 = 0;\n        for (let ih = it + 1; ih < histogram.length; ih++) {\n            if (histogram[ih] !== 0) {\n                entObj1 -= (normHisto[ih] / P2[it]) * Math.log(normHisto[ih] / P2[it]);\n            }\n            entObj2 += Math.sqrt(normHisto[ih] / P2[it]);\n            entObj3 += (normHisto[ih] * normHisto[ih]) / (P2[it] * P2[it]);\n        }\n        /* Total entropy */\n        const totEnt1 = entBack1 + entObj1;\n        const totEnt2 = term2 * (entBack2 * entObj2 > 0 ? Math.log(entBack2 * entObj2) : 0);\n        const totEnt3 = term3 * (entBack3 * entObj3 > 0 ? Math.log(entBack3 * entObj3) : 0);\n        if (totEnt1 > maxEnt1) {\n            maxEnt1 = totEnt1;\n            threshold1 = it;\n        }\n        if (totEnt2 > maxEnt2) {\n            maxEnt2 = totEnt2;\n            threshold2 = it;\n        }\n        if (totEnt3 > maxEnt3) {\n            maxEnt3 = totEnt3;\n            threshold3 = it;\n        }\n    }\n    /* End Maximum Entropy Thresholding */\n    const tStars = new Uint32Array([threshold1, threshold2, threshold3]);\n    tStars.sort();\n    let betas;\n    /* Adjust beta values */\n    if (Math.abs(tStars[0] - tStars[1]) <= 5) {\n        if (Math.abs(tStars[1] - tStars[2]) <= 5) {\n            betas = [1, 2, 1];\n        }\n        else {\n            betas = [0, 1, 3];\n        }\n    }\n    else if (Math.abs(tStars[1] - tStars[2]) <= 5) {\n        betas = [3, 1, 0];\n    }\n    else {\n        betas = [1, 2, 1];\n    }\n    /* Determine the optimal threshold value */\n    const omega = P1[tStars[2]] - P1[tStars[0]];\n    const optThreshold = Math.round(tStars[0] * (P1[tStars[0]] + 0.25 * omega * betas[0]) +\n        0.25 * tStars[1] * omega * betas[1] +\n        tStars[2] * (P2[tStars[2]] + 0.25 * omega * betas[2]));\n    return optThreshold;\n}\n//# sourceMappingURL=renyiEntropy.js.map","// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java\n// Shanhbag A.G. (1994) \"Utilization of Information Measure as a Means of\n// Image Thresholding\" Graphical Models and Image Processing, 56(5): 414-419\n// Ported to ImageJ plugin by G.Landini from E Celebi's fourier_0.8 routines\n/**\n * Return a threshold for a histogram using Shanbhag algorithm.\n * @param histogram - The image histogram.\n * @param total - Total number of pixels of the image.\n * @returns The threshold.\n */\nexport default function shanbhag(histogram, total) {\n    const normHisto = new Array(histogram.length); // normalized histogram\n    for (let ih = 0; ih < histogram.length; ih++) {\n        normHisto[ih] = histogram[ih] / total;\n    }\n    const P1 = new Array(histogram.length); // cumulative normalized histogram\n    const P2 = new Array(histogram.length);\n    P1[0] = normHisto[0];\n    P2[0] = 1 - P1[0];\n    for (let ih = 1; ih < histogram.length; ih++) {\n        P1[ih] = P1[ih - 1] + normHisto[ih];\n        P2[ih] = 1 - P1[ih];\n    }\n    /* Determine the first non-zero bin */\n    let firstBin = 0;\n    for (let ih = 0; ih < histogram.length; ih++) {\n        if (Math.abs(P1[ih]) >= Number.EPSILON) {\n            firstBin = ih;\n            break;\n        }\n    }\n    /* Determine the last non-zero bin */\n    let lastBin = histogram.length - 1;\n    for (let ih = histogram.length - 1; ih >= firstBin; ih--) {\n        if (Math.abs(P2[ih]) >= Number.EPSILON) {\n            lastBin = ih;\n            break;\n        }\n    }\n    // Calculate the total entropy each gray-level\n    // and find the threshold that maximizes it\n    let threshold = -1;\n    let minEnt = Number.MAX_VALUE; // min entropy\n    let term;\n    let totEnt; // total entropy\n    let entBack; // entropy of the background pixels at a given threshold\n    let entObj; // entropy of the object pixels at a given threshold\n    for (let it = firstBin; it <= lastBin; it++) {\n        /* Entropy of the background pixels */\n        entBack = 0;\n        term = 0.5 / P1[it];\n        for (let ih = 1; ih <= it; ih++) {\n            entBack -= normHisto[ih] * Math.log(1 - term * P1[ih - 1]);\n        }\n        entBack *= term;\n        /* Entropy of the object pixels */\n        entObj = 0;\n        term = 0.5 / P2[it];\n        for (let ih = it + 1; ih < histogram.length; ih++) {\n            entObj -= normHisto[ih] * Math.log(1 - term * P2[ih]);\n        }\n        entObj *= term;\n        /* Total entropy */\n        totEnt = Math.abs(entBack - entObj);\n        if (totEnt < minEnt) {\n            minEnt = totEnt;\n            threshold = it;\n        }\n    }\n    return threshold;\n}\n//# sourceMappingURL=shanbhag.js.map","// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java\n// Zack, G. W., Rogers, W. E. and Latt, S. A., 1977,\n// Automatic Measurement of Sister Chromatid Exchange Frequency,\n// Journal of Histochemistry and Cytochemistry 25 (7), pp. 741-753\n//\n//  modified from Johannes Schindelin plugin\n/**\n * Return a threshold for a histogram using Triangle algorithm.\n * @param histogram - The image histogram.\n * @returns The threshold.\n */\nexport function triangle(histogram) {\n    // find min and max\n    let min = 0;\n    let dmax = 0;\n    let max = 0;\n    let min2 = 0;\n    for (let i = 0; i < histogram.length; i++) {\n        if (histogram[i] > 0) {\n            min = i;\n            break;\n        }\n    }\n    if (min > 0) {\n        // line to the (p==0) point, not to histogram[min]\n        min--;\n    }\n    // The Triangle algorithm cannot tell whether the data is skewed to one side or another.\n    // This causes a problem as there are 2 possible thresholds between the max and the 2 extremes\n    // of the histogram.\n    // Here I propose to find out to which side of the max point the data is furthest, and use that as\n    //  the other extreme.\n    for (let i = histogram.length - 1; i > 0; i--) {\n        if (histogram[i] > 0) {\n            min2 = i;\n            break;\n        }\n    }\n    if (min2 < histogram.length - 1) {\n        // line to the (p==0) point, not to data[min]\n        min2++;\n    }\n    for (let i = 0; i < histogram.length; i++) {\n        if (histogram[i] > dmax) {\n            max = i;\n            dmax = histogram[i];\n        }\n    }\n    // find which is the furthest side\n    let inverted = false;\n    if (max - min < min2 - max) {\n        // reverse the histogram\n        inverted = true;\n        let left = 0; // index of leftmost element\n        let right = histogram.length - 1; // index of rightmost element\n        while (left < right) {\n            // exchange the left and right elements\n            const temp = histogram[left];\n            histogram[left] = histogram[right];\n            histogram[right] = temp;\n            // move the bounds toward the center\n            left++;\n            right--;\n        }\n        min = histogram.length - 1 - min2;\n        max = histogram.length - 1 - max;\n    }\n    if (min === max) {\n        return min;\n    }\n    // describe line by nx * x + ny * y - d = 0\n    let nx, ny, d;\n    // nx is just the max frequency as the other point has freq=0\n    nx = histogram[max]; // -min; // data[min]; //  lowest value bmin = (p=0)% in the image\n    ny = min - max;\n    d = Math.hypot(nx, ny);\n    nx /= d;\n    ny /= d;\n    d = nx * min + ny * histogram[min];\n    // find split point\n    let split = min;\n    let splitDistance = 0;\n    for (let i = min + 1; i <= max; i++) {\n        const newDistance = nx * i + ny * histogram[i] - d;\n        if (newDistance > splitDistance) {\n            split = i;\n            splitDistance = newDistance;\n        }\n    }\n    split--;\n    if (inverted) {\n        // The histogram might be used for something else, so let's reverse it back\n        let left = 0;\n        let right = histogram.length - 1;\n        while (left < right) {\n            const temp = histogram[left];\n            histogram[left] = histogram[right];\n            histogram[right] = temp;\n            left++;\n            right--;\n        }\n        return histogram.length - 1 - split;\n    }\n    else {\n        return split;\n    }\n}\n//# sourceMappingURL=triangle.js.map","// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java\n// Implements Yen  thresholding method\n// 1) Yen J.C., Chang F.J., and Chang S. (1995) \"A New Criterion\n//    for Automatic Multilevel Thresholding\" IEEE Trans. on Image\n//    Processing, 4(3): 370-378\n// 2) Sezgin M. and Sankur B. (2004) \"Survey over Image Thresholding\n//    Techniques and Quantitative Performance Evaluation\" Journal of\n//    Electronic Imaging, 13(1): 146-165\n//    http://citeseer.ist.psu.edu/sezgin04survey.html\n//\n// M. Emre Celebi\n// 06.15.2007\n// Ported to ImageJ plugin by G.Landini from E Celebi's fourier_0.8 routines\n/**\n * Return a threshold for a histogram using Yen algorithm.\n * @param histogram - The image histogram.\n * @param total - Total number of pixels of the image.\n * @returns The threshold.\n */\nexport default function yen(histogram, total) {\n    const normHisto = new Array(histogram.length); // normalized histogram\n    for (let ih = 0; ih < histogram.length; ih++) {\n        normHisto[ih] = histogram[ih] / total;\n    }\n    const P1 = new Array(histogram.length); // cumulative normalized histogram\n    P1[0] = normHisto[0];\n    for (let ih = 1; ih < histogram.length; ih++) {\n        P1[ih] = P1[ih - 1] + normHisto[ih];\n    }\n    const P1Sq = new Array(histogram.length);\n    P1Sq[0] = normHisto[0] * normHisto[0];\n    for (let ih = 1; ih < histogram.length; ih++) {\n        P1Sq[ih] = P1Sq[ih - 1] + normHisto[ih] * normHisto[ih];\n    }\n    const P2Sq = new Array(histogram.length);\n    P2Sq[histogram.length - 1] = 0;\n    for (let ih = histogram.length - 2; ih >= 0; ih--) {\n        P2Sq[ih] = P2Sq[ih + 1] + normHisto[ih + 1] * normHisto[ih + 1];\n    }\n    /* Find the threshold that maximizes the criterion */\n    let threshold = -1;\n    let maxCrit = Number.MIN_VALUE;\n    let crit;\n    for (let it = 0; it < histogram.length; it++) {\n        crit =\n            -1 * (P1Sq[it] * P2Sq[it] > 0 ? Math.log(P1Sq[it] * P2Sq[it]) : 0) +\n                2 * (P1[it] * (1 - P1[it]) > 0 ? Math.log(P1[it] * (1 - P1[it])) : 0);\n        if (crit > maxCrit) {\n            maxCrit = crit;\n            threshold = it;\n        }\n    }\n    return threshold;\n}\n//# sourceMappingURL=yen.js.map","import { match } from 'ts-pattern';\nimport { imageToOutputMask } from '../utils/getOutputImage.js';\nimport huang from './thresholds/huang.js';\nimport intermodes from './thresholds/intermodes.js';\nimport isodata from './thresholds/isodata.js';\nimport li from './thresholds/li.js';\nimport maxEntropy from './thresholds/maxEntropy.js';\nimport mean from './thresholds/mean.js';\nimport minError from './thresholds/minError.js';\nimport minimum from './thresholds/minimum.js';\nimport moments from './thresholds/moments.js';\nimport { otsu } from './thresholds/otsu.js';\nimport percentile from './thresholds/percentile.js';\nimport renyiEntropy from './thresholds/renyiEntropy.js';\nimport shanbhag from './thresholds/shanbhag.js';\nimport { triangle } from './thresholds/triangle.js';\nimport yen from './thresholds/yen.js';\nexport const ThresholdAlgorithm = {\n    HUANG: 'huang',\n    INTERMODES: 'intermodes',\n    ISODATA: 'isodata',\n    LI: 'li',\n    MAX_ENTROPY: 'maxEntropy',\n    MEAN: 'mean',\n    MIN_ERROR: 'minError',\n    MINIMUM: 'minimum',\n    MOMENTS: 'moments',\n    OTSU: 'otsu',\n    PERCENTILE: 'percentile',\n    RENYI_ENTROPY: 'renyiEntropy',\n    SHANBHAG: 'shanbhag',\n    TRIANGLE: 'triangle',\n    YEN: 'yen',\n};\n/**\n * Compute threshold value for an image using the specified algorithm.\n * @param image - The grey image.\n * @param options - Threshold options.\n * @returns The threshold value for the image.\n */\nexport function computeThreshold(image, options = {}) {\n    const { algorithm = 'otsu', slots } = options;\n    if (image.channels !== 1) {\n        throw new TypeError('threshold can only be computed on images with one channel');\n    }\n    const histogram = image.histogram({ slots });\n    const scale = slots ? 2 ** image.bitDepth / slots : 1;\n    return match(algorithm)\n        .with('huang', () => huang(histogram) * scale)\n        .with('intermodes', () => intermodes(histogram) * scale)\n        .with('isodata', () => isodata(histogram) * scale)\n        .with('li', () => li(histogram, image.size) * scale)\n        .with('maxEntropy', () => maxEntropy(histogram, image.size) * scale)\n        .with('mean', () => mean(histogram, image.size) * scale)\n        .with('minimum', () => minimum(histogram) * scale)\n        .with('minError', () => minError(histogram, image.size) * scale)\n        .with('moments', () => moments(histogram, image.size) * scale)\n        .with('otsu', () => otsu(histogram, image.size) * scale)\n        .with('percentile', () => percentile(histogram) * scale)\n        .with('renyiEntropy', () => renyiEntropy(histogram, image.size) * scale)\n        .with('shanbhag', () => shanbhag(histogram, image.size) * scale)\n        .with('triangle', () => triangle(histogram) * scale)\n        .with('yen', () => yen(histogram, image.size) * scale)\n        .exhaustive();\n}\n// See: https://docs.opencv.org/4.0.1/d7/d1b/group__imgproc__misc.html#gaa9e58d2860d4afa658ef70a9b1115576\n/**\n * Create a black and white image based on a threshold value.\n * @param image - The grey image to convert.\n * @param options - Threshold options.\n * @returns The resulting mask.\n */\nexport function threshold(image, options = {}) {\n    let thresholdValue;\n    if ('threshold' in options) {\n        const threshold = options.threshold;\n        if (threshold < 0 || threshold > 1) {\n            throw new RangeError('threshold must be a value between 0 and 1');\n        }\n        thresholdValue = threshold * image.maxValue;\n    }\n    else {\n        thresholdValue = computeThreshold(image, options);\n    }\n    const result = imageToOutputMask(image, options);\n    for (let i = 0; i < image.size; i++) {\n        result.setBitByIndex(i, image.getValueByIndex(i, 0) > thresholdValue ? 1 : 0);\n    }\n    return result;\n}\n//# sourceMappingURL=threshold.js.map","import { assert } from '../utils/validators/assert.js';\n/**\n * Converts R, G and B values to a single value using Luma 709 standard({@link https://en.wikipedia.org/wiki/Luma_(video)}).\n * @param red - Red value of current pixel.\n * @param green - Green value of current pixel.\n * @param blue - Blue value of current pixel.\n * @returns - Corresponding gray value.\n */\nexport function luma709(red, green, blue) {\n    // sRGB\n    // return red * 0.2126 + green * 0.7152 + blue * 0.0722;\n    // Let's do a little trick ... in order not convert the integer to a double we do\n    // the multiplication with integer to reach a total of 32768 and then shift the bits\n    // of 15 to the right\n    // This does a Math.floor and may lead to small (max 1) difference\n    // Same result, > 10% faster on the full grey conversion\n    return (red * 6966 + green * 23436 + blue * 2366) >> 15;\n}\n/**\n *  Converts R, G and B values to a single value using Luma 601 standard({@link https://en.wikipedia.org/wiki/Luma_(video)}).\n * @param red - Red value of current pixel.\n * @param green - Green value of current pixel.\n * @param blue - Blue value of current pixel.\n * @returns - Corresponding gray value.\n */\nexport function luma601(red, green, blue) {\n    // NTSC\n    // return this.red * 0.299 + green * 0.587 + blue * 0.114;\n    return (red * 9798 + green * 19235 + blue * 3735) >> 15;\n}\n/**\n * Return the maximal value between red, green and blue.\n * @param red - Red value of current pixel.\n * @param green - Green value of current pixel.\n * @param blue - Blue value of current pixel.\n * @returns - Corresponding gray value.\n */\nexport function max(red, green, blue) {\n    return Math.max(red, green, blue);\n}\n/**\n * Return the minimal value between red, green and blue.\n * @param red - Red value of current pixel.\n * @param green - Green value of current pixel.\n * @param blue - Blue value of current pixel.\n * @returns - Corresponding gray value.\n */\nexport function min(red, green, blue) {\n    return Math.min(red, green, blue);\n}\n/**\n * Return the average of red, green and blue.\n * @param red - Red value of current pixel.\n * @param green - Green value of current pixel.\n * @param blue - Blue value of current pixel.\n * @returns - Corresponding gray value.\n */\nexport function average(red, green, blue) {\n    return ((red + green + blue) / 3) >> 0;\n}\n/**\n * Return the average between the max and min values of red, green and blue.\n * @param red - Red value of current pixel.\n * @param green - Green value of current pixel.\n * @param blue - Blue value of current pixel.\n * @returns - Corresponding gray value.\n */\nexport function minmax(red, green, blue) {\n    return (Math.max(red, green, blue) + Math.min(red, green, blue)) / 2;\n}\n/**\n * Return the red value.\n * @param red - Red value of current pixel.\n * @returns - Corresponding gray value.\n */\nexport function red(red) {\n    return red;\n}\n/**\n * Return the green value.\n * @param red - Red value of current pixel.\n * @param green - Green value of current pixel.\n * @returns - Corresponding gray value.\n */\nexport function green(red, green) {\n    return green;\n}\n/**\n * Return the blue value.\n * @param red - Red value of current pixel.\n * @param green - Green value of current pixel.\n * @param blue - Blue value of current pixel.\n * @returns - Corresponding gray value.\n */\nexport function blue(red, green, blue) {\n    return blue;\n}\n/**\n * Return the minimum of the inverses of red, green and blue.\n * @param red - Red value of current pixel.\n * @param green - Green value of current pixel.\n * @param blue - Blue value of current pixel.\n * @param image - Image to convert to grey.\n * @returns - Corresponding gray value.\n */\nexport function black(red, green, blue, image) {\n    return Math.min(image.maxValue - red, image.maxValue - green, image.maxValue - blue);\n}\n/**\n * Returns the cyan component of a pixel.\n * @param red - Red value of current pixel.\n * @param green - Green value of current pixel.\n * @param blue - Blue value of current pixel.\n * @param image - Image to convert to grey.\n * @returns - Corresponding gray value.\n */\nexport function cyan(red, green, blue, image) {\n    const blackColor = black(red, green, blue, image);\n    return (((image.maxValue - red - blackColor) / (1 - blackColor / image.maxValue)) >>\n        0);\n}\n/**\n * Returns the magenta component of a pixel.\n * @param red - Red value of current pixel.\n * @param green - Green value of current pixel.\n * @param blue - Blue value of current pixel.\n * @param image - Image to convert to grey.\n * @returns - Corresponding gray value.\n */\nexport function magenta(red, green, blue, image) {\n    const blackColor = black(red, green, blue, image);\n    return (((image.maxValue - green - blackColor) /\n        (1 - blackColor / image.maxValue)) >>\n        0);\n}\n/**\n * Returns the yellow component of a pixel.\n * @param red - Red value of current pixel.\n * @param green - Green value of current pixel.\n * @param blue - Blue value of current pixel.\n * @param image - Image to convert to grey.\n * @returns - Corresponding gray value.\n */\nexport function yellow(red, green, blue, image) {\n    const blackColor = black(red, green, blue, image);\n    return (((image.maxValue - blue - blackColor) /\n        (1 - blackColor / image.maxValue)) >>\n        0);\n}\n/**\n * Returns the hue of a pixel as a value between 0 and 255.\n * @param red - Red value of current pixel.\n * @param green - Green value of current pixel.\n * @param blue - Blue value of current pixel.\n * @param image - Source image for the RGB values.\n * @returns - Hue of the pixel.\n */\nexport function hue(red, green, blue, image) {\n    const minValue = min(red, green, blue);\n    const maxValue = max(red, green, blue);\n    if (maxValue === minValue) {\n        return 0;\n    }\n    let hue = 0;\n    const delta = maxValue - minValue;\n    if (maxValue === red) {\n        hue = (green - blue) / delta + (green < blue ? 6 : 0);\n    }\n    else if (maxValue === green) {\n        hue = (blue - red) / delta + 2;\n    }\n    else {\n        assert(maxValue === blue);\n        hue = (red - green) / delta + 4;\n    }\n    return ((hue / 6) * image.maxValue) >> 0;\n}\n/**\n * Returns the saturation component of a pixel.\n * @param red - Red value of current pixel.\n * @param green - Green value of current pixel.\n * @param blue - Blue value of current pixel.\n * @param image - Source image for the RGB values.\n * @returns - Saturation of the pixel.\n */\nexport function saturation(red, green, blue, image) {\n    // from HSV model\n    const minValue = min(red, green, blue);\n    const maxValue = max(red, green, blue);\n    const delta = maxValue - minValue;\n    return maxValue === 0 ? 0 : (delta / maxValue) * image.maxValue;\n}\n/**\n * Returns the lightness of a pixel.\n * @param red - Red value of current pixel.\n * @param green - Green value of current pixel.\n * @param blue - Blue value of current pixel.\n * @returns - Lightness of the pixel.\n */\nexport function lightness(red, green, blue) {\n    const minValue = min(red, green, blue);\n    const maxValue = max(red, green, blue);\n    return (maxValue + minValue) / 2;\n}\n//# sourceMappingURL=greyAlgorithms.js.map","import { getClamp } from '../utils/clamp.js';\nimport { getOutputImage } from '../utils/getOutputImage.js';\nimport { assert } from '../utils/validators/assert.js';\nimport checkProcessable from '../utils/validators/checkProcessable.js';\nimport * as greyAlgorithms from './greyAlgorithms.js';\nexport const GreyAlgorithm = {\n    LUMA_709: 'luma709',\n    LUMA_601: 'luma601',\n    MAX: 'max',\n    MIN: 'min',\n    AVERAGE: 'average',\n    MINMAX: 'minmax',\n    RED: 'red',\n    GREEN: 'green',\n    BLUE: 'blue',\n    BLACK: 'black',\n    CYAN: 'cyan',\n    MAGENTA: 'magenta',\n    YELLOW: 'yellow',\n    HUE: 'hue',\n    SATURATION: 'saturation',\n    LIGHTNESS: 'lightness',\n};\n{\n    // Check that all the algorithms are in the enum.\n    const algos = new Set(Object.values(GreyAlgorithm));\n    for (const algo of Object.keys(greyAlgorithms)) {\n        assert(algos.has(algo), `Grey algorithm ${algo} is missing in the GreyAlgorithm enum`);\n    }\n}\n/**\n * Convert the current image to grayscale.\n * The source image has to be RGB or RGBA.\n * If there is an alpha channel you have to specify what to do:\n * - keepAlpha :  keep the alpha channel, you will get a GREYA image.\n * - mergeAlpha : multiply each pixel of the image by the alpha, you will get a GREY image.\n * @param image - Original color image to convert to grey.\n * @param options - The grey conversion options.\n * @returns The resulting grey image.\n */\nexport function grey(image, options = {}) {\n    let { keepAlpha = false, mergeAlpha = true } = options;\n    const { algorithm = 'luma709' } = options;\n    checkProcessable(image, {\n        colorModel: ['RGB', 'RGBA'],\n    });\n    keepAlpha = keepAlpha && image.alpha;\n    mergeAlpha = mergeAlpha && image.alpha;\n    if (keepAlpha) {\n        mergeAlpha = false;\n    }\n    const newColorModel = keepAlpha ? 'GREYA' : 'GREY';\n    const newImage = getOutputImage(image, options, {\n        newParameters: { colorModel: newColorModel },\n    });\n    let method;\n    if (typeof algorithm === 'function') {\n        method = algorithm;\n    }\n    else {\n        method = greyAlgorithms[algorithm];\n    }\n    const clamp = getClamp(newImage);\n    for (let i = 0; i < image.size; i++) {\n        const red = image.getValueByIndex(i, 0);\n        const green = image.getValueByIndex(i, 1);\n        const blue = image.getValueByIndex(i, 2);\n        let newValue;\n        if (mergeAlpha) {\n            const alpha = image.getValueByIndex(i, 3);\n            newValue = clamp((method(red, green, blue, image) * alpha) / image.maxValue);\n        }\n        else {\n            newValue = clamp(method(red, green, blue, image));\n            if (keepAlpha) {\n                const alpha = image.getValueByIndex(i, 3);\n                newImage.setValueByIndex(i, 1, alpha);\n            }\n        }\n        newImage.setValueByIndex(i, 0, newValue);\n    }\n    return newImage;\n}\n//# sourceMappingURL=grey.js.map","import { Image } from '../Image.js';\nimport { getOutputImage, maskToOutputMask } from '../utils/getOutputImage.js';\nimport { setBlendedPixel } from '../utils/setBlendedPixel.js';\nimport { checkPointIsInteger } from '../utils/validators/checkPointIsInteger.js';\n/**\n * Copy the image to another one by specifying the location in the target image.\n * If the source image exceeds the boundaries of the target image, the excess pixels\n * are ignored. The result image will have the same dimensions as the target image.\n * @param source - The source image.\n * @param target - The target image.\n * @param options - Options.\n * @returns The target with the source copied to it.\n */\nexport function copyTo(source, target, options = {}) {\n    const { origin = { column: 0, row: 0 } } = options;\n    const { column, row } = origin;\n    if (source.colorModel !== target.colorModel) {\n        throw new RangeError('source and target must have the same color model');\n    }\n    checkPointIsInteger(origin, 'Origin');\n    let result;\n    if (target instanceof Image) {\n        result = getOutputImage(target, options, { clone: true });\n    }\n    else {\n        result = maskToOutputMask(target, options, { clone: true });\n    }\n    for (let currentRow = Math.max(row, 0); currentRow < Math.min(source.height + row, target.height); currentRow++) {\n        for (let currentColumn = Math.max(column, 0); currentColumn < Math.min(source.width + column, target.width); currentColumn++) {\n            const sourcePixel = source.getPixel(currentColumn - column, currentRow - row);\n            setBlendedPixel(result, currentColumn, currentRow, sourcePixel);\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=copyTo.js.map","import { Image } from '../Image.js';\nimport { checkPointIsInteger } from '../utils/validators/checkPointIsInteger.js';\nimport checkProcessable from '../utils/validators/checkProcessable.js';\n/**\n * Crop the input image to a desired size.\n * @param image - Image to crop.\n * @param [options] - Crop options.\n * @returns The new cropped image.\n * @example\n * var cropped = image.crop({\n *   row:20,\n *   column:100\n * });\n */\nexport function crop(image, options = {}) {\n    const { origin = { row: 0, column: 0 }, width = image.width - origin.column, height = image.height - origin.row, } = options;\n    const { column, row } = origin;\n    checkProcessable(image, {\n        bitDepth: [8, 16],\n    });\n    checkPointIsInteger(origin, 'Origin');\n    if (!Number.isInteger(width) || !Number.isInteger(height)) {\n        throw new RangeError(`Width and height (width:${width}; height:${height}) must be integers`);\n    }\n    if (row > image.height - 1 || column > image.width - 1) {\n        throw new RangeError(`Origin (row:${row}, column:${column}) out of range (${image.width - 1}; ${image.height - 1})`);\n    }\n    if (width <= 0 || height <= 0) {\n        throw new RangeError(`Width and height (width:${width}; height:${height}) must be positive numbers`);\n    }\n    if (row < 0 || column < 0) {\n        throw new RangeError(`Row and column (row:${row}, column:${column}) must be positive numbers`);\n    }\n    if (width > image.width - column || height > image.height - row) {\n        throw new RangeError(`Size is out of range (row:${row}, column:${column}, width:${width}, height:${height})`);\n    }\n    const newImage = Image.createFrom(image, {\n        width,\n        height,\n    });\n    for (let currentRow = 0; currentRow < height; currentRow++) {\n        for (let currentColumn = 0; currentColumn < width; currentColumn++) {\n            newImage.setPixel(currentColumn, currentRow, image.getPixel(column + currentColumn, row + currentRow));\n        }\n    }\n    return newImage;\n}\n//# sourceMappingURL=crop.js.map","import checkProcessable from '../utils/validators/checkProcessable.js';\n/**\n * Crops the image based on the alpha channel\n * This removes lines and columns where the alpha channel is lower than a threshold value.\n * @param image - Image to process.\n * @param options - Crop alpha options.\n * @returns The cropped image.\n */\nexport function cropAlpha(image, options = {}) {\n    checkProcessable(image, {\n        alpha: true,\n    });\n    const { threshold = image.maxValue } = options;\n    const left = findLeft(image, threshold, image.components);\n    if (left === -1) {\n        throw new RangeError(`could not find new dimensions. Threshold may be too high: ${threshold}`);\n    }\n    const top = findTop(image, threshold, image.components, left);\n    const bottom = findBottom(image, threshold, image.components, left);\n    const right = findRight(image, threshold, image.components, left, top, bottom);\n    return image.crop({\n        origin: { column: left, row: top },\n        width: right - left + 1,\n        height: bottom - top + 1,\n    });\n}\nfunction findLeft(image, threshold, channel) {\n    for (let row = 0; row < image.width; row++) {\n        for (let column = 0; column < image.height; column++) {\n            if (image.getValue(row, column, channel) >= threshold) {\n                return row;\n            }\n        }\n    }\n    return -1;\n}\nfunction findTop(image, threshold, channel, left) {\n    for (let row = 0; row < image.height; row++) {\n        for (let column = left; column < image.width; column++) {\n            if (image.getValue(column, row, channel) >= threshold) {\n                return row;\n            }\n        }\n    }\n    /* istanbul ignore next */\n    return -1;\n}\nfunction findBottom(image, threshold, channel, left) {\n    for (let row = image.height - 1; row >= 0; row--) {\n        for (let column = left; column < image.width; column++) {\n            if (image.getValue(column, row, channel) >= threshold) {\n                return row;\n            }\n        }\n    }\n    /* istanbul ignore next */\n    return -1;\n}\nfunction findRight(image, threshold, channel, left, top, bottom) {\n    for (let row = image.width - 1; row >= left; row--) {\n        for (let column = top; column <= bottom; column++) {\n            if (image.getValue(row, column, channel) >= threshold) {\n                return row;\n            }\n        }\n    }\n    /* istanbul ignore next */\n    return -1;\n}\n//# sourceMappingURL=cropAlpha.js.map","import { match } from 'ts-pattern';\nimport { round } from './round.js';\nexport const InterpolationType = {\n    NEAREST: 'nearest',\n    BILINEAR: 'bilinear',\n    BICUBIC: 'bicubic',\n};\n/**\n * Get the interpolation function based on its name.\n * @param interpolationType - Specified interpolation type.\n * @returns The interpolation function.\n */\nexport function getInterpolationFunction(interpolationType) {\n    return match(interpolationType)\n        .with('nearest', () => interpolateNearest)\n        .with('bilinear', () => interpolateBilinear)\n        .with('bicubic', () => interpolateBicubic)\n        .exhaustive();\n}\n/**\n * Interpolate using nearest neighbor.\n * @param image - The image to interpolate.\n * @param column - Column index.\n * @param row - Row index.\n * @param channel - Channel index.\n * @param interpolateBorder - Border interpolation function.\n * @returns The interpolated value.\n */\nfunction interpolateNearest(image, column, row, channel, interpolateBorder) {\n    column = Math.round(column);\n    row = Math.round(row);\n    return interpolateBorder(column, row, channel, image);\n}\n/**\n * Interpolate using bilinear interpolation.\n * @param image - The image to interpolate.\n * @param column - Column index.\n * @param row - Row index.\n * @param channel - Channel index.\n * @param interpolateBorder - Border interpolation function.\n * @returns The interpolated value.\n */\nfunction interpolateBilinear(image, column, row, channel, interpolateBorder) {\n    const px0 = Math.floor(column);\n    const py0 = Math.floor(row);\n    const px1 = px0 + 1;\n    const py1 = py0 + 1;\n    if (px1 < image.width && py1 < image.height && px0 >= 0 && py0 >= 0) {\n        const vx0y0 = image.getValue(px0, py0, channel);\n        const vx1y0 = image.getValue(px1, py0, channel);\n        const vx0y1 = image.getValue(px0, py1, channel);\n        const vx1y1 = image.getValue(px1, py1, channel);\n        const r1 = (px1 - column) * vx0y0 + (column - px0) * vx1y0;\n        const r2 = (px1 - column) * vx0y1 + (column - px0) * vx1y1;\n        return round((py1 - row) * r1 + (row - py0) * r2);\n    }\n    else {\n        const vx0y0 = interpolateBorder(px0, py0, channel, image);\n        const vx1y0 = interpolateBorder(px1, py0, channel, image);\n        const vx0y1 = interpolateBorder(px0, py1, channel, image);\n        const vx1y1 = interpolateBorder(px1, py1, channel, image);\n        const r1 = (px1 - column) * vx0y0 + (column - px0) * vx1y0;\n        const r2 = (px1 - column) * vx0y1 + (column - px0) * vx1y1;\n        return round((py1 - row) * r1 + (row - py0) * r2);\n    }\n}\n/**\n * Interpolate using bicubic interpolation.\n * @param image - The image to interpolate.\n * @param column - Column index.\n * @param row - Row index.\n * @param channel - Channel index.\n * @param interpolateBorder - Border interpolation function.\n * @param clamp - Clamp function.\n * @returns The interpolated value.\n */\nfunction interpolateBicubic(image, column, row, channel, interpolateBorder, clamp) {\n    const px1 = Math.floor(column);\n    const py1 = Math.floor(row);\n    if (px1 === column && py1 === row) {\n        return interpolateBorder(px1, py1, channel, image);\n    }\n    const xNorm = column - px1;\n    const yNorm = row - py1;\n    const vx0y0 = interpolateBorder(px1 - 1, py1 - 1, channel, image);\n    const vx1y0 = interpolateBorder(px1, py1 - 1, channel, image);\n    const vx2y0 = interpolateBorder(px1 + 1, py1 - 1, channel, image);\n    const vx3y0 = interpolateBorder(px1 + 2, py1 - 1, channel, image);\n    const v0 = cubic(vx0y0, vx1y0, vx2y0, vx3y0, xNorm);\n    const vx0y1 = interpolateBorder(px1 - 1, py1, channel, image);\n    const vx1y1 = interpolateBorder(px1, py1, channel, image);\n    const vx2y1 = interpolateBorder(px1 + 1, py1, channel, image);\n    const vx3y1 = interpolateBorder(px1 + 2, py1, channel, image);\n    const v1 = cubic(vx0y1, vx1y1, vx2y1, vx3y1, xNorm);\n    const vx0y2 = interpolateBorder(px1 - 1, py1 + 1, channel, image);\n    const vx1y2 = interpolateBorder(px1, py1 + 1, channel, image);\n    const vx2y2 = interpolateBorder(px1 + 1, py1 + 1, channel, image);\n    const vx3y2 = interpolateBorder(px1 + 2, py1 + 1, channel, image);\n    const v2 = cubic(vx0y2, vx1y2, vx2y2, vx3y2, xNorm);\n    const vx0y3 = interpolateBorder(px1 - 1, py1 + 2, channel, image);\n    const vx1y3 = interpolateBorder(px1, py1 + 2, channel, image);\n    const vx2y3 = interpolateBorder(px1 + 1, py1 + 2, channel, image);\n    const vx3y3 = interpolateBorder(px1 + 2, py1 + 2, channel, image);\n    const v3 = cubic(vx0y3, vx1y3, vx2y3, vx3y3, xNorm);\n    return round(clamp(cubic(v0, v1, v2, v3, yNorm)));\n}\n/**\n * Cubic function.\n * @param a - First value.\n * @param b - Second value.\n * @param c - Third value.\n * @param d - Fourth value.\n * @param x - X value.\n * @returns The interpolated value.\n */\nfunction cubic(a, b, c, d, x) {\n    return (b +\n        0.5 *\n            x *\n            (c - a + x * (2 * a - 5 * b + 4 * c - d + x * (3 * (b - c) + d - a))));\n}\n//# sourceMappingURL=interpolatePixel.js.map","import { Matrix, inverse } from 'ml-matrix';\nimport { Image } from '../Image.js';\nimport { getClamp } from '../utils/clamp.js';\nimport { getBorderInterpolation } from '../utils/interpolateBorder.js';\nimport { getInterpolationFunction } from '../utils/interpolatePixel.js';\n/**\n * Transforms an image using a matrix.\n * @param image - Original image.\n * @param transformMatrix - 23 transform matrix.\n * @param options - Transform options.\n * @returns The new image.\n */\nexport function transform(image, transformMatrix, options = {}) {\n    const { borderType = 'constant', borderValue = 0, interpolationType = 'bilinear', fullImage, } = options;\n    let { width = image.width, height = image.height } = options;\n    if (!isValidMatrix(transformMatrix)) {\n        throw new TypeError(`transformation matrix must be 2x3 or 3x3. Received ${transformMatrix.length}x${transformMatrix[1].length}`);\n    }\n    if (transformMatrix.length === 2) {\n        transformMatrix.push([0, 0, 1]);\n    }\n    if (fullImage) {\n        transformMatrix = transformMatrix.map((row) => row.slice());\n        transformMatrix[0][2] = 0;\n        transformMatrix[1][2] = 0;\n        const corners = [\n            image.getCoordinates('top-left'),\n            image.getCoordinates('top-right'),\n            image.getCoordinates('bottom-right'),\n            image.getCoordinates('bottom-left'),\n        ];\n        corners[1].column += 1;\n        corners[2].column += 1;\n        corners[2].row += 1;\n        corners[3].row += 1;\n        const transformedCorners = corners.map((corner) => {\n            return [\n                transformPoint(transformMatrix[0], transformMatrix[2], corner.column, corner.row),\n                transformPoint(transformMatrix[1], transformMatrix[2], corner.column, corner.row),\n            ];\n        });\n        const xCoordinates = transformedCorners.map((c) => c[0]);\n        const yCoordinates = transformedCorners.map((c) => c[1]);\n        const maxX = Math.max(...xCoordinates);\n        const maxY = Math.max(...yCoordinates);\n        const minX = Math.min(...xCoordinates);\n        const minY = Math.min(...yCoordinates);\n        const center = [(image.width - 1) / 2, (image.height - 1) / 2];\n        width = maxX - minX;\n        height = maxY - minY;\n        const centerX = transformPoint(transformMatrix[0], transformMatrix[2], center[0], center[1]);\n        const centerY = transformPoint(transformMatrix[1], transformMatrix[2], center[0], center[1]);\n        const a = (width - 1) / 2 - centerX;\n        const b = (height - 1) / 2 - centerY;\n        transformMatrix[0][2] = a;\n        transformMatrix[1][2] = b;\n        width = Math.round(width);\n        height = Math.round(height);\n    }\n    if (!options.inverse) {\n        transformMatrix = inverse(new Matrix(transformMatrix)).to2DArray();\n    }\n    const newImage = Image.createFrom(image, {\n        width,\n        height,\n    });\n    const interpolateBorder = getBorderInterpolation(borderType, borderValue);\n    const clamp = getClamp(newImage);\n    const interpolate = getInterpolationFunction(interpolationType);\n    for (let row = 0; row < newImage.height; row++) {\n        for (let column = 0; column < newImage.width; column++) {\n            const nx = transformPoint(transformMatrix[0], transformMatrix[2], column, row);\n            const ny = transformPoint(transformMatrix[1], transformMatrix[2], column, row);\n            for (let channel = 0; channel < newImage.channels; channel++) {\n                const newValue = interpolate(image, nx, ny, channel, interpolateBorder, clamp);\n                newImage.setValue(column, row, channel, newValue);\n            }\n        }\n    }\n    return newImage;\n}\n/**\n * Apply a transformation to a point.\n * @param transform - Transformation matrix.\n * @param perspective - Perspective matrix.\n * @param column - Column of the point.\n * @param row - Row of the point.\n * @returns New value.\n */\nfunction transformPoint(transform, perspective, column, row) {\n    return ((transform[0] * column + transform[1] * row + transform[2]) /\n        (perspective[0] * column + perspective[1] * row + perspective[2]));\n}\nfunction isValidMatrix(transformationMatrix) {\n    return ((transformationMatrix.length === 3 &&\n        transformationMatrix[0].length === 3 &&\n        transformationMatrix[1].length === 3 &&\n        transformationMatrix[2].length === 3) ||\n        (transformationMatrix.length === 2 &&\n            transformationMatrix[0].length === 3 &&\n            transformationMatrix[1].length === 3));\n}\n//# sourceMappingURL=transform.js.map","import { assert } from '../utils/validators/assert.js';\nimport { transform } from './transform.js';\n/**\n * Returns a resized copy of an image.\n * @param image - Original image.\n * @param options - Resize options.\n * @returns The new image.\n */\nexport function resize(image, options) {\n    const { interpolationType = 'bilinear', borderType = 'replicate', borderValue = 0, } = options;\n    const { width, height, xFactor, yFactor } = checkOptions(image, options);\n    return transform(image, [\n        [xFactor, 0, xFactor / 2],\n        [0, yFactor, yFactor / 2],\n    ], {\n        interpolationType,\n        borderType,\n        borderValue,\n        height,\n        width,\n    });\n}\n/**\n * Verify that the resize options are valid.\n * @param image - Image.\n * @param options - Resize options.\n * @returns Resize options.\n */\nfunction checkOptions(image, options) {\n    const { width, height, xFactor, yFactor, preserveAspectRatio = true, } = options;\n    if (width === undefined &&\n        height === undefined &&\n        xFactor === undefined &&\n        yFactor === undefined) {\n        throw new TypeError('at least one of the width, height, xFactor or yFactor options must be passed');\n    }\n    let newWidth;\n    let newHeight;\n    const maybeWidth = getSize(width, xFactor, image.width, preserveAspectRatio);\n    const maybeHeight = getSize(height, yFactor, image.height, preserveAspectRatio);\n    if (maybeWidth === undefined) {\n        assert(maybeHeight !== undefined);\n        newWidth = Math.round(maybeHeight * (image.width / image.height));\n    }\n    else {\n        newWidth = maybeWidth;\n    }\n    if (maybeHeight === undefined) {\n        assert(maybeWidth !== undefined);\n        newHeight = Math.round(maybeWidth * (image.height / image.width));\n    }\n    else {\n        newHeight = maybeHeight;\n    }\n    return {\n        width: newWidth,\n        height: newHeight,\n        xFactor: xFactor ?? newWidth / image.width,\n        yFactor: yFactor ?? newHeight / image.height,\n    };\n}\n/**\n * Compute automatic new size.\n * @param sizeOpt - Size option.\n * @param factor - Factor option.\n * @param sizeImg - Size of the image.\n * @param preserveAspectRatio - Whether to preserve the aspect ratio.\n * @returns New size.\n */\nfunction getSize(sizeOpt, factor, sizeImg, preserveAspectRatio) {\n    if (sizeOpt === undefined) {\n        if (factor !== undefined) {\n            return Math.round(sizeImg * factor);\n        }\n        else if (!preserveAspectRatio) {\n            return sizeImg;\n        }\n    }\n    else if (factor !== undefined) {\n        throw new TypeError('factor and size cannot be passed together');\n    }\n    else {\n        return sizeOpt;\n    }\n    return undefined;\n}\n//# sourceMappingURL=resize.js.map","import { Image } from '../Image.js';\n/**\n * Rotates an image in multiples of 90 degrees.\n * @param image - The image to rotate.\n * @param angle - The angle to rotate the image by. Positive values rotate clockwise, negative values rotate counter-clockwise.\n * @returns - The rotated image.\n */\nexport function rotate(image, angle) {\n    const newWidth = angle % 180 === 0 ? image.width : image.height;\n    const newHeight = angle % 180 === 0 ? image.height : image.width;\n    const newImage = Image.createFrom(image, {\n        width: newWidth,\n        height: newHeight,\n    });\n    if (angle === 90 || angle === -270) {\n        for (let column = 0; column < image.width; column++) {\n            for (let row = 0; row < image.height; row++) {\n                for (let channel = 0; channel < image.channels; channel++) {\n                    newImage.setValue(newImage.width - row - 1, column, channel, image.getValue(column, row, channel));\n                }\n            }\n        }\n    }\n    else if (angle === 180 || angle === -180) {\n        for (let column = 0; column < image.width; column++) {\n            for (let row = 0; row < image.height; row++) {\n                for (let channel = 0; channel < image.channels; channel++) {\n                    newImage.setValue(newImage.width - column - 1, newImage.height - row - 1, channel, image.getValue(column, row, channel));\n                }\n            }\n        }\n    }\n    else if (angle === 270 || angle === -90) {\n        for (let column = 0; column < image.width; column++) {\n            for (let row = 0; row < image.height; row++) {\n                for (let channel = 0; channel < image.channels; channel++) {\n                    newImage.setValue(row, newImage.height - column - 1, channel, image.getValue(column, row, channel));\n                }\n            }\n        }\n    }\n    else {\n        throw new RangeError(`invalid angle: ${angle}`);\n    }\n    return newImage;\n}\n//# sourceMappingURL=rotate.js.map","import { transform } from './transform.js';\n/**\n * Rotate an image anti-clockwise of a given angle.\n * @param image - Original image.\n * @param angle - Angle in degrees.\n * @param options - Rotate options.\n * @returns A new rotated image.\n */\nexport function transformRotate(image, angle, options = {}) {\n    const { center = 'center', scale = 1, ...otherOptions } = options;\n    let centerCoordinates;\n    if (typeof center === 'string') {\n        centerCoordinates = image.getCoordinates(center);\n    }\n    else {\n        centerCoordinates = center;\n    }\n    const transformMatrix = getRotationMatrix(angle, centerCoordinates, scale);\n    return transform(image, transformMatrix, otherOptions);\n}\n/**\n * Generates a rotation matrix for the given angle.\n * @param angle - Angle in degrees.\n * @param center - Center point of the image.\n * @param scale - Scaling factor.\n * @returns 3 x 3 rotation matrix.\n */\nfunction getRotationMatrix(angle, center, scale) {\n    const angleRadians = (angle * Math.PI) / 180;\n    const cos = scale * Math.cos(angleRadians);\n    const sin = scale * Math.sin(angleRadians);\n    return [\n        [cos, sin, (1 - cos) * center.column - sin * center.row],\n        [-sin, cos, sin * center.column + (1 - cos) * center.row],\n        [0, 0, 1],\n    ];\n}\n//# sourceMappingURL=transformRotate.js.map","import { Matrix, SingularValueDecomposition } from 'ml-matrix';\n// REFERENCES :\n// http://graphics.cs.cmu.edu/courses/15-463/2011_fall/Lectures/morphing.pdf\n/**\n * Computes a perspective transformation matrix to rectify a quadrilateral region into a rectangle.\n *\n * This function takes four corner points of a quadrilateral (e.g., a document photographed at an angle) and calculates the transformation matrix needed to \"unwarp\" it into a rectangular image.\n * The output dimensions can be specified or calculated automatically based on the input geometry.\n * @param pts - 4 reference corners.\n * @param options - PerspectiveWarpOptions.\n * @returns - Matrix from 4 points.\n */\nexport function getPerspectiveWarp(pts, options = {}) {\n    if (pts.length !== 4) {\n        throw new Error(`The array pts must have four elements, which are the four corners. Currently, pts have ${pts.length} elements`);\n    }\n    const { width, height } = options;\n    const [tl, tr, br, bl] = order4Points(pts);\n    let widthRect;\n    let heightRect;\n    if (height && width) {\n        widthRect = width;\n        heightRect = height;\n    }\n    else if (!height && !width) {\n        widthRect = Math.ceil(Math.max(distance2Points(tl, tr), distance2Points(bl, br)));\n        heightRect = Math.ceil(Math.max(distance2Points(tl, bl), distance2Points(tr, br)));\n    }\n    else {\n        throw new Error(`Invalid dimensions: ${width ? '`height`' : '`width`'} is missing. ` +\n            `Either provide both width and height, or omit both to auto-calculate dimensions.`);\n    }\n    const [x1, y1] = [0, 0];\n    const [x2, y2] = [widthRect - 1, 0];\n    const [x3, y3] = [widthRect - 1, heightRect - 1];\n    const [x4, y4] = [0, heightRect - 1];\n    const S = new Matrix([\n        [x1, y1, 1, 0, 0, 0, -x1 * tl.column, -y1 * tl.column],\n        [x2, y2, 1, 0, 0, 0, -x2 * tr.column, -y2 * tr.column],\n        [x3, y3, 1, 0, 0, 0, -x3 * br.column, -y3 * br.column],\n        [x4, y4, 1, 0, 0, 0, -x4 * bl.column, -y4 * bl.column],\n        [0, 0, 0, x1, y1, 1, -x1 * tl.row, -y1 * tl.row],\n        [0, 0, 0, x2, y2, 1, -x2 * tr.row, -y2 * tr.row],\n        [0, 0, 0, x3, y3, 1, -x3 * br.row, -y3 * br.row],\n        [0, 0, 0, x4, y4, 1, -x4 * bl.row, -y4 * bl.row],\n    ]);\n    const D = Matrix.columnVector([\n        tl.column,\n        tr.column,\n        br.column,\n        bl.column,\n        tl.row,\n        tr.row,\n        br.row,\n        bl.row,\n    ]);\n    const svd = new SingularValueDecomposition(S);\n    const T = svd.solve(D).to1DArray(); // solve S*T = D\n    T.push(1);\n    const M = [];\n    for (let i = 0; i < 3; i++) {\n        const row = [];\n        for (let j = 0; j < 3; j++) {\n            row.push(T[i * 3 + j]);\n        }\n        M.push(row);\n    }\n    return { matrix: M, width: widthRect, height: heightRect };\n}\n/**\n * Sorts 4 points in order =>[top-left,top-right,bottom-right,bottom-left]. Input points must be in clockwise or counter-clockwise order.\n * @param pts - Array of 4 points.\n * @returns Sorted array of 4 points.\n */\nexport function order4Points(pts) {\n    let tl;\n    let tr;\n    let br;\n    let bl;\n    let minX = pts[0].column;\n    let indexMinX = 0;\n    for (let i = 1; i < pts.length; i++) {\n        if (pts[i].column < minX) {\n            minX = pts[i].column;\n            indexMinX = i;\n        }\n    }\n    let minX2 = pts[(indexMinX + 1) % pts.length].column;\n    let indexMinX2 = (indexMinX + 1) % pts.length;\n    for (let i = 0; i < pts.length; i++) {\n        if (pts[i].column < minX2 && i !== indexMinX) {\n            minX2 = pts[i].column;\n            indexMinX2 = i;\n        }\n    }\n    if (pts[indexMinX2].row < pts[indexMinX].row) {\n        tl = pts[indexMinX2];\n        bl = pts[indexMinX];\n        if (indexMinX !== (indexMinX2 + 1) % 4) {\n            tr = pts[(indexMinX2 + 1) % 4];\n            br = pts[(indexMinX2 + 2) % 4];\n        }\n        else {\n            tr = pts[(indexMinX2 + 2) % 4];\n            br = pts[(indexMinX2 + 3) % 4];\n        }\n    }\n    else {\n        bl = pts[indexMinX2];\n        tl = pts[indexMinX];\n        if (indexMinX2 !== (indexMinX + 1) % 4) {\n            tr = pts[(indexMinX + 1) % 4];\n            br = pts[(indexMinX + 2) % 4];\n        }\n        else {\n            tr = pts[(indexMinX + 2) % 4];\n            br = pts[(indexMinX + 3) % 4];\n        }\n    }\n    return [tl, tr, br, bl];\n}\n/**\n *  Calculates distance between points.\n * @param p1 - Point1\n * @param p2 - Point2\n * @returns distance between points.\n */\nfunction distance2Points(p1, p2) {\n    return Math.hypot(p1.column - p2.column, p1.row - p2.row);\n}\n//# sourceMappingURL=getPerspectiveWarp.js.map","/**\n * Rotate a point around a center by a given angle.\n * @param point - The point to rotate\n * @param rotationCenter - The center of rotation\n * @param angle - The angle of rotation in radians\n * @returns The rotated point\n */\nexport function rotatePoint(point, rotationCenter, angle) {\n    const angleCos = Math.cos(angle);\n    const angleSin = Math.sin(angle);\n    const column = point.column * angleCos -\n        point.row * angleSin +\n        (1 - angleCos) * rotationCenter.column +\n        rotationCenter.row * angleSin;\n    const row = point.column * angleSin +\n        point.row * angleCos +\n        (1 - angleCos) * rotationCenter.row -\n        rotationCenter.column * angleSin;\n    return { column, row };\n}\n//# sourceMappingURL=operations.js.map","import { transform } from '../geometry/index.js';\nimport { getAngle } from '../maskAnalysis/utils/getAngle.js';\nimport { rotatePoint } from '../point/operations.js';\n/**\n * Crop an oriented rectangle from an image.\n * If the rectangle's length or width are not an integers, its dimension is expanded in both directions such as the length and width are integers.\n * @param image - The input image\n * @param points - The points of the rectangle. Points must be circling around the rectangle (clockwise or anti-clockwise). The validity of the points passed is assumed and not checked.\n * @param options - Crop options, see {@link CropRectangleOptions}\n * @returns The cropped image. The orientation of the image is the one closest to the rectangle passed as input.\n */\nexport function cropRectangle(image, points, options) {\n    if (points.length !== 4) {\n        throw new Error('The points array must contain 4 points');\n    }\n    // get the smallest possible angle which puts the rectangle in an upright position\n    const angle = getSmallestAngle(points);\n    const center = {\n        row: (points[0].row + points[2].row) / 2,\n        column: (points[0].column + points[2].column) / 2,\n    };\n    // Rotated points form an upright rectangle\n    const rotatedPoints = points.map((p) => rotatePoint(p, center, angle));\n    const [p1, p2, p3] = rotatedPoints;\n    const originalWidth = Math.max(Math.abs(p1.column - p2.column), Math.abs(p2.column - p3.column));\n    const originalHeight = Math.max(Math.abs(p1.row - p2.row), Math.abs(p2.row - p3.row));\n    // Deal with numerical imprecision when the rectangle actually had a whole number width or height\n    const width = Math.min(Math.ceil(originalWidth), Math.ceil(originalWidth - 1e-10));\n    const height = Math.min(Math.ceil(originalHeight), Math.ceil(originalHeight - 1e-10));\n    // Top left position of the upright rectangle after normalization of width and height\n    const expandedTopLeft = {\n        row: Math.min(...rotatedPoints.map((p) => p.row)) -\n            (height - originalHeight) / 2,\n        column: Math.min(...rotatedPoints.map((p) => p.column)) -\n            (width - originalWidth) / 2,\n    };\n    const translation = rotatePoint(expandedTopLeft, center, -angle);\n    const angleCos = Math.cos(-angle);\n    const angleSin = Math.sin(-angle);\n    const matrix = [\n        [angleCos, -angleSin, translation.column],\n        [angleSin, angleCos, translation.row],\n    ];\n    return transform(image, matrix, {\n        inverse: true,\n        width,\n        height,\n        ...options,\n    });\n}\n/**\n * Get the smallest angle to put the rectangle in an upright position\n * @param points - 2 points forming a line\n * @returns The angle in radians\n */\nfunction getSmallestAngle(points) {\n    // Angle respective to horizontal, -/2 and /2\n    let angleHorizontal = -getAngle(points[1], points[0]);\n    if (angleHorizontal > Math.PI / 2) {\n        angleHorizontal -= Math.PI;\n    }\n    else if (angleHorizontal < -Math.PI / 2) {\n        angleHorizontal += Math.PI;\n    }\n    // angle is between -/4 and /4\n    let angle = angleHorizontal;\n    if (Math.abs(angleHorizontal) > Math.PI / 4) {\n        angle =\n            angleHorizontal > 0\n                ? -Math.PI / 2 + angleHorizontal\n                : Math.PI / 2 + angleHorizontal;\n    }\n    return angle;\n}\n//# sourceMappingURL=cropRectangle.js.map","import { getDefaultColor } from '../utils/getDefaultColor.js';\nimport { getOutputImage } from '../utils/getOutputImage.js';\nimport { setBlendedPixel } from '../utils/setBlendedPixel.js';\nimport { checkPointIsInteger } from '../utils/validators/checkPointIsInteger.js';\n/**\n * Paint a mask onto an image and the given position and with the given color.\n * @param image - Image on which to paint the mask.\n * @param mask - Mask to paint on the image.\n * @param options - Paint mask options.\n * @returns The painted image.\n */\nexport function paintMaskOnImage(image, mask, options = {}) {\n    const { origin = { row: 0, column: 0 }, color = getDefaultColor(image), blend = true, } = options;\n    const { column, row } = origin;\n    if (color.length !== image.channels) {\n        throw new RangeError('the given color is not compatible with the image');\n    }\n    checkPointIsInteger(origin, 'Origin');\n    const result = getOutputImage(image, options, { clone: true });\n    if (blend) {\n        checkColorIsNumberArray(color);\n        for (let currentRow = Math.max(row, 0); currentRow < Math.min(mask.height + row, image.height); currentRow++) {\n            for (let currentColumn = Math.max(column, 0); currentColumn < Math.min(mask.width + column, image.width); currentColumn++) {\n                if (mask.getBit(currentColumn - column, currentRow - row)) {\n                    setBlendedPixel(result, currentColumn, currentRow, color);\n                }\n            }\n        }\n    }\n    else {\n        for (let currentRow = Math.max(row, 0); currentRow < Math.min(mask.height + row, image.height); currentRow++) {\n            for (let currentColumn = Math.max(column, 0); currentColumn < Math.min(mask.width + column, image.width); currentColumn++) {\n                if (mask.getBit(currentColumn - column, currentRow - row)) {\n                    for (let channel = 0; channel < image.channels; channel++) {\n                        const currentValue = color[channel];\n                        if (typeof currentValue === 'number') {\n                            result.setValue(currentColumn, currentRow, channel, currentValue);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return result;\n}\nfunction checkColorIsNumberArray(color) {\n    for (const channel of color) {\n        if (typeof channel !== 'number') {\n            throw new TypeError('cannot have null channels in color if blend is true');\n        }\n    }\n}\n//# sourceMappingURL=paintMaskOnImage.js.map","import { maskToOutputMask } from '../utils/getOutputImage.js';\nimport { checkPointIsInteger } from '../utils/validators/checkPointIsInteger.js';\n/**\n * Paint a mask onto an image and the given position and with the given color.\n * @param image - Image on which to paint the mask.\n * @param mask - Mask to paint on the image.\n * @param options - Paint mask options.\n * @returns The painted image.\n */\nexport function paintMaskOnMask(image, mask, options = {}) {\n    const { origin = { row: 0, column: 0 }, value = 1 } = options;\n    const { column, row } = origin;\n    checkPointIsInteger(origin, 'Origin');\n    const result = maskToOutputMask(image, options, { clone: true });\n    for (let currentRow = Math.max(row, 0); currentRow < Math.min(mask.height + row, image.height); currentRow++) {\n        for (let currentColumn = Math.max(column, 0); currentColumn < Math.min(mask.width + column, image.width); currentColumn++) {\n            if (mask.getBit(currentColumn - column, currentRow - row)) {\n                result.setBit(currentColumn, currentRow, value);\n            }\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=paintMaskOnMask.js.map","/**\n * Cast `number` to string. Optionally `digits` specifies significant figures.\n * @param number\n * @param figures\n * @returns - A string representation of `number`.\n */\nexport function maybeToPrecision(number, figures) {\n    if (number < 0) {\n        number = 0 - number;\n        if (typeof figures === 'number') {\n            return `- ${number.toPrecision(figures)}`;\n        }\n        else {\n            return `- ${number.toString()}`;\n        }\n    }\n    else if (typeof figures === 'number') {\n        return number.toPrecision(figures);\n    }\n    else {\n        return number.toString();\n    }\n}\n//# sourceMappingURL=maybeToPrecision.js.map","import { isAnyArray } from 'is-any-array';\n/**\n * Check that x and y are arrays with the same length.\n * @param x - first array\n * @param y - second array\n * @throws if x or y are not the same length, or if they are not arrays\n */\nexport function checkArrayLength(input, output) {\n    // TODO: This function should be removed and replace by\n    // https://github.com/mljs/spectra-processing/blob/main/src/xy/xyCheck.ts\n    if (!isAnyArray(input.x) || !isAnyArray(input.y) || !isAnyArray(output)) {\n        throw new TypeError('x, y and outputs must be arrays');\n    }\n    if (input.x.length < 2) {\n        throw new RangeError('explanatory variable should be two element per point');\n    }\n    if (input.x.length !== input.y.length) {\n        throw new RangeError('x and y data must have the same length');\n    }\n    if (input.x.length !== output.length) {\n        throw new RangeError('input and outputs must have the same length');\n    }\n}\n//# sourceMappingURL=checkArrayLength.js.map","import { isAnyArray } from 'is-any-array';\nimport { checkArrayLength } from './checkArrayLength';\nexport class BaseRegression2D {\n    constructor() {\n        if (new.target === BaseRegression2D) {\n            throw new Error('BaseRegression must be subclassed');\n        }\n    }\n    predict(inputs) {\n        if (isOnePoint(inputs)) {\n            return this._predict(inputs);\n        }\n        else if (isAnyArray(inputs.x)) {\n            const { x, y } = inputs;\n            const result = new Float64Array(x.length);\n            for (let i = 0; i < x.length; i++) {\n                result[i] = this._predict({ x: x[i], y: y[i] });\n            }\n            return result;\n        }\n        else {\n            throw new TypeError('x must be a number or array');\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _predict(x) {\n        throw new Error('_predict must be implemented');\n    }\n    train() {\n        // Do nothing for this package\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    toString(precision) {\n        return '';\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    toLaTeX(precision) {\n        return '';\n    }\n    /**\n     * Return the correlation coefficient of determination (r) and chi-square.\n     * @param x - explanatory variable\n     * @param y - response variable\n     * @return - Object with further statistics.\n     */\n    getScore(input, z) {\n        checkArrayLength(input, z);\n        const y2 = this.predict(input);\n        let xSum = 0;\n        let ySum = 0;\n        let chi2 = 0;\n        let rmsd = 0;\n        let xSquared = 0;\n        let ySquared = 0;\n        let xY = 0;\n        const n = z.length;\n        for (let i = 0; i < n; i++) {\n            xSum += y2[i];\n            ySum += z[i];\n            xSquared += y2[i] * y2[i];\n            ySquared += z[i] * z[i];\n            xY += y2[i] * z[i];\n            if (z[i] !== 0) {\n                chi2 += ((z[i] - y2[i]) * (z[i] - y2[i])) / z[i];\n            }\n            rmsd += (z[i] - y2[i]) * (z[i] - y2[i]);\n        }\n        const r = (n * xY - xSum * ySum) /\n            Math.sqrt((n * xSquared - xSum * xSum) * (n * ySquared - ySum * ySum));\n        return {\n            r,\n            r2: r * r,\n            chi2,\n            rmsd: Math.sqrt(rmsd / n),\n        };\n    }\n}\nfunction isOnePoint(input) {\n    return !isAnyArray(input.x);\n}\nexport { checkArrayLength };\n//# sourceMappingURL=BaseRegression2D.js.map","import { Matrix, SVD } from 'ml-matrix';\nimport { maybeToPrecision } from 'ml-regression-base';\nimport { BaseRegression2D, checkArrayLength } from './BaseRegression2D';\n// Implements the Kernel ridge regression algorithm.\n// http://www.ics.uci.edu/~welling/classnotes/papers_class/Kernel-Ridge.pdf\nexport class PolynomialRegression2D extends BaseRegression2D {\n    order;\n    coefficients;\n    score;\n    /**\n     * Constructor for the 2D polynomial fitting\n     *\n     * @param inputs - independent or explanatory variable\n     * @param outputs - dependent or response variable`\n     * @constructor\n     */\n    constructor(inputs, outputs, options = {}) {\n        super();\n        // @ts-expect-error internal use only\n        if (inputs === true) {\n            // @ts-expect-error internal use only\n            this.coefficients = Matrix.columnVector(outputs.coefficients);\n            // @ts-expect-error internal use only\n            this.order = outputs.order;\n            // @ts-expect-error internal use only\n            this.score = outputs.score;\n        }\n        else {\n            checkArrayLength(inputs, outputs);\n            const { order = 2 } = options;\n            this.order = order;\n            this.coefficients = train(inputs, outputs, order);\n            this.score = this.getScore(inputs, outputs);\n        }\n    }\n    _predict(newInputs) {\n        const { x, y } = newInputs;\n        let z = 0;\n        let column = 0;\n        for (let i = 0; i <= this.order; i++) {\n            for (let j = 0; j <= this.order - i; j++) {\n                z += x ** i * y ** j * this.coefficients.get(column, 0);\n                column++;\n            }\n        }\n        return z;\n    }\n    toString(precision) {\n        return this._toFormula(precision, false);\n    }\n    toLaTeX(precision) {\n        return this._toFormula(precision, true);\n    }\n    _toFormula(precision, isLaTeX) {\n        let sup = '^';\n        let closeSup = '';\n        let times = ' * ';\n        if (isLaTeX) {\n            sup = '^{';\n            closeSup = '}';\n            times = '';\n        }\n        let fn = '';\n        let str = '';\n        let column = 0;\n        for (let i = 0; i <= this.order; i++) {\n            for (let j = 0; j <= this.order - i; j++) {\n                str = '';\n                const coefficient = this.coefficients.get(column, 0);\n                if (coefficient !== 0) {\n                    str += maybeToPrecision(coefficient, precision);\n                    if (i === 1) {\n                        str += `${times}x`;\n                    }\n                    else if (i > 1) {\n                        str += `${times}x${sup}${i}${closeSup}`;\n                    }\n                    if (j === 1) {\n                        str += `${times}y`;\n                    }\n                    else if (j > 1) {\n                        str += `${times}y${sup}${j}${closeSup}`;\n                    }\n                    if (coefficient > 0) {\n                        str = ` + ${str}`;\n                    }\n                    else {\n                        str = ` ${str}`;\n                    }\n                }\n                column++;\n                fn = str + fn;\n            }\n        }\n        return `f(x, y) = ${fn.startsWith('+') ? fn.slice(1) : fn}`;\n    }\n    toJSON() {\n        return {\n            name: 'polyfit2D',\n            order: this.order,\n            score: this.score,\n            coefficients: this.coefficients,\n        };\n    }\n    static load(json) {\n        if (json.name !== 'polyfit2D') {\n            throw new TypeError('not a polyfit2D model');\n        }\n        //@ts-expect-error internal use only\n        return new PolynomialRegression2D(true, json);\n    }\n}\n/**\n * Function that given a column vector return this: vector^power\n *\n * @param x - Column vector.\n * @param power - Pow number.\n * @return {Matrix}\n */\nfunction powColVector(x, power) {\n    const result = x.clone();\n    for (let i = 0; i < x.rows; ++i) {\n        result.set(i, 0, result.get(i, 0) ** power);\n    }\n    return result;\n}\n/**\n * Function that fits the model given the data(x) and predictions(y).\n * The third argument is an object with the following options:\n * * order: order of the polynomial to fit.\n *\n * @param x - A matrix with n rows and 2 columns.\n * @param y - A vector of the prediction values.\n */\nfunction train(input, y, order) {\n    if (!Matrix.isMatrix(y))\n        y = Matrix.columnVector(y);\n    const x = new Matrix(y.rows, 2);\n    x.setColumn(0, input.x);\n    x.setColumn(1, input.y);\n    if (y.rows !== x.rows) {\n        y = y.transpose();\n    }\n    if (x.columns !== 2) {\n        throw new RangeError(`You give x with ${x.columns} columns and it must be 2`);\n    }\n    if (x.rows !== y.rows) {\n        throw new RangeError('x and y must have the same rows');\n    }\n    const examples = x.rows;\n    const nbCoefficients = ((order + 2) * (order + 1)) / 2;\n    if (examples < nbCoefficients) {\n        throw new TypeError('Insufficient number of points to create regression model.');\n    }\n    const x1 = x.getColumnVector(0);\n    const x2 = x.getColumnVector(1);\n    const scaleX1 = 1.0 / x1.clone().abs().max();\n    const scaleX2 = 1.0 / x2.clone().abs().max();\n    const scaleY = 1.0 / y.clone().abs().max();\n    x1.mulColumn(0, scaleX1);\n    x2.mulColumn(0, scaleX2);\n    y.mulColumn(0, scaleY);\n    const A = new Matrix(examples, nbCoefficients);\n    let col = 0;\n    for (let i = 0; i <= order; ++i) {\n        const limit = order - i;\n        for (let j = 0; j <= limit; ++j) {\n            const result = powColVector(x1, i).mulColumnVector(powColVector(x2, j));\n            A.setColumn(col, result);\n            col++;\n        }\n    }\n    const svd = new SVD(A.transpose(), {\n        computeLeftSingularVectors: true,\n        computeRightSingularVectors: true,\n        autoTranspose: false,\n    });\n    let qqs = Matrix.rowVector(svd.diagonal);\n    qqs = qqs.apply((i, j) => {\n        if (qqs.get(i, j) >= 1e-15)\n            qqs.set(i, j, 1 / qqs.get(i, j));\n        else\n            qqs.set(i, j, 0);\n    });\n    const qqs1 = Matrix.zeros(examples, nbCoefficients);\n    for (let i = 0; i < nbCoefficients; ++i) {\n        qqs1.set(i, i, qqs.get(0, i));\n    }\n    qqs = qqs1;\n    const U = svd.rightSingularVectors;\n    const V = svd.leftSingularVectors;\n    const coefficients = V.mmul(qqs.transpose()).mmul(U.transpose()).mmul(y);\n    for (let i = 0, col = 0; i <= nbCoefficients; ++i) {\n        const limit = order - i;\n        for (let j = 0; j <= limit; ++j) {\n            coefficients.set(col, 0, (coefficients.get(col, 0) * scaleX1 ** i * scaleX2 ** j) / scaleY);\n            col++;\n        }\n    }\n    return coefficients;\n}\n//# sourceMappingURL=PolynomialRegression2D.js.map","import { PolynomialRegression2D } from 'ml-regression-polynomial-2d';\nimport checkProcessable from '../utils/validators/checkProcessable.js';\n/**\n * Corrects background from an image for baseline correction.\n * @param image - Image to subtract background from.\n * @param options - CorrectBackgroundOptions.\n * @returns Image with corrected baseline.\n */\nexport function correctBackground(image, options) {\n    const { background, order = 2, backgroundKind = 'light' } = options;\n    checkProcessable(image, { colorModel: ['GREY'] });\n    const columns = new Array();\n    const rows = new Array();\n    const values = new Array();\n    for (const point of background) {\n        columns.push(point.column);\n        rows.push(point.row);\n        values.push(image.getValueByPoint(point, 0));\n    }\n    const model = new PolynomialRegression2D({ x: columns, y: rows }, values, {\n        order,\n    });\n    const points = { x: [], y: [] };\n    for (let row = 0; row < image.height; row++) {\n        for (let column = 0; column < image.width; column++) {\n            points.x.push(column);\n            points.y.push(row);\n        }\n    }\n    const Y = model.predict(points);\n    for (let row = 0; row < image.height; row++) {\n        for (let column = 0; column < image.width; column++) {\n            const value = Math.abs(image.getValue(column, row, 0) - Y[row * image.width + column]);\n            image.setValue(column, row, 0, value);\n        }\n    }\n    if (backgroundKind === 'light') {\n        return image.invert();\n    }\n    else {\n        return image;\n    }\n}\n//# sourceMappingURL=correctBackground.js.map","import { Image } from '../Image.js';\nimport { copyAlpha } from '../operations/index.js';\nimport { getOutputImage, maskToOutputMask } from '../utils/getOutputImage.js';\n/**\n * Invert the components of an image.\n * @param image - The image to invert.\n * @param options - Invert options.\n * @returns The inverted image.\n */\nexport function invert(image, options) {\n    if (image instanceof Image) {\n        const newImage = getOutputImage(image, options);\n        if (image.alpha) {\n            copyAlpha(image, newImage);\n        }\n        const { maxValue, size } = newImage;\n        for (let i = 0; i < size; i++) {\n            for (let component = 0; component < image.components; component++) {\n                newImage.setValueByIndex(i, component, maxValue - image.getValueByIndex(i, component));\n            }\n        }\n        return newImage;\n    }\n    else {\n        const newImage = maskToOutputMask(image, options);\n        for (let i = 0; i < newImage.size; i++) {\n            newImage.setBitByIndex(i, !image.getBitByIndex(i));\n        }\n        return newImage;\n    }\n}\n//# sourceMappingURL=invert.js.map","import { getClamp } from '../utils/clamp.js';\nimport { getOutputImage } from '../utils/getOutputImage.js';\nimport checkProcessable from '../utils/validators/checkProcessable.js';\nimport { validateChannels } from '../utils/validators/validators.js';\n/**\n * Level the image using the optional input and output value. The default options allow to increase the image's contrast.\n * @param image - Image to process.\n * @param options - Level options.\n * @returns The levelled image.\n */\nexport function level(image, options = {}) {\n    const minMax = image.minMax();\n    let { inputMin = minMax.min, inputMax = minMax.max, outputMin = 0, outputMax = image.maxValue, gamma = 1, } = options;\n    const { channels = new Array(image.components).fill(0).map((value, index) => index), } = options;\n    validateChannels(channels, image);\n    checkProcessable(image, {\n        bitDepth: [8, 16],\n    });\n    const newImage = getOutputImage(image, options, { clone: true });\n    const clamp = getClamp(image);\n    inputMin = getValueArray(inputMin, image.channels);\n    inputMax = getValueArray(inputMax, image.channels);\n    outputMin = getValueArray(outputMin, image.channels);\n    outputMax = getValueArray(outputMax, image.channels);\n    gamma = getValueArray(gamma, image.channels);\n    for (let row = 0; row < image.height; row++) {\n        for (let column = 0; column < image.width; column++) {\n            for (const channel of channels) {\n                const currentValue = image.getValue(column, row, channel);\n                const clamped = Math.max(Math.min(currentValue, inputMax[channel]), inputMin[channel]);\n                let ratio = clamp((clamped - inputMin[channel]) /\n                    (inputMax[channel] - inputMin[channel]));\n                if (Number.isNaN(ratio))\n                    ratio = 0;\n                const result = clamp(ratio ** (1 / gamma[channel]) *\n                    (outputMax[channel] - outputMin[channel]) +\n                    outputMin[channel]);\n                newImage.setValue(column, row, channel, result);\n            }\n        }\n    }\n    return newImage;\n}\n/**\n * Get an array with correct values for each channel to process.\n * @param value - Number or array to transform to the final array.\n * @param imageChannels - Number of channels processed in the level function.\n * @returns Array of values for each channel.\n */\nfunction getValueArray(value, imageChannels) {\n    if (Array.isArray(value)) {\n        if (value.length === imageChannels) {\n            return value;\n        }\n        else {\n            throw new RangeError('array length is not compatible with channel option');\n        }\n    }\n    else {\n        return new Array(imageChannels).fill(value);\n    }\n}\n//# sourceMappingURL=level.js.map","import { maskToOutputMask } from '../utils/getOutputImage.js';\n/**\n * Perform an OR operation on two masks.\n * @param mask - First mask.\n * @param otherMask - Second mask.\n * @param options - Or options.\n * @returns OR of the two masks.\n */\nexport function or(mask, otherMask, options) {\n    const newMask = maskToOutputMask(mask, options);\n    if (mask.width !== otherMask.width || mask.height !== otherMask.height) {\n        throw new RangeError('both masks must have the same size');\n    }\n    for (let i = 0; i < newMask.size; i++) {\n        if (mask.getBitByIndex(i) || otherMask.getBitByIndex(i)) {\n            newMask.setBitByIndex(i, 1);\n        }\n        else {\n            newMask.setBitByIndex(i, 0);\n        }\n    }\n    return newMask;\n}\n//# sourceMappingURL=or.js.map","import checkProcessable from '../utils/validators/checkProcessable.js';\n/**\n * Apply a flipX filter to an image.\n * @param image - Image to process.\n * @returns The processed image.\n */\nexport default function flipX(image) {\n    checkProcessable(image, {\n        bitDepth: [8, 16],\n    });\n    for (let row = 0; row < image.height; row++) {\n        for (let column = 0; column < Math.floor(image.width / 2); column++) {\n            const currentCol = column;\n            const oppositeCol = image.width - column - 1;\n            for (let channel = 0; channel < image.channels; channel++) {\n                const tmp = image.getValue(currentCol, row, channel);\n                image.setValue(currentCol, row, channel, image.getValue(oppositeCol, row, channel));\n                image.setValue(oppositeCol, row, channel, tmp);\n            }\n        }\n    }\n    return image;\n}\n//# sourceMappingURL=flipX.js.map","import checkProcessable from '../utils/validators/checkProcessable.js';\n/**\n * Apply a flipY filter to an image.\n * @param image - Image to process.\n * @returns The processed image.\n */\nexport default function flipY(image) {\n    checkProcessable(image, {\n        bitDepth: [8, 16],\n    });\n    for (let row = 0; row < Math.floor(image.height / 2); row++) {\n        for (let column = 0; column < image.width; column++) {\n            const currentRow = row;\n            const oppositeRow = image.height - row - 1;\n            for (let channel = 0; channel < image.channels; channel++) {\n                const tmp = image.getValue(column, currentRow, channel);\n                image.setValue(column, currentRow, channel, image.getValue(column, oppositeRow, channel));\n                image.setValue(column, oppositeRow, channel, tmp);\n            }\n        }\n    }\n    return image;\n}\n//# sourceMappingURL=flipY.js.map","import { getOutputImage } from '../utils/getOutputImage.js';\nimport flipX from './flipX.js';\nimport flipY from './flipY.js';\n/**\n * Apply a flip filter to an image.\n * @param image - Image to process.\n * @param options - Flip options.\n * @returns - The processed image.\n */\nexport function flip(image, options = {}) {\n    const { axis = 'horizontal' } = options;\n    const newImage = getOutputImage(image, options, { clone: true });\n    if (axis === 'horizontal') {\n        return flipX(newImage);\n    }\n    else if (axis === 'vertical') {\n        return flipY(newImage);\n    }\n    else {\n        return flipY(flipX(newImage));\n    }\n}\n//# sourceMappingURL=flip.js.map","import { xMedian } from 'ml-spectra-processing';\nimport { Image } from '../Image.js';\nimport { getBorderInterpolation } from '../utils/interpolateBorder.js';\nimport checkProcessable from '../utils/validators/checkProcessable.js';\n/**\n * Calculate a new image that replaces all pixel values by the median of neighbouring pixels.\n * @param image - Image to be filtered.\n * @param options - MedianFilterOptions\n * @returns Image after median filter.\n */\nexport function medianFilter(image, options) {\n    const { cellSize = 3, borderType = 'reflect101', borderValue } = options;\n    checkProcessable(image, {\n        bitDepth: [8, 16],\n    });\n    if (cellSize < 1) {\n        throw new RangeError(`Invalid property \"cellSize\". Must be greater than 0. Received ${cellSize}.`);\n    }\n    if (cellSize % 2 === 0) {\n        throw new RangeError(`Invalid property \"cellSize\". Must be an odd number. Received ${cellSize}.`);\n    }\n    const interpolateBorder = getBorderInterpolation(borderType, borderValue);\n    const newImage = Image.createFrom(image);\n    const size = cellSize ** 2;\n    const cellValues = new Uint16Array(size);\n    const halfCellSize = (cellSize - 1) / 2;\n    for (let channel = 0; channel < image.channels; channel++) {\n        for (let row = 0; row < image.height; row++) {\n            for (let column = 0; column < image.width; column++) {\n                let n = 0;\n                for (let cellRow = -halfCellSize; cellRow <= halfCellSize; cellRow++) {\n                    for (let cellColumn = -halfCellSize; cellColumn <= halfCellSize; cellColumn++) {\n                        cellValues[n++] = interpolateBorder(column + cellColumn, row + cellRow, channel, image);\n                    }\n                }\n                newImage.setValue(column, row, channel, xMedian(cellValues));\n            }\n        }\n    }\n    return newImage;\n}\n//# sourceMappingURL=medianFilter.js.map","import { xMedian } from 'ml-spectra-processing';\nimport { getOutputImage } from '../utils/getOutputImage.js';\nimport { assertUnreachable } from '../utils/validators/assert.js';\n/**\n * Function to pixelate an image.\n * @param image - Image to be pixelated.\n * @param options - PixelateOptions.\n * @returns Pixelated Image.\n */\nexport function pixelate(image, options) {\n    const { cellSize, algorithm = 'center' } = options;\n    if (!Number.isInteger(cellSize)) {\n        throw new TypeError('cellSize must be an integer');\n    }\n    if (cellSize < 2) {\n        throw new RangeError('cellSize must be greater than 1');\n    }\n    const newImage = getOutputImage(image, options);\n    const getCellValue = getCellValueFunction(algorithm);\n    for (let channel = 0; channel < image.channels; channel++) {\n        for (let column = 0; column < image.width; column += cellSize) {\n            for (let row = 0; row < image.height; row += cellSize) {\n                const currentCellWidth = Math.min(cellSize, image.width - column);\n                const currentCellHeight = Math.min(cellSize, image.height - row);\n                const value = getCellValue(image, channel, {\n                    width: currentCellWidth,\n                    height: currentCellHeight,\n                    origin: { column, row },\n                });\n                for (let newColumn = column; newColumn < column + currentCellWidth; newColumn++) {\n                    for (let newRow = row; newRow < row + currentCellHeight; newRow++) {\n                        newImage.setValue(newColumn, newRow, channel, value);\n                    }\n                }\n            }\n        }\n    }\n    return newImage;\n}\n/**\n * Computes the center value for the current sector\n * @param image - image used for the algorithm\n * @param channel - image channel toto find center value of\n * @param options - GetValueOptions\n * @returns center value\n */\nfunction getCellCenter(image, channel, options) {\n    const center = {\n        column: Math.floor((options.origin.column + options.origin.column + options.width - 1) / 2),\n        row: Math.floor((options.origin.row + options.origin.row + options.height - 1) / 2),\n    };\n    const value = image.getValue(center.column, center.row, channel);\n    return value;\n}\n/**\n * Computes mean value for the current sector\n * @param image - image used for algorithm\n * @param channel - current channel of an image\n * @param options - GetValueOptions\n * @returns mean value\n */\nfunction getCellMean(image, channel, options) {\n    let sum = 0;\n    for (let column = options.origin.column; column < options.origin.column + options.width; column++) {\n        for (let row = options.origin.row; row < options.origin.row + options.height; row++) {\n            sum += image.getValue(column, row, channel);\n        }\n    }\n    return Math.round(sum / (options.width * options.height));\n}\n/**\n * Computes a median value for the current sector\n * @param image - image used algorithm\n * @param channel - current channel of an image\n * @param options - GetValueOptions\n * @returns median value\n */\nfunction getCellMedian(image, channel, options) {\n    const array = [];\n    for (let column = options.origin.column; column < options.origin.column + options.width; column++) {\n        for (let row = options.origin.row; row < options.origin.row + options.height; row++) {\n            array.push(image.getValue(column, row, channel));\n        }\n    }\n    return xMedian(array);\n}\n/**\n *  Chooses which algorithm to use for pixelization and returns a function to use for computation\n * @param algorithm - string with the name of an algorithm\n * @returns function\n */\nfunction getCellValueFunction(algorithm) {\n    switch (algorithm) {\n        case 'mean':\n            return getCellMean;\n        case 'median':\n            return getCellMedian;\n        case 'center':\n            return getCellCenter;\n        default:\n            assertUnreachable(algorithm);\n            break;\n    }\n}\n//# sourceMappingURL=pixelate.js.map","// TODO: This function could be optimised by following the contour instead of scanning all pixels.\n/**\n * Return an array with the coordinates of the pixels that are on the border of the mask.\n * The reference is the top-left corner of the ROI.\n * @param mask - Mask to process.\n * @param options - Get border points options.\n * @returns The array of border pixels.\n */\nexport function getBorderPoints(mask, options = {}) {\n    const { innerBorders = false, allowCorners = false } = options;\n    if (!innerBorders) {\n        mask = mask.solidFill();\n    }\n    const borders = [];\n    // first process frame pixels\n    for (let column = 0; column < mask.width; column++) {\n        if (mask.getBit(column, 0)) {\n            borders.push({ column, row: 0 });\n        }\n        if (mask.getBit(column, mask.height - 1)) {\n            borders.push({ column, row: mask.height - 1 });\n        }\n    }\n    for (let row = 0; row < mask.height; row++) {\n        if (mask.getBit(0, row)) {\n            borders.push({ column: 0, row });\n        }\n        if (mask.getBit(mask.width - 1, row)) {\n            borders.push({ column: mask.width - 1, row });\n        }\n    }\n    for (let row = 1; row < mask.height - 1; row++) {\n        for (let column = 1; column < mask.width - 1; column++) {\n            if (mask.getBit(column, row)) {\n                if (mask.getBit(column - 1, row) === 0 ||\n                    mask.getBit(column, row - 1) === 0 ||\n                    mask.getBit(column + 1, row) === 0 ||\n                    mask.getBit(column, row + 1) === 0) {\n                    borders.push({ column, row });\n                }\n                if (allowCorners &&\n                    (mask.getBit(column - 1, row - 1) === 0 ||\n                        mask.getBit(column - 1, row + 1) === 0 ||\n                        mask.getBit(column + 1, row - 1) === 0 ||\n                        mask.getBit(column + 1, row + 1) === 0)) {\n                    borders.push({ column, row });\n                }\n            }\n        }\n    }\n    return borders;\n}\n//# sourceMappingURL=getBorderPoints.js.map","/**\n * Compute the length of a segment defined by two points.\n * @param p1 - First point.\n * @param p2 - Second point.\n * @returns Length of the segment.\n */\nexport function getLineLength(p1, p2) {\n    return Math.hypot(p1.column - p2.column, p1.row - p2.row);\n}\n//# sourceMappingURL=lines.js.map","import { getLineLength } from './lines.js';\n/**\n * Compute the perimeter of a polygon.\n * @param points - Array of polygon vertices.\n * @returns The perimeter.\n */\nexport function getPolygonPerimeter(points) {\n    let perimeter = 0;\n    for (let i = 0; i < points.length; i++) {\n        perimeter += getLineLength(points[(i + 1) % points.length], points[i]);\n    }\n    return perimeter;\n}\n/**\n * Compute the area of a polygon.\n * Based on the algorithm described on\n * @see {@link https://web.archive.org/web/20100405070507/http://valis.cs.uiuc.edu/~sariel/research/CG/compgeom/msg00831.html}\n * @param points - Array of polygon vertices.\n * @returns The area.\n */\nexport function getPolygonArea(points) {\n    let area = 0;\n    for (let current = 0; current < points.length; current++) {\n        const next = (current + 1) % points.length;\n        area += points[current].column * points[next].row;\n        area -= points[current].row * points[next].column;\n    }\n    return Math.abs(area / 2);\n}\n//# sourceMappingURL=polygons.js.map","/**\n * Get the pixels that surround an ROI. The pixels include the top and left borders,\n * but extend the right and bottom one by one pixel.\n * This allows to compute the minimum bounding rectangle with the correct surface.\n * This method is only used to calculate minimalBoundRectangle and convexHull.\n * @param mask - The ROI for which to get the extended border points.\n * @returns - The array of points.\n */\nexport function getExtendedBorderPoints(mask) {\n    const borderPoints = mask.getBorderPoints({\n        allowCorners: true,\n        innerBorders: false,\n    });\n    const result = [];\n    for (const point of borderPoints) {\n        result.push(point, { column: point.column + 1, row: point.row }, { column: point.column + 1, row: point.row + 1 }, { column: point.column, row: point.row + 1 });\n    }\n    return result;\n}\n//# sourceMappingURL=getExtendedBorderPoints.js.map","/**\n * Computes the convex hull of a binary image using Andrew's Monotone Chain Algorithm\n * @see {@link http://www.algorithmist.com/index.php/Monotone_Chain_Convex_Hull}\n * @param points - An array of points.\n * @param options - MCCH Algorithm options.\n * @returns Coordinates of the convex hull in clockwise order.\n */\nexport function monotoneChainConvexHull(points, options = {}) {\n    const { sorted = false } = options;\n    if (!sorted) {\n        points = points.slice();\n        points.sort(byXThenY);\n    }\n    const n = points.length;\n    const result = new Array(n * 2);\n    let k = 0;\n    for (let i = 0; i < n; i++) {\n        const point = points[i];\n        while (k >= 2 && cw(result[k - 2], result[k - 1], point) <= 0) {\n            k--;\n        }\n        result[k++] = point;\n    }\n    const t = k + 1;\n    for (let i = n - 2; i >= 0; i--) {\n        const point = points[i];\n        while (k >= t && cw(result[k - 2], result[k - 1], point) <= 0) {\n            k--;\n        }\n        result[k++] = point;\n    }\n    return result.slice(0, k - 1);\n}\nfunction cw(p1, p2, p3) {\n    return ((p2.row - p1.row) * (p3.column - p1.column) -\n        (p2.column - p1.column) * (p3.row - p1.row));\n}\nfunction byXThenY(point1, point2) {\n    if (point1.column === point2.column) {\n        return point1.row - point2.row;\n    }\n    return point1.column - point2.column;\n}\n// 0 -> column, 1 -> row\n//# sourceMappingURL=monotoneChainConvexHull.js.map","import { getPolygonArea, getPolygonPerimeter, } from '../utils/geometry/polygons.js';\nimport { getExtendedBorderPoints } from './utils/getExtendedBorderPoints.js';\nimport { monotoneChainConvexHull as mcch } from './utils/monotoneChainConvexHull.js';\n/**\n * Get the vertices of the convex Hull polygon of a mask.\n * @param mask - Mask to process.\n * @returns Array of the vertices of the convex Hull in clockwise order.\n */\nexport function getConvexHull(mask) {\n    const borderPoints = getExtendedBorderPoints(mask);\n    if (borderPoints.length === 0) {\n        return {\n            points: [],\n            surface: 0,\n            perimeter: 0,\n        };\n    }\n    const points = mcch(borderPoints);\n    const perimeter = getPolygonPerimeter(points);\n    const surface = getPolygonArea(points);\n    return { points, perimeter, surface };\n}\n//# sourceMappingURL=getConvexHull.js.map","import { toDegrees } from '../utils/geometry/angles.js';\nimport { rotate } from '../utils/geometry/points.js';\nimport { getAngle } from './utils/getAngle.js';\n/**\n * Computes the Feret diameters.\n * @see {@link https://www.sympatec.com/en/particle-measurement/glossary/particle-shape/#}\n * @see {@link http://portal.s2nano.org:8282/files/TEM_protocol_NANoREG.pdf}\n * @param mask - The mask of the ROI.\n * @returns The Feret diameters.\n */\nexport function getFeret(mask) {\n    const hull = mask.getConvexHull();\n    const hullPoints = hull.points;\n    if (hull.surface === 0) {\n        return {\n            minDiameter: {\n                length: 0,\n                points: [\n                    { column: 0, row: 0 },\n                    { column: 0, row: 0 },\n                ],\n                angle: 0,\n                calliperLines: [\n                    [\n                        { column: 0, row: 0 },\n                        { column: 0, row: 0 },\n                    ],\n                    [\n                        { column: 0, row: 0 },\n                        { column: 0, row: 0 },\n                    ],\n                ],\n            },\n            maxDiameter: {\n                length: 0,\n                points: [\n                    { column: 0, row: 0 },\n                    { column: 0, row: 0 },\n                ],\n                angle: 0,\n                calliperLines: [\n                    [\n                        { column: 0, row: 0 },\n                        { column: 0, row: 0 },\n                    ],\n                    [\n                        { column: 0, row: 0 },\n                        { column: 0, row: 0 },\n                    ],\n                ],\n            },\n            aspectRatio: 1,\n        };\n    }\n    // Compute minimum diameter\n    let minWidth = Number.POSITIVE_INFINITY;\n    let minWidthAngle = 0;\n    let minLinePoints = [];\n    let minLines;\n    for (let i = 0; i < hullPoints.length; i++) {\n        const angle = getAngle(hullPoints[i], hullPoints[(i + 1) % hullPoints.length]);\n        // We rotate so that it is parallel to X axis.\n        const rotatedPoints = rotate(-angle, hullPoints);\n        let currentWidth = 0;\n        let currentMinLinePoints = [];\n        for (let j = 0; j < hullPoints.length; j++) {\n            const absWidth = Math.abs(rotatedPoints[i].row - rotatedPoints[j].row);\n            if (absWidth > currentWidth) {\n                currentWidth = absWidth;\n                currentMinLinePoints = [rotatedPoints[i], rotatedPoints[j]];\n            }\n        }\n        if (currentWidth < minWidth) {\n            minWidth = currentWidth;\n            minWidthAngle = angle;\n            minLinePoints = currentMinLinePoints;\n            const { minIndex: currentMin, maxIndex: currentMax } = findPointIndexesOfExtremeColumns(rotatedPoints);\n            minLines = getMinLines(minWidthAngle, currentMin, currentMax, rotatedPoints, minLinePoints);\n        }\n    }\n    const minDiameter = {\n        points: rotate(minWidthAngle, minLinePoints),\n        length: minWidth,\n        angle: toDegrees(minWidthAngle),\n        calliperLines: minLines,\n    };\n    // Compute maximum diameter\n    let maxLinePoints = [];\n    let maxSquaredWidth = 0;\n    let maxLineIndex = [];\n    for (let i = 0; i < hullPoints.length - 1; i++) {\n        for (let j = i + 1; j < hullPoints.length; j++) {\n            const currentSquaredWidth = (hullPoints[i].column - hullPoints[j].column) ** 2 +\n                (hullPoints[i].row - hullPoints[j].row) ** 2;\n            if (currentSquaredWidth > maxSquaredWidth) {\n                maxSquaredWidth = currentSquaredWidth;\n                maxLinePoints = [hullPoints[i], hullPoints[j]];\n                maxLineIndex = [i, j];\n            }\n        }\n    }\n    const maxAngle = getAngle(maxLinePoints[0], maxLinePoints[1]);\n    const rotatedMaxPoints = rotate(-maxAngle, hullPoints);\n    const { minIndex: currentMin, maxIndex: currentMax } = findPointsIndexesOfExtremeRows(rotatedMaxPoints);\n    const maxLines = getMaxLines(maxAngle, currentMin, currentMax, rotatedMaxPoints, maxLineIndex);\n    const maxDiameter = {\n        length: Math.sqrt(maxSquaredWidth),\n        angle: toDegrees(getAngle(maxLinePoints[0], maxLinePoints[1])),\n        points: maxLinePoints,\n        calliperLines: maxLines,\n    };\n    return {\n        minDiameter,\n        maxDiameter,\n        aspectRatio: minDiameter.length / maxDiameter.length,\n    };\n}\nfunction findPointIndexesOfExtremeColumns(points) {\n    let maxIndex = 0;\n    let minIndex = 0;\n    for (let i = 0; i < points.length; i++) {\n        if (points[i].column > points[maxIndex].column) {\n            maxIndex = i;\n        }\n        if (points[i].column < points[minIndex].column) {\n            minIndex = i;\n        }\n    }\n    return { minIndex, maxIndex };\n}\nfunction findPointsIndexesOfExtremeRows(points) {\n    let maxIndex = 0;\n    let minIndex = 0;\n    for (let i = 0; i < points.length; i++) {\n        if (points[i].row > points[maxIndex].row) {\n            maxIndex = i;\n        }\n        if (points[i].row < points[minIndex].row) {\n            minIndex = i;\n        }\n    }\n    return { minIndex, maxIndex };\n}\nfunction getMinLines(angle, min, max, rotatedPoints, feretPoints) {\n    const minLine1 = [\n        { column: rotatedPoints[min].column, row: feretPoints[0].row },\n        {\n            column: rotatedPoints[max].column,\n            row: feretPoints[0].row,\n        },\n    ];\n    const minLine2 = [\n        {\n            column: rotatedPoints[min].column,\n            row: feretPoints[1].row,\n        },\n        {\n            column: rotatedPoints[max].column,\n            row: feretPoints[1].row,\n        },\n    ];\n    return [rotate(angle, minLine1), rotate(angle, minLine2)];\n}\nfunction getMaxLines(angle, min, max, rotatedPoints, index) {\n    const maxLine1 = [\n        { column: rotatedPoints[index[0]].column, row: rotatedPoints[min].row },\n        {\n            column: rotatedPoints[index[0]].column,\n            row: rotatedPoints[max].row,\n        },\n    ];\n    const maxLine2 = [\n        { column: rotatedPoints[index[1]].column, row: rotatedPoints[min].row },\n        {\n            column: rotatedPoints[index[1]].column,\n            row: rotatedPoints[max].row,\n        },\n    ];\n    return [rotate(angle, maxLine1), rotate(angle, maxLine2)];\n}\n//# sourceMappingURL=getFeret.js.map","import { toDegrees } from '../../utils/geometry/angles.js';\nimport { getAngle } from './getAngle.js';\nconst leftFirst = (mbrPoint1, mbrPoint2) => mbrPoint1.column <= mbrPoint2.column ? -1 : 1;\nconst topFirst = (mbrPoint1, mbrPoint2) => mbrPoint1.row >= mbrPoint2.row ? -1 : 1;\n/**\n * Get the anti-clockwise angle in degrees between the MBR and a horizontal line.\n * @param mbr - MBR to process.\n * @returns The angle in degrees.\n */\nexport function getMbrAngle(mbr) {\n    const sorted = mbr.slice();\n    sorted.sort(leftFirst);\n    const left = sorted.slice(0, 2);\n    const right = sorted.slice(2, 4);\n    left.sort(topFirst);\n    right.sort(topFirst);\n    const topLeft = left[0];\n    const topRight = right[0];\n    return -toDegrees(getAngle(topLeft, topRight));\n}\n//# sourceMappingURL=getMbrAngle.js.map","import { rotate } from '../../utils/geometry/points.js';\nimport { getAngle } from './getAngle.js';\nimport { getMbrAngle } from './getMbrAngle.js';\n/**\n * Get the four corners of the minimum bounding rectangle from a set of points defining a simple convex polygon.\n * @see {@link https://www.researchgate.net/profile/Lennert_Den_Boer2/publication/303783472_A_Fast_Algorithm_for_Generating_a_Minimal_Bounding_Rectangle/links/5751a14108ae6807fafb2aa5.pdf}\n * @param points - Points from which to compute the MBR.\n * @returns The array of corners.\n */\nexport function getMbrFromPoints(points) {\n    if (points.length === 0) {\n        return {\n            points: [],\n            angle: 0,\n            width: 0,\n            height: 0,\n            surface: 0,\n            perimeter: 0,\n            aspectRatio: 0,\n        };\n    }\n    if (points.length === 1) {\n        return {\n            points: [points[0], points[0], points[0], points[0]],\n            perimeter: 0,\n            surface: 0,\n            angle: 0,\n            width: 0,\n            height: 0,\n            aspectRatio: 1,\n        };\n    }\n    let rotatedVertices = [];\n    let minSurface = Number.POSITIVE_INFINITY;\n    let minSurfaceAngle = 0;\n    let mbr = [];\n    for (let i = 0; i < points.length; i++) {\n        const angle = getAngle(points[i], points[(i + 1) % points.length]);\n        rotatedVertices = rotate(-angle, points);\n        // Rotate and translate so that this segment is at the bottom.\n        const aX = rotatedVertices[i].column;\n        const aY = rotatedVertices[i].row;\n        const bX = rotatedVertices[(i + 1) % rotatedVertices.length].column;\n        const bY = rotatedVertices[(i + 1) % rotatedVertices.length].row;\n        let tUndefined = true;\n        let tMin = 0;\n        let tMax = 0;\n        let maxWidth = 0;\n        for (const point of rotatedVertices) {\n            const cX = point.column;\n            const cY = point.row;\n            const t = (cX - aX) / (bX - aX);\n            if (tUndefined) {\n                tUndefined = false;\n                tMin = t;\n                tMax = t;\n            }\n            else {\n                if (t < tMin)\n                    tMin = t;\n                if (t > tMax)\n                    tMax = t;\n            }\n            const width = (-(bX - aX) * cY + bX * aY - bY * aX) / (bX - aX);\n            if (Math.abs(width) > Math.abs(maxWidth)) {\n                maxWidth = width;\n            }\n        }\n        const minPoint = { column: aX + tMin * (bX - aX), row: aY };\n        const maxPoint = { column: aX + tMax * (bX - aX), row: aY };\n        const currentSurface = Math.abs(maxWidth * (tMin - tMax) * (bX - aX));\n        if (currentSurface < minSurface) {\n            minSurfaceAngle = angle;\n            minSurface = currentSurface;\n            mbr = [\n                maxPoint,\n                minPoint,\n                { column: minPoint.column, row: minPoint.row - maxWidth },\n                { column: maxPoint.column, row: maxPoint.row - maxWidth },\n            ];\n        }\n    }\n    const mbrRotated = rotate(minSurfaceAngle, mbr);\n    const sides = [\n        Math.hypot(mbr[0].column - mbr[1].column, mbr[0].row - mbr[1].row),\n        Math.hypot(mbr[0].column - mbr[3].column, mbr[0].row - mbr[3].row),\n    ];\n    const maxSide = Math.max(...sides);\n    const minSide = Math.min(...sides);\n    const mbrAngle = getMbrAngle(mbrRotated);\n    const ratio = minSide / maxSide;\n    return {\n        points: mbrRotated,\n        surface: minSurface,\n        angle: mbrAngle,\n        width: maxSide,\n        height: minSide,\n        perimeter: 2 * maxSide + 2 * minSide,\n        aspectRatio: ratio,\n    };\n}\n//# sourceMappingURL=getMbrFromPoints.js.map","import { getExtendedBorderPoints } from './utils/getExtendedBorderPoints.js';\nimport { getMbrFromPoints } from './utils/getMbrFromPoints.js';\nimport { monotoneChainConvexHull } from './utils/monotoneChainConvexHull.js';\n/**\n * Get the four corners of the minimum bounding rectangle of an ROI.\n * @param mask - The ROI to process.\n * @returns The array of corners.\n */\nexport function getMbr(mask) {\n    const vertices = monotoneChainConvexHull(getExtendedBorderPoints(mask));\n    return getMbrFromPoints(vertices);\n}\n//# sourceMappingURL=getMbr.js.map","/**\n * Checks the that the dimensions of the kernel are odd.\n * @param kernel - Kernel passed to a morphology function.\n */\nexport function checkKernel(kernel) {\n    if (kernel.length % 2 === 0 || kernel[0].length % 2 === 0) {\n        throw new TypeError('the number of rows and columns of the kernel must be odd');\n    }\n}\n//# sourceMappingURL=checkKernel.js.map","import { Image } from '../Image.js';\nimport { Mask } from '../Mask.js';\nimport { checkKernel } from '../utils/validators/checkKernel.js';\nimport checkProcessable from '../utils/validators/checkProcessable.js';\n/**\n * Erosion is one of two fundamental operations (with dilatation) in morphological\n * Image processing from which all other morphological operations are based (from Wikipedia).\n * Replaces each value with it's local minimum among the pixels with a kernel value of 1.\n * @see {@link http://docs.opencv.org/2.4/doc/tutorials/imgproc/erosion_dilatation/erosion_dilatation.html}\n * @see {@link https://en.wikipedia.org/wiki/Erosion_(morphology)}\n * @param image - The image to erode.\n * @param options - Erode options.\n * @returns - The eroded image.\n */\nexport function erode(image, options = {}) {\n    let defaultKernel = false;\n    if (options.kernel === undefined) {\n        defaultKernel = true;\n    }\n    const { kernel = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1],\n    ], iterations = 1, } = options;\n    if (image instanceof Image) {\n        checkProcessable(image, {\n            bitDepth: [1, 8, 16],\n            components: 1,\n            alpha: false,\n        });\n    }\n    checkKernel(kernel);\n    let onlyOnes = true;\n    if (!defaultKernel) {\n        outer: for (const row of kernel) {\n            for (const bit of row) {\n                if (bit !== 1) {\n                    onlyOnes = false;\n                    break outer;\n                }\n            }\n        }\n    }\n    let result = image;\n    for (let i = 0; i < iterations; i++) {\n        if (result instanceof Mask) {\n            if (onlyOnes) {\n                const newImage = result.clone();\n                result = erodeMaskOnlyOnes(result, newImage, kernel[0].length, kernel.length);\n            }\n            else {\n                const newImage = Mask.createFrom(image);\n                result = erodeMask(result, newImage, kernel);\n            }\n        }\n        else if (onlyOnes) {\n            const newImage = Image.createFrom(image);\n            result = erodeGreyOnlyOnes(result, newImage, kernel[0].length, kernel.length);\n        }\n        else {\n            const newImage = Image.createFrom(image);\n            result = erodeGrey(result, newImage, kernel);\n        }\n    }\n    return result;\n}\nfunction erodeGrey(img, newImage, kernel) {\n    const kernelWidth = kernel[0].length;\n    const kernelHeight = kernel.length;\n    const radiusX = (kernelWidth - 1) / 2;\n    const radiusY = (kernelHeight - 1) / 2;\n    for (let row = 0; row < img.height; row++) {\n        for (let column = 0; column < img.width; column++) {\n            let min = img.maxValue;\n            for (let kernelRow = 0; kernelRow < kernelHeight; kernelRow++) {\n                for (let kernelColumn = 0; kernelColumn < kernelWidth; kernelColumn++) {\n                    if (kernel[kernelRow][kernelColumn] !== 1)\n                        continue;\n                    const currentColumn = kernelColumn - radiusX + column;\n                    const currentRow = kernelRow - radiusY + row;\n                    if (currentColumn < 0 ||\n                        currentRow < 0 ||\n                        currentColumn >= img.width ||\n                        currentRow >= img.height) {\n                        continue;\n                    }\n                    const value = img.getValue(currentColumn, currentRow, 0);\n                    if (value < min)\n                        min = value;\n                }\n            }\n            newImage.setValue(column, row, 0, min);\n        }\n    }\n    return newImage;\n}\nfunction erodeGreyOnlyOnes(image, newImage, kernelWidth, kernelHeight) {\n    const radiusX = (kernelWidth - 1) / 2;\n    const radiusY = (kernelHeight - 1) / 2;\n    const minList = [];\n    for (let column = 0; column < image.width; column++) {\n        minList.push(0);\n    }\n    for (let row = 0; row < image.height; row++) {\n        for (let column = 0; column < image.width; column++) {\n            let min = image.maxValue;\n            for (let h = Math.max(0, row - radiusY); h < Math.min(image.height, row + radiusY + 1); h++) {\n                const value = image.getValue(column, h, 0);\n                if (value < min) {\n                    min = value;\n                }\n            }\n            minList[column] = min;\n        }\n        for (let column = 0; column < image.width; column++) {\n            let min = image.maxValue;\n            for (let i = Math.max(0, column - radiusX); i < Math.min(image.width, column + radiusX + 1); i++) {\n                if (minList[i] < min) {\n                    min = minList[i];\n                }\n            }\n            newImage.setValue(column, row, 0, min);\n        }\n    }\n    return newImage;\n}\nfunction erodeMask(mask, newMask, kernel) {\n    const kernelWidth = kernel[0].length;\n    const kernelHeight = kernel.length;\n    const radiusX = (kernelWidth - 1) / 2;\n    const radiusY = (kernelHeight - 1) / 2;\n    for (let row = 0; row < mask.height; row++) {\n        for (let column = 0; column < mask.width; column++) {\n            let min = 1;\n            for (let kernelRow = 0; kernelRow < kernelHeight; kernelRow++) {\n                for (let kernelColumn = 0; kernelColumn < kernelWidth; kernelColumn++) {\n                    if (kernel[kernelRow][kernelColumn] !== 1)\n                        continue;\n                    const currentColumn = kernelColumn - radiusX + column;\n                    const currentRow = kernelRow - radiusY + row;\n                    if (currentRow < 0 ||\n                        currentColumn < 0 ||\n                        currentColumn >= mask.width ||\n                        currentRow >= mask.height) {\n                        continue;\n                    }\n                    const value = mask.getBit(currentColumn, currentRow);\n                    if (value === 0) {\n                        min = 0;\n                        break;\n                    }\n                }\n            }\n            if (min === 1) {\n                newMask.setBit(column, row, 1);\n            }\n        }\n    }\n    return newMask;\n}\nfunction erodeMaskOnlyOnes(mask, newMask, kernelWidth, kernelHeight) {\n    const radiusX = (kernelWidth - 1) / 2;\n    const radiusY = (kernelHeight - 1) / 2;\n    const minList = [];\n    for (let column = 0; column < mask.width; column++) {\n        minList.push(0);\n    }\n    for (let row = 0; row < mask.height; row++) {\n        for (let column = 0; column < mask.width; column++) {\n            minList[column] = 1;\n            for (let h = Math.max(0, row - radiusY); h < Math.min(mask.height, row + radiusY + 1); h++) {\n                if (mask.getBit(column, h) === 0) {\n                    minList[column] = 0;\n                    break;\n                }\n            }\n        }\n        for (let column = 0; column < mask.width; column++) {\n            if (newMask.getBit(column, row) === 0)\n                continue;\n            for (let i = Math.max(0, column - radiusX); i < Math.min(mask.width, column + radiusX + 1); i++) {\n                if (minList[i] === 0) {\n                    newMask.setBit(column, row, 0);\n                    break;\n                }\n            }\n        }\n    }\n    return newMask;\n}\n//# sourceMappingURL=erode.js.map","import { Image } from '../Image.js';\nimport { Mask } from '../Mask.js';\nimport { checkKernel } from '../utils/validators/checkKernel.js';\nimport checkProcessable from '../utils/validators/checkProcessable.js';\n/**\n * Dilatation is one of two fundamental operations (with erosion) in morphological\n * image processing from which all other morphological operations are based (from Wikipedia).\n * Replaces each value with it's local maximum among the pixels with a kernel value of 1.\n * @see {@link http://docs.opencv.org/2.4/doc/tutorials/imgproc/erosion_dilatation/erosion_dilatation.html}\n * @see {@link https://en.wikipedia.org/wiki/Dilation_(morphology)}\n * @param image - Image to dilate.\n * @param options - Dilate options.\n * @returns Dilated image.\n */\nexport function dilate(image, options = {}) {\n    let defaultKernel = false;\n    if (options.kernel === undefined) {\n        defaultKernel = true;\n    }\n    const { kernel = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1],\n    ], iterations = 1, } = options;\n    if (image instanceof Image) {\n        checkProcessable(image, {\n            bitDepth: [1, 8, 16],\n            components: 1,\n            alpha: false,\n        });\n    }\n    checkKernel(kernel);\n    let onlyOnes = true;\n    if (!defaultKernel) {\n        outer: for (const row of kernel) {\n            for (const value of row) {\n                if (value !== 1) {\n                    onlyOnes = false;\n                    break outer;\n                }\n            }\n        }\n    }\n    let result = image;\n    for (let i = 0; i < iterations; i++) {\n        if (result instanceof Mask) {\n            if (onlyOnes) {\n                const newMask = result.clone();\n                result = dilatMaskOnlyOnes(result, newMask, kernel[0].length, kernel.length);\n            }\n            else {\n                const newMask = Mask.createFrom(result);\n                result = dilateMask(result, newMask, kernel);\n            }\n        }\n        else if (onlyOnes) {\n            const newImage = Image.createFrom(result);\n            result = dilateGreyOnlyOnes(result, newImage, kernel[0].length, kernel.length);\n        }\n        else {\n            const newImage = Image.createFrom(result);\n            result = dilateGrey(result, newImage, kernel);\n        }\n    }\n    return result;\n}\nfunction dilateGrey(image, newImage, kernel) {\n    const kernelWidth = kernel[0].length;\n    const kernelHeight = kernel.length;\n    const radiusX = (kernelWidth - 1) / 2;\n    const radiusY = (kernelHeight - 1) / 2;\n    for (let row = 0; row < image.height; row++) {\n        for (let column = 0; column < image.width; column++) {\n            let max = 0;\n            for (let kernelRow = 0; kernelRow < kernelHeight; kernelRow++) {\n                for (let kernelColumn = 0; kernelColumn < kernelWidth; kernelColumn++) {\n                    if (kernel[kernelRow][kernelColumn] !== 1)\n                        continue;\n                    const currentColumn = kernelColumn - radiusX + column;\n                    const currentRow = kernelRow - radiusY + row;\n                    if (currentColumn < 0 ||\n                        currentRow < 0 ||\n                        currentColumn >= image.width ||\n                        currentRow >= image.height) {\n                        continue;\n                    }\n                    const value = image.getValue(currentColumn, currentRow, 0);\n                    if (value > max)\n                        max = value;\n                }\n            }\n            newImage.setValue(column, row, 0, max);\n        }\n    }\n    return newImage;\n}\nfunction dilateGreyOnlyOnes(image, newImage, kernelWidth, kernelHeight) {\n    const radiusX = (kernelWidth - 1) / 2;\n    const radiusY = (kernelHeight - 1) / 2;\n    const maxList = [];\n    for (let column = 0; column < image.width; column++) {\n        maxList.push(0);\n    }\n    for (let row = 0; row < image.height; row++) {\n        for (let column = 0; column < image.width; column++) {\n            let max = 0;\n            for (let h = Math.max(0, row - radiusY); h < Math.min(image.height, row + radiusY + 1); h++) {\n                const value = image.getValue(column, h, 0);\n                if (value > max) {\n                    max = value;\n                }\n            }\n            maxList[column] = max;\n        }\n        for (let column = 0; column < image.width; column++) {\n            let max = 0;\n            for (let i = Math.max(0, column - radiusX); i < Math.min(image.width, column + radiusX + 1); i++) {\n                if (maxList[i] > max) {\n                    max = maxList[i];\n                }\n            }\n            newImage.setValue(column, row, 0, max);\n        }\n    }\n    return newImage;\n}\nfunction dilateMask(mask, newMask, kernel) {\n    const kernelWidth = kernel[0].length;\n    const kernelHeight = kernel.length;\n    const radiusX = (kernelWidth - 1) / 2;\n    const radiusY = (kernelHeight - 1) / 2;\n    for (let row = 0; row < mask.height; row++) {\n        for (let column = 0; column < mask.width; column++) {\n            let max = 0;\n            for (let kernelRow = 0; kernelRow < kernelHeight; kernelRow++) {\n                for (let kernelColumn = 0; kernelColumn < kernelWidth; kernelColumn++) {\n                    if (kernel[kernelRow][kernelColumn] !== 1)\n                        continue;\n                    const currentColumn = kernelColumn - radiusX + column;\n                    const currentRow = kernelRow - radiusY + row;\n                    if (currentRow < 0 ||\n                        currentColumn < 0 ||\n                        currentColumn >= mask.width ||\n                        currentRow >= mask.height) {\n                        continue;\n                    }\n                    const value = mask.getBit(currentColumn, currentRow);\n                    if (value === 1) {\n                        max = 1;\n                        break;\n                    }\n                }\n            }\n            if (max === 1) {\n                newMask.setBit(column, row, 1);\n            }\n        }\n    }\n    return newMask;\n}\nfunction dilatMaskOnlyOnes(mask, newMask, kernelWidth, kernelHeight) {\n    const radiusX = (kernelWidth - 1) / 2;\n    const radiusY = (kernelHeight - 1) / 2;\n    const maxList = [];\n    for (let column = 0; column < mask.width; column++) {\n        maxList.push(1);\n    }\n    for (let row = 0; row < mask.height; row++) {\n        for (let column = 0; column < mask.width; column++) {\n            maxList[column] = 0;\n            for (let h = Math.max(0, row - radiusY); h < Math.min(mask.height, row + radiusY + 1); h++) {\n                if (mask.getBit(column, h) === 1) {\n                    maxList[column] = 1;\n                    break;\n                }\n            }\n        }\n        for (let column = 0; column < mask.width; column++) {\n            if (newMask.getBit(column, row) === 1)\n                continue;\n            for (let i = Math.max(0, column - radiusX); i < Math.min(mask.width, column + radiusX + 1); i++) {\n                if (maxList[i] === 1) {\n                    newMask.setBit(column, row, 1);\n                    break;\n                }\n            }\n        }\n    }\n    return newMask;\n}\n//# sourceMappingURL=dilate.js.map","import { Image } from '../Image.js';\nimport { checkKernel } from '../utils/validators/checkKernel.js';\nimport checkProcessable from '../utils/validators/checkProcessable.js';\n/**\n * In mathematical morphology, opening is the dilation of the erosion of a set A by a structuring element B.\n * Together with closing, the opening serves in computer vision and image processing as a basic workhorse of morphological noise removal.\n * Opening removes small objects from the foreground (usually taken as the bright pixels) of an image,\n * placing them in the background, while closing removes small holes in the foreground, changing small islands of background into foreground. (Wikipedia)\n * @see {@link http://docs.opencv.org/2.4/doc/tutorials/imgproc/opening_closing_hats/opening_closing_hats.html}\n * @param image - Image to process.\n * @param options - Open options.\n * @returns The opened image.\n */\nexport function open(image, options = {}) {\n    const { kernel = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1],\n    ], iterations = 1, } = options;\n    if (image instanceof Image) {\n        checkProcessable(image, {\n            bitDepth: [1, 8, 16],\n            components: 1,\n            alpha: false,\n        });\n    }\n    checkKernel(kernel);\n    let newImage = image;\n    for (let i = 0; i < iterations; i++) {\n        newImage = newImage.erode({ kernel });\n        newImage = newImage.dilate({ kernel });\n    }\n    return newImage;\n}\n//# sourceMappingURL=open.js.map","import { Image } from '../Image.js';\nimport { checkKernel } from '../utils/validators/checkKernel.js';\nimport checkProcessable from '../utils/validators/checkProcessable.js';\n/**\n * In mathematical morphology, the closing of a set A by a structuring element B is the erosion of the dilation of that set (Wikipedia).\n * In image processing, closing is, together with opening, the basic workhorse of morphological noise removal.\n * Opening removes small objects, while closing removes small holes.\n * @see {@link http://docs.opencv.org/2.4/doc/tutorials/imgproc/opening_closing_hats/opening_closing_hats.html}\n * @param image - Image to process.\n * @param options - Close options.\n * @returns Closed image.\n */\nexport function close(image, options = {}) {\n    const { kernel = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1],\n    ], iterations = 1, } = options;\n    if (image instanceof Image) {\n        checkProcessable(image, {\n            bitDepth: [1, 8, 16],\n            components: 1,\n            alpha: false,\n        });\n    }\n    checkKernel(kernel);\n    let newImage = image;\n    for (let i = 0; i < iterations; i++) {\n        newImage = newImage.dilate({ kernel }).erode({ kernel });\n    }\n    return newImage;\n}\n//# sourceMappingURL=close.js.map","import { Image } from '../Image.js';\nimport { subtract } from '../compare/index.js';\nimport { checkKernel } from '../utils/validators/checkKernel.js';\nimport checkProcessable from '../utils/validators/checkProcessable.js';\n/**\n * This function is the white top hat (also called top hat). In mathematical morphology and digital image processing,\n * top-hat transform is an operation that extracts small elements and details from given images.\n * The white top-hat transform is defined as the difference between the input image and its opening by some structuring element.\n * Top-hat transforms are used for various image processing tasks, such as feature extraction, background equalization, image enhancement, and others. (Wikipedia)\n * @see {@link http://docs.opencv.org/2.4/doc/tutorials/imgproc/opening_closing_hats/opening_closing_hats.html}\n * @param image - Image to process.\n * @param options - Top hat options.\n * @returns The top-hatted image.\n */\nexport function topHat(image, options = {}) {\n    const { kernel = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1],\n    ], iterations = 1, } = options;\n    if (image instanceof Image) {\n        checkProcessable(image, {\n            bitDepth: [1, 8, 16],\n            components: 1,\n            alpha: false,\n        });\n    }\n    checkKernel(kernel);\n    let newImage = image;\n    for (let i = 0; i < iterations; i++) {\n        const openImage = newImage.open({ kernel });\n        newImage = subtract(openImage, newImage, { absolute: true });\n    }\n    return newImage;\n}\n//# sourceMappingURL=topHat.js.map","import { Image } from '../Image.js';\nimport { subtract } from '../compare/index.js';\nimport { checkKernel } from '../utils/validators/checkKernel.js';\nimport checkProcessable from '../utils/validators/checkProcessable.js';\n/**\n * This function is the black top hat (also called bottom hat).\n * In mathematical morphology and digital image processing,\n * top-hat transform is an operation that extracts small elements and details from given images.\n * The black top-hat transform is defined dually as the difference between the closed and the input image.\n * Top-hat transforms are used for various image processing tasks, such as feature extraction, background equalization,\n * image enhancement, and others. (Wikipedia)\n * @see {@link http://docs.opencv.org/2.4/doc/tutorials/imgproc/opening_closing_hats/opening_closing_hats.html}\n * @param image - Image to process.\n * @param options - Bottom hat options.\n * @returns The bottom-hatted image.\n */\nexport function bottomHat(image, options = {}) {\n    const { kernel = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1],\n    ], iterations = 1, } = options;\n    if (image instanceof Image) {\n        checkProcessable(image, {\n            bitDepth: [1, 8, 16],\n            components: 1,\n            alpha: false,\n        });\n    }\n    checkKernel(kernel);\n    let newImage = image;\n    for (let i = 0; i < iterations; i++) {\n        const openImage = newImage.close({ kernel });\n        newImage = subtract(openImage, newImage, { absolute: true });\n    }\n    return newImage;\n}\n//# sourceMappingURL=bottomHat.js.map","import { Image } from '../Image.js';\nimport { subtract } from '../compare/index.js';\nimport { checkKernel } from '../utils/validators/checkKernel.js';\nimport checkProcessable from '../utils/validators/checkProcessable.js';\n/**\n * In mathematical morphology and digital image processing, a morphological gradient is the difference between the dilation and the erosion of a given image. It is an image where each pixel value (typically non-negative) indicates the contrast intensity in the close neighborhood of that pixel. It is useful for edge detection and segmentation applications.\n * @see {@link http://docs.opencv.org/2.4/doc/tutorials/imgproc/opening_closing_hats/opening_closing_hats.html}\n * @param image - Image to process.\n * @param options - Morphological gradient hat options.\n * @returns The processed image.\n */\nexport function morphologicalGradient(image, options = {}) {\n    const { kernel = [\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1],\n    ], iterations = 1, } = options;\n    if (image instanceof Image) {\n        checkProcessable(image, {\n            bitDepth: [1, 8, 16],\n            components: 1,\n            alpha: false,\n        });\n    }\n    checkKernel(kernel);\n    let newImage = image;\n    for (let i = 0; i < iterations; i++) {\n        const dilatedImage = newImage.dilate({ kernel });\n        const erodedImage = newImage.erode({ kernel });\n        newImage = subtract(dilatedImage, erodedImage, { absolute: true });\n    }\n    return newImage;\n}\n//# sourceMappingURL=morphologicalGradient.js.map","/**\n * Create function that allows to iterate on the pixels of the border of an image.\n * @param image - Image for which to create the border iterator.\n * @yields - Index of the border pixel.\n */\nexport function* borderIterator(image) {\n    for (let col = 0; col < image.width; col++) {\n        yield col;\n    }\n    for (let row = 2; row < image.height; row++) {\n        yield row * image.width - 1;\n    }\n    for (let col = 0; col < image.width; col++) {\n        yield image.width * image.height - col - 1;\n    }\n    for (let row = image.height - 2; row >= 1; row--) {\n        yield row * image.width;\n    }\n}\n//# sourceMappingURL=borderIterator.js.map","import { Mask } from '../Mask.js';\nimport { maskToOutputMask } from '../utils/getOutputImage.js';\nimport { assert } from '../utils/validators/assert.js';\nconst MAX_ARRAY = 65536; // 65536 should be enough for most of the cases\nconst toProcess = new Uint32Array(MAX_ARRAY);\n/**\n * Set the pixels connected to the border of the mask to zero. You can chose to allow corner connection of not with the `allowCorners` option.\n * @param mask - The mask to process.\n * @param options - Clear border options.\n * @returns The image with cleared borders.\n */\nexport function multipleFloodFill(mask, options = {}) {\n    const { startPixels = [0], startPixelValue = 0, newPixelValue = 1, allowCorners = false, } = options;\n    const newMask = maskToOutputMask(mask, options, { clone: true });\n    const alreadyConsidered = Mask.createFrom(mask);\n    let from = 0;\n    let to = 0;\n    // const startPixelValue = mask.getBitByIndex(startPixels[0]);\n    // find relevant border pixels\n    for (const pixelIndex of startPixels) {\n        if (newMask.getBitByIndex(pixelIndex) === startPixelValue) {\n            toProcess[to++ % MAX_ARRAY] = pixelIndex;\n            alreadyConsidered.setBitByIndex(pixelIndex, 1);\n            newMask.setBitByIndex(pixelIndex, newPixelValue);\n        }\n    }\n    // find pixels connected to the border pixels\n    while (from < to) {\n        assert(to - from <= MAX_ARRAY);\n        const currentPixel = toProcess[from++ % MAX_ARRAY];\n        newMask.setBitByIndex(currentPixel, newPixelValue);\n        // check if pixel is on a border\n        const topBorder = currentPixel < mask.width;\n        const leftBorder = currentPixel % mask.width === 0;\n        const rightBorder = currentPixel % mask.width === mask.width - 1;\n        const bottomBorder = currentPixel > mask.size - mask.width;\n        // check neighbors\n        if (!bottomBorder) {\n            const bottom = currentPixel + mask.width;\n            addToProcess(bottom);\n        }\n        if (!leftBorder) {\n            const left = currentPixel - 1;\n            addToProcess(left);\n        }\n        if (!topBorder) {\n            const top = currentPixel - mask.width;\n            addToProcess(top);\n        }\n        if (!rightBorder) {\n            const right = currentPixel + 1;\n            addToProcess(right);\n        }\n        if (allowCorners) {\n            if (!topBorder) {\n                if (!leftBorder) {\n                    const topLeft = currentPixel - mask.width - 1;\n                    addToProcess(topLeft);\n                }\n                if (!rightBorder) {\n                    const topRight = currentPixel - mask.width + 1;\n                    addToProcess(topRight);\n                }\n            }\n            if (!bottomBorder) {\n                if (!leftBorder) {\n                    const bottomLeft = currentPixel + mask.width - 1;\n                    addToProcess(bottomLeft);\n                }\n                if (!rightBorder) {\n                    const bottomRight = currentPixel + mask.width + 1;\n                    addToProcess(bottomRight);\n                }\n            }\n        }\n    }\n    function addToProcess(pixel) {\n        if (alreadyConsidered.getBitByIndex(pixel))\n            return;\n        if (newMask.getBitByIndex(pixel) === startPixelValue) {\n            toProcess[to++ % MAX_ARRAY] = pixel;\n            alreadyConsidered.setBitByIndex(pixel, 1);\n        }\n    }\n    return newMask;\n}\n//# sourceMappingURL=multipleFloodFill.js.map","import { borderIterator } from '../utils/borderIterator.js';\nimport { multipleFloodFill } from './multipleFloodFill.js';\n/**\n * Set the pixels connected to the border of the mask to zero. You can chose to allow corner connection of not with the `allowCorners` option.\n * @param mask - The mask to process.\n * @param options - Clear border options.\n * @returns The image with cleared borders.\n */\nexport function clearBorder(mask, options = {}) {\n    const { allowCorners = false, out, color = 'white' } = options;\n    return multipleFloodFill(mask, {\n        startPixels: borderIterator(mask),\n        startPixelValue: color === 'white' ? 1 : 0,\n        newPixelValue: color === 'white' ? 0 : 1,\n        allowCorners,\n        out,\n    });\n}\n//# sourceMappingURL=clearBorder.js.map","import { getIndex } from '../utils/getIndex.js';\nimport { imageToOutputMask } from '../utils/getOutputImage.js';\nimport checkProcessable from '../utils/validators/checkProcessable.js';\nconst kernelX = [\n    [-1, 0, 1],\n    [-2, 0, 2],\n    [-1, 0, 1],\n];\nconst kernelY = [\n    [-1, -2, -1],\n    [0, 0, 0],\n    [1, 2, 1],\n];\n/**\n * Apply Canny edge detection to an image.\n * @param image - Image to process.\n * @param options - Canny edge detection options.\n * @returns The processed image.\n */\nexport function cannyEdgeDetector(image, options = {}) {\n    const { hysteresis = true, lowThreshold = 0.04, highThreshold = 0.1, gaussianBlurOptions = { sigma: 1 }, } = options;\n    const minValue = lowThreshold * image.maxValue;\n    const maxValue = highThreshold * image.maxValue;\n    checkProcessable(image, {\n        colorModel: 'GREY',\n    });\n    const width = image.width;\n    const height = image.height;\n    const blurred = image.gaussianBlur(gaussianBlurOptions);\n    const gradientX = blurred.rawDirectConvolution(kernelY);\n    const gradientY = blurred.rawDirectConvolution(kernelX);\n    const gradient = new Float64Array(image.size);\n    for (let i = 0; i < image.size; i++) {\n        gradient[i] = Math.hypot(gradientX[i], gradientY[i]);\n    }\n    const nonMaxSuppression = new Float64Array(image.size);\n    const edges = new Float64Array(image.size);\n    const finalImage = imageToOutputMask(image, options);\n    // Non-Maximum suppression\n    for (let column = 1; column < width - 1; column++) {\n        for (let row = 1; row < height - 1; row++) {\n            const currentGradientX = gradientX[getIndex(column, row, image, 0)];\n            const currentGradientY = gradientY[getIndex(column, row, image, 0)];\n            const direction = getDirection(currentGradientX, currentGradientY);\n            const currentGradient = gradient[getIndex(column, row, image, 0)];\n            if (\n            // horizontal\n            (direction === 0 &&\n                currentGradient >= gradient[getIndex(column, row - 1, image, 0)] &&\n                currentGradient >= gradient[getIndex(column, row + 1, image, 0)]) ||\n                // upward slope\n                (direction === 1 &&\n                    currentGradient >=\n                        gradient[getIndex(column - 1, row - 1, image, 0)] &&\n                    currentGradient >=\n                        gradient[getIndex(column + 1, row + 1, image, 0)]) ||\n                // vertical\n                (direction === 2 &&\n                    currentGradient >= gradient[getIndex(column - 1, row, image, 0)] &&\n                    currentGradient >= gradient[getIndex(column + 1, row, image, 0)]) ||\n                // downward slope\n                (direction === 3 &&\n                    currentGradient >=\n                        gradient[getIndex(column - 1, row + 1, image, 0)] &&\n                    currentGradient >= gradient[getIndex(column + 1, row - 1, image, 0)])) {\n                // pixels to remove from the final image\n                nonMaxSuppression[getIndex(column, row, image, 0)] = currentGradient;\n            }\n        }\n    }\n    for (let i = 0; i < width * height; ++i) {\n        const currentNms = nonMaxSuppression[i];\n        let currentEdge = 0;\n        if (currentNms > maxValue) {\n            currentEdge++;\n            finalImage.setBitByIndex(i, 1);\n        }\n        if (currentNms > minValue) {\n            currentEdge++;\n        }\n        edges[i] = currentEdge;\n    }\n    // Hysteresis: first pass\n    if (hysteresis) {\n        let currentPixels = [];\n        for (let column = 1; column < width - 1; ++column) {\n            for (let row = 1; row < height - 1; ++row) {\n                if (edges[getIndex(column, row, image, 0)] !== 1) {\n                    continue;\n                }\n                outer: for (let hystColumn = column - 1; hystColumn < column + 2; ++hystColumn) {\n                    for (let hystRow = row - 1; hystRow < row + 2; ++hystRow) {\n                        if (edges[getIndex(hystColumn, hystRow, image, 0)] === 2) {\n                            currentPixels.push([column, row]);\n                            finalImage.setValue(column, row, 0, 1);\n                            break outer;\n                        }\n                    }\n                }\n            }\n        }\n        // Hysteresis: second pass\n        while (currentPixels.length > 0) {\n            const newPixels = [];\n            for (const currentPixel of currentPixels) {\n                for (let j = -1; j < 2; ++j) {\n                    for (let k = -1; k < 2; ++k) {\n                        if (j === 0 && k === 0) {\n                            continue;\n                        }\n                        const row = currentPixel[0] + j;\n                        const column = currentPixel[1] + k;\n                        if (\n                        // there could be an error here\n                        edges[getIndex(column, row, image, 0)] === 1 &&\n                            finalImage.getValue(column, row, 0) === 0) {\n                            newPixels.push([row, column]);\n                            finalImage.setValue(column, row, 0, 1);\n                        }\n                    }\n                }\n            }\n            currentPixels = newPixels;\n        }\n    }\n    return finalImage;\n    /* Function for debug\n    import { Matrix } from 'ml-matrix';\n  \n    function printArray(array: Float64Array): void {\n      // @ts-expect-error: only for debug\n      const matrix = Matrix.from1DArray(height, width, array);\n      console.log(matrix);\n    }\n    */\n}\n/**\n * Return a 0 to 3 value indicating the four main directions (horizontal, upward diagonal, vertical, downward diagonal).\n * @param x - The x coordinate.\n * @param y - The y coordinate.\n * @returns The direction as a 0 to 4 value.\n */\nexport function getDirection(x, y) {\n    return (Math.round(Math.atan2(y, x) * (4 / Math.PI)) + 4) % 4;\n}\n//# sourceMappingURL=cannyEdgeDetector.js.map","import { getIndex } from '../utils/getIndex.js';\nimport { multipleFloodFill } from './multipleFloodFill.js';\n/**\n * Apply a flood fill algorithm to an image.\n * @param mask - Mask to process.\n * @param options - Flood fill options.\n * @returns The filled mask.\n */\nexport function floodFill(mask, options = {}) {\n    const { origin = { row: 0, column: 0 }, allowCorners = false, out } = options;\n    const startPixel = getIndex(origin.column, origin.row, mask);\n    return multipleFloodFill(mask, {\n        startPixels: [startPixel],\n        allowCorners,\n        out,\n    });\n}\n//# sourceMappingURL=floodFill.js.map","import { maskToOutputMask } from '../utils/getOutputImage.js';\n/**\n * Fill holes in regions of interest.\n * @param mask - Mask to process.\n * @param options - Flood fill options.\n * @returns The filled mask.\n */\nexport function solidFill(mask, options = {}) {\n    const { allowCorners = false } = options;\n    const newImage = maskToOutputMask(mask, options, { clone: true });\n    const inverted = mask.invert();\n    const cleared = inverted.clearBorder({ allowCorners });\n    return newImage.or(cleared, { out: newImage });\n}\n//# sourceMappingURL=solidFill.js.map","/**\n * Converts a bit value to the corresponding number.\n * @param value - The bit to convert.\n * @returns The bit value as a number.\n */\nexport function boolToNumber(value) {\n    let result;\n    if (typeof value === 'boolean') {\n        result = value ? 1 : 0;\n    }\n    else {\n        result = value;\n    }\n    return result;\n}\n//# sourceMappingURL=boolToNumber.js.map","import { subtract } from './compare/index.js';\nimport { drawLineOnMask, drawPoints, drawPolygonOnMask, drawPolylineOnMask, drawRectangle, } from './draw/index.js';\nimport { and, invert, or } from './filters/index.js';\nimport { getBorderPoints } from './maskAnalysis/getBorderPoints.js';\nimport { getConvexHull } from './maskAnalysis/getConvexHull.js';\nimport { getFeret } from './maskAnalysis/getFeret.js';\nimport { getMbr } from './maskAnalysis/getMbr.js';\nimport { bottomHat, clearBorder, close, dilate, erode, floodFill, morphologicalGradient, open, solidFill, topHat, } from './morphology/index.js';\nimport { convertColor, copyTo, paintMaskOnMask } from './operations/index.js';\nimport { boolToNumber } from './utils/boolToNumber.js';\nimport { colorModels } from './utils/constants/colorModels.js';\nexport class Mask {\n    /**\n     * The number of columns of the mask.\n     */\n    width;\n    /**\n     * The number of rows of the mask.\n     */\n    height;\n    /**\n     * The total number of bits in the mask (width  height).\n     */\n    size;\n    /**\n     * The number of bits per value in each channel (always 1).\n     */\n    bitDepth;\n    /**\n     * The color model of the mask (always BINARY).\n     */\n    colorModel;\n    /**\n     * The number of color channels in the image, excluding the alpha channel (always 1).\n     */\n    components;\n    /**\n     * The number of channels in the mask, including the alpha channel (always 1).\n     */\n    channels;\n    /**\n     * Specifying that the mask has no an alpha channel.\n     */\n    alpha;\n    /**\n     * The maximum value that a pixel channel can have.\n     */\n    maxValue;\n    /**\n     * Origin of the image relative to a the parent image.\n     */\n    origin;\n    /**\n     * Typed array holding the mask data.\n     */\n    data;\n    /**\n     * Construct a new Mask knowing its dimensions.\n     * @param width - Image width.\n     * @param height - Image height.\n     * @param options - Image options.\n     */\n    constructor(width, height, options = {}) {\n        const { data, origin = { row: 0, column: 0 } } = options;\n        if (width < 1 || !Number.isInteger(width)) {\n            throw new RangeError(`width must be an integer and at least 1. Received ${width}`);\n        }\n        if (height < 1 || !Number.isInteger(height)) {\n            throw new RangeError(`height must be an integer and at least 1. Received ${height}`);\n        }\n        this.width = width;\n        this.height = height;\n        this.size = width * height;\n        this.bitDepth = 1;\n        this.colorModel = 'BINARY';\n        this.origin = origin;\n        const colorModelDef = colorModels[this.colorModel];\n        this.components = colorModelDef.components;\n        this.alpha = colorModelDef.alpha;\n        this.channels = colorModelDef.channels;\n        this.maxValue = 1;\n        if (data === undefined) {\n            this.data = new Uint8Array(this.size);\n        }\n        else {\n            const expectedLength = this.size * this.channels;\n            if (data.length !== expectedLength) {\n                throw new RangeError(`incorrect data size: ${data.length}. Expected ${expectedLength}`);\n            }\n            this.data = data;\n        }\n    }\n    /**\n     * Create a new Mask based on the properties of an existing one.\n     * @param other - Reference Mask.\n     * @param options - Mask options.\n     * @returns New mask.\n     */\n    static createFrom(other, options = {}) {\n        const { width = other.width, height = other.height, origin = other.origin, } = options;\n        return new Mask(width, height, { origin, ...options });\n    }\n    /**\n     * Get a pixel of the mask.\n     * @param column - Column index.\n     * @param row - Row index.\n     * @returns The pixel.\n     */\n    getPixel(column, row) {\n        const result = [];\n        const index = row * this.width + column;\n        result.push(this.data[index]);\n        return result;\n    }\n    /**\n     * Set a pixel.\n     * @param column - Column index.\n     * @param row - Row index.\n     * @param value - The pixel value.\n     */\n    setPixel(column, row, value) {\n        const index = row * this.width + column;\n        this.data[index] = value[0];\n    }\n    /**\n     * Set a pixel to a given value if the coordinates are inside the mask.\n     * @param column - Column index.\n     * @param row - Row index.\n     * @param value - New color of the pixel to set.\n     */\n    setVisiblePixel(column, row, value) {\n        if (column >= 0 && column < this.width && row >= 0 && row < this.height) {\n            this.setPixel(column, row, value);\n        }\n    }\n    /**\n     * Get a pixel using its index.\n     * @param index - Index of the pixel.\n     * @returns The pixel.\n     */\n    getPixelByIndex(index) {\n        return [this.data[index]];\n    }\n    /**\n     * Set a pixel using its index.\n     * @param index - Index of the pixel.\n     * @param value - New value of the pixel to set.\n     */\n    setPixelByIndex(index, value) {\n        this.data[index] = value[0];\n    }\n    /**\n     * Create a mask from an array of points.\n     * @param width - Width of the mask.\n     * @param height - Height of the mask.\n     * @param points - Reference Mask.\n     * @returns New mask.\n     */\n    static fromPoints(width, height, points) {\n        const mask = new Mask(width, height);\n        for (const point of points) {\n            mask.setBit(point.column, point.row, 1);\n        }\n        return mask;\n    }\n    /**\n     * Create a copy of this mask.\n     * @returns The mask clone.\n     */\n    clone() {\n        return Mask.createFrom(this, { data: this.data.slice() });\n    }\n    /**\n     * Get the value of a bit.\n     * @param column - Column index.\n     * @param row - Row index.\n     * @returns The bit value.\n     */\n    getBit(column, row) {\n        const index = row * this.width + column;\n        return this.data[index];\n    }\n    /**\n     * Set the value of a bit.\n     * @param column - Column index.\n     * @param row - Row index.\n     * @param value - New bit value.\n     */\n    setBit(column, row, value) {\n        const index = row * this.width + column;\n        // @ts-expect-error: we know that value is a boolean\n        this.data[index] = value;\n    }\n    /**\n     * Get the value of a bit using index.\n     * @param index - Index of the pixel.\n     * @returns Value of the bit.\n     */\n    getBitByIndex(index) {\n        return this.data[index * this.channels];\n    }\n    /**\n     * Set the value of a bit using index.\n     * @param index - Index of the pixel.\n     * @param value - Value to set.\n     */\n    setBitByIndex(index, value) {\n        this.data[index * this.channels] = boolToNumber(value);\n    }\n    /**\n     * Get the number of pixels that do not have the value 0.\n     * @returns The number of non-zero pixels.\n     */\n    getNbNonZeroPixels() {\n        let count = 0;\n        for (const datum of this.data) {\n            if (datum) {\n                count++;\n            }\n        }\n        return count;\n    }\n    /**\n     * Get the value of a bit. Function exists for compatibility with Image.\n     * @param column - Column index.\n     * @param row - Row index.\n     * @param channel - Index of the channel, must be zero.\n     * @returns The bit value.\n     */\n    getValue(column, row, channel) {\n        checkChannel(channel);\n        return this.getBit(column, row);\n    }\n    /**\n     * Set the value of a bit. Function exists for compatibility with Image.\n     * @param column - Column index.\n     * @param row - Row index.\n     * @param channel - Index of the channel, must be zero.\n     * @param value - New bit value.\n     */\n    setValue(column, row, channel, value) {\n        checkChannel(channel);\n        this.setBit(column, row, value);\n    }\n    /**\n     * Get the value of a bit using index. Function exists for compatibility with Image.\n     * @param index - Index of the pixel.\n     * @param channel - Index of the channel, must be zero.\n     * @returns Value of the bit.\n     */\n    getValueByIndex(index, channel) {\n        checkChannel(channel);\n        return this.getBitByIndex(index);\n    }\n    /**\n     * Set the value of a bit using index. Function exists for compatibility with Image.\n     * @param index - Index of the pixel.\n     * @param channel - Index of the channel, must be zero.\n     * @param value - Value to set.\n     */\n    setValueByIndex(index, channel, value) {\n        checkChannel(channel);\n        this.setBitByIndex(index, value);\n    }\n    /**\n     * Get the value of a specific bit. Select bit using a point.\n     * @param point - Coordinates of the desired biz.\n     * @returns Value of the bit.\n     */\n    getValueByPoint(point) {\n        return this.getValue(point.column, point.row, 0);\n    }\n    /**\n     * Set the value of a specific bit. Select bit using a point.\n     * @param point - Coordinates of the bit.\n     * @param value - Value to set.\n     */\n    setValueByPoint(point, value) {\n        this.setValue(point.column, point.row, 0, value);\n    }\n    /**\n     * Return the raw mask data.\n     * @returns The raw data.\n     */\n    getRawImage() {\n        return {\n            width: this.width,\n            height: this.height,\n            data: this.data,\n        };\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        let dataString;\n        if (this.height > 20 || this.width > 20) {\n            dataString = '[...]';\n        }\n        else {\n            dataString = printData(this);\n        }\n        return `Mask {\n  width: ${this.width}\n  height: ${this.height}\n  data: ${dataString}\n}`;\n    }\n    /**\n     * Fill the mask with a value.\n     * @param value - Value of the bit.\n     * @returns The mask instance.\n     */\n    fill(value) {\n        const result = boolToNumber(value);\n        this.data.fill(result);\n        return this;\n    }\n    convertColor(colorModel) {\n        return convertColor(this, colorModel);\n    }\n    // FILTERS\n    /**\n     * Invert the colors of the mask.\n     * @param options - Inversion options.\n     * @returns The inverted mask.\n     */\n    invert(options) {\n        return invert(this, options);\n    }\n    /**\n     * Subtract other from a mask.\n     * @param other - Image to subtract.\n     * @param options - Inversion options.\n     * @returns The subtracted mask.\n     */\n    subtract(other, options) {\n        return subtract(this, other, options);\n    }\n    /**\n     * Perform an AND operation on two masks.\n     * @param other - Second mask.\n     * @param options - And options.\n     * @returns AND of the two masks.\n     */\n    and(other, options) {\n        return and(this, other, options);\n    }\n    /**\n     * Perform an OR operation on two masks.\n     * @param other - Second mask.\n     * @param options - And options.\n     * @returns OR of the two masks.\n     */\n    or(other, options) {\n        return or(this, other, options);\n    }\n    // MASK ANALYSIS\n    /**\n     * Get the coordinates of the points on the border of a shape defined in a mask.\n     * @param options - Get border points options.\n     * @returns Array of border points.\n     */\n    getBorderPoints(options) {\n        return getBorderPoints(this, options);\n    }\n    /**\n     * Get the vertices of the convex Hull polygon of a mask.\n     * @returns Array of the vertices of the convex Hull in clockwise order.\n     */\n    getConvexHull() {\n        return getConvexHull(this);\n    }\n    /**\n     * Get the corners of the minimum bounding rectangle of a shape defined in a mask.\n     * @returns Array of border points.\n     */\n    getMbr() {\n        return getMbr(this);\n    }\n    /**\n     * Computes the Feret data.\n     * @returns The Feret diameters.\n     */\n    getFeret() {\n        return getFeret(this);\n    }\n    // MORPHOLOGY\n    /**\n     * Erode a Mask.\n     * @param options - Erode options.\n     * @returns The eroded mask.\n     */\n    erode(options) {\n        return erode(this, options);\n    }\n    /**\n     * Dilate an image.\n     * @param options - Dilate options.\n     * @returns The dilated image.\n     */\n    dilate(options) {\n        return dilate(this, options);\n    }\n    /**\n     * Open an image.\n     * @param options - Open options.\n     * @returns The opened image.\n     */\n    open(options) {\n        return open(this, options);\n    }\n    /**\n     * Close an image.\n     * @param options - Close options.\n     * @returns The closed image.\n     */\n    close(options) {\n        return close(this, options);\n    }\n    /**\n     * Top hat of an image.\n     * @param options - Top hat options.\n     * @returns The top-hatted image.\n     */\n    topHat(options) {\n        return topHat(this, options);\n    }\n    /**\n     * Bottom hat of an image.\n     * @param options - Bottom hat options.\n     * @returns The bottom-hatted image.\n     */\n    bottomHat(options) {\n        return bottomHat(this, options);\n    }\n    /**\n     * Apply morphological gradient to an image.\n     * @param options - Morphological gradient options.\n     * @returns The processed image.\n     */\n    morphologicalGradient(options) {\n        return morphologicalGradient(this, options);\n    }\n    /**\n     * Remove elements connected to the borders of an image.\n     * @param options - Clear border options.\n     * @returns The processed image.\n     */\n    clearBorder(options) {\n        return clearBorder(this, options);\n    }\n    /**\n     * Apply flood fill algorithm from a given starting point.\n     * @param options - Flood fill options.\n     * @returns The filled mask.\n     */\n    floodFill(options) {\n        return floodFill(this, options);\n    }\n    /**\n     * Fill holes in regions of interest.\n     * @param options - Flood fill options.\n     * @returns The filled mask.\n     */\n    solidFill(options) {\n        return solidFill(this, options);\n    }\n    // DRAW\n    /**\n     * Draw a set of points on a mask.\n     * @param points - Array of points.\n     * @param options - Draw points on Image options.\n     * @returns New mask.\n     */\n    drawPoints(points, options = {}) {\n        return drawPoints(this, points, options);\n    }\n    /**\n     * Draw a line defined by two points onto a mask.\n     * @param from - Line starting point.\n     * @param to - Line ending point.\n     * @param options - Draw Line options.\n     * @returns The mask with the line drawing.\n     */\n    drawLine(from, to, options = {}) {\n        return drawLineOnMask(this, from, to, options);\n    }\n    /**\n     * Draw a polyline defined by an array of points on a mask.\n     * @param points - Polyline array of points.\n     * @param options - Draw polyline options.\n     * @returns The mask with the polyline drawing.\n     */\n    drawPolyline(points, options = {}) {\n        return drawPolylineOnMask(this, points, options);\n    }\n    /**\n     * Draw a polygon defined by an array of points onto an mask.\n     * @param points - Polygon vertices.\n     * @param options - Draw Line options.\n     * @returns The mask with the polygon drawing.\n     */\n    drawPolygon(points, options = {}) {\n        return drawPolygonOnMask(this, points, options);\n    }\n    /**\n     * Draw a rectangle defined by position of the top-left corner, width and height.\n     * @param options - Draw rectangle options.\n     * @returns The image with the rectangle drawing.\n     */\n    drawRectangle(options = {}) {\n        return drawRectangle(this, options);\n    }\n    // OPERATIONS\n    /**\n     * Copy the mask to another one by specifying the location in the target mask.\n     * @param target - The target mask.\n     * @param options - Options.\n     * @returns The target with the source copied to it.\n     */\n    copyTo(target, options = {}) {\n        return copyTo(this, target, options);\n    }\n    /**\n     * Paint a mask onto another mask and the given position and with the given value.\n     * @param mask - Mask to paint.\n     * @param options - Paint mask options.\n     * @returns The painted mask.\n     */\n    paintMask(mask, options) {\n        return paintMaskOnMask(this, mask, options);\n    }\n}\n/**\n * Returns all values of a mask as a string.\n * @param mask - Input mask.\n * @returns Formatted string with all values of a mask.\n */\nfunction printData(mask) {\n    const result = [];\n    for (let row = 0; row < mask.height; row++) {\n        const line = [];\n        for (let column = 0; column < mask.width; column++) {\n            line.push(String(mask.getBit(column, row)));\n        }\n        result.push(`[${line.join(' ')}]`);\n    }\n    return result.join('\\n        ');\n}\n/**\n * Verify the channel value of a mask.\n * @param channel - The channel value.\n */\nfunction checkChannel(channel) {\n    if (channel !== 0) {\n        throw new RangeError(`channel value must be 0 on type Mask. Received ${channel}`);\n    }\n}\n//# sourceMappingURL=Mask.js.map","import { Image } from '../Image.js';\nimport { Mask } from '../Mask.js';\nimport checkProcessable from '../utils/validators/checkProcessable.js';\nimport { validateForComparison } from '../utils/validators/validators.js';\n/**\n * Calculate a new image that is the subtraction between the current image and the otherImage.\n * @param image - Image from which to subtract.\n * @param otherImage - Image to subtract.\n * @param options - Subtract options.\n * @returns The subtracted image.\n */\nexport function subtract(image, otherImage, options = {}) {\n    const { absolute = false } = options;\n    if (image instanceof Image) {\n        checkProcessable(image, {\n            bitDepth: [1, 8, 16],\n            components: [1, 3],\n            alpha: false,\n        });\n    }\n    validateForComparison(image, otherImage);\n    const newImage = image.clone();\n    if (newImage instanceof Image) {\n        for (let index = 0; index < image.size; index++) {\n            for (let channel = 0; channel < image.channels; channel++) {\n                const value = image.getValueByIndex(index, channel) -\n                    otherImage.getValueByIndex(index, channel);\n                if (absolute) {\n                    if (value < 0) {\n                        newImage.setValueByIndex(index, channel, -value);\n                    }\n                    else {\n                        newImage.setValueByIndex(index, channel, value);\n                    }\n                }\n                else if (value < 0) {\n                    newImage.setValueByIndex(index, channel, 0);\n                }\n                else {\n                    newImage.setValueByIndex(index, channel, value);\n                }\n            }\n        }\n    }\n    else if (image instanceof Mask && otherImage instanceof Mask) {\n        for (let index = 0; index < image.size; index++) {\n            const value = image.getBitByIndex(index) - otherImage.getBitByIndex(index);\n            if (absolute) {\n                newImage.setBitByIndex(index, value ? 1 : 0);\n            }\n            else {\n                newImage.setBitByIndex(index, value > 0 ? 1 : 0);\n            }\n        }\n    }\n    return newImage;\n}\n//# sourceMappingURL=subtract.js.map","import { Image } from '../Image.js';\nimport { getClamp } from '../utils/clamp.js';\nimport checkProcessable from '../utils/validators/checkProcessable.js';\nimport { validateForComparison } from '../utils/validators/validators.js';\n/**\n *\n * Calculate a new image that is the sum between the current image and the otherImage.\n * @param image - Image to which to add.\n * @param otherImage - Image to add.\n * @returns The summed image.\n */\nexport function add(image, otherImage) {\n    if (image instanceof Image) {\n        checkProcessable(image, {\n            bitDepth: [8, 16],\n            components: [1, 3],\n            alpha: false,\n        });\n    }\n    validateForComparison(image, otherImage);\n    const newImage = image.clone();\n    const clamp = getClamp(image);\n    for (let index = 0; index < image.size; index++) {\n        for (let channel = 0; channel < image.channels; channel++) {\n            const value = image.getValueByIndex(index, channel) +\n                otherImage.getValueByIndex(index, channel);\n            newImage.setValueByIndex(index, channel, clamp(value));\n        }\n    }\n    return newImage;\n}\n//# sourceMappingURL=add.js.map","import { getOutputImage } from '../utils/getOutputImage.js';\nimport { validateChannels } from '../utils/validators/validators.js';\n/**\n *\n * Multiplies points by a certain value.\n * @param image - image to which multiplication will be applied.\n * @param value - Value by which each pixel will be multiplied.\n * @param options - Multiply options\n * @returns image.\n */\nexport function multiply(image, value, options = {}) {\n    const { channels = new Array(image.channels).fill(0).map((value, index) => index), } = options;\n    validateChannels(channels, image);\n    const newImage = getOutputImage(image, options, { clone: true });\n    if (channels.length === 0) {\n        return newImage;\n    }\n    for (const channel of channels) {\n        for (let row = 0; row < newImage.height; row++) {\n            for (let column = 0; column < newImage.width; column++) {\n                const newIntensity = newImage.getValue(column, row, channel) * value;\n                newImage.setClampedValue(column, row, channel, newIntensity);\n            }\n        }\n    }\n    return newImage;\n}\n//# sourceMappingURL=multiply.js.map","/**\n * Compute the mean of an image. The mean can be either computed on each channel\n * individually or on the whole image.\n * @param image - Image to process.\n * @param options - Mean options.\n * @returns The mean pixel.\n */\nexport function mean(image, options) {\n    const pixelSum = new Array(image.channels).fill(0);\n    const nbValues = options ? options.points.length : image.size;\n    if (nbValues === 0)\n        throw new RangeError('Array of coordinates is empty.');\n    if (options) {\n        for (const point of options.points) {\n            for (let channel = 0; channel < image.channels; channel++) {\n                if (point.column < 0 ||\n                    point.column >= image.width ||\n                    point.row < 0 ||\n                    point.row >= image.height) {\n                    throw new RangeError(`Invalid coordinate: {column: ${point.column}, row: ${point.row}}.`);\n                }\n                pixelSum[channel] += image.getValueByPoint(point, channel);\n            }\n        }\n    }\n    else {\n        for (let row = 0; row < image.height; row++) {\n            for (let column = 0; column < image.width; column++) {\n                for (let channel = 0; channel < image.channels; channel++) {\n                    pixelSum[channel] += image.getValue(column, row, channel);\n                }\n            }\n        }\n    }\n    return pixelSum.map((channelSum) => channelSum / nbValues);\n}\n//# sourceMappingURL=mean.js.map","import { validateChannel } from '../utils/validators/validators.js';\n/**\n * Returns a histogram of pixel intensities.\n * @param image - The original image.\n * @param options - Histogram options.\n * @returns - The histogram.\n */\nexport function histogram(image, options = {}) {\n    let { channel } = options;\n    const { slots = 2 ** image.bitDepth } = options;\n    if (!(slots !== 0 && (slots & (slots - 1)) === 0)) {\n        throw new RangeError('slots must be a power of 2, for example: 64, 256, 1024');\n    }\n    if (typeof channel !== 'number') {\n        if (image.channels !== 1) {\n            throw new TypeError('channel option is mandatory for multi-channel images');\n        }\n        channel = 0;\n    }\n    validateChannel(channel, image);\n    const hist = new Uint32Array(slots);\n    let bitShift = 0;\n    const bitSlots = Math.log2(slots);\n    bitShift = image.bitDepth - bitSlots;\n    for (let i = 0; i < image.size; i++) {\n        hist[image.getValueByIndex(i, channel) >> bitShift]++;\n    }\n    return hist;\n}\n//# sourceMappingURL=histogram.js.map","// @ts-expect-error: median-quisckselect has no types\nimport quickMedian from 'median-quickselect';\n/**\n * Returns the median pixel of the image. The median is computed on each channel individually.\n * @param image - Image to process.\n * @param options - Median options.\n * @returns Median pixel.\n */\nexport function median(image, options) {\n    const pixel = new Array(image.channels).fill(0);\n    if (options) {\n        if (options.points.length === 0) {\n            throw new RangeError('Array of coordinates is empty.');\n        }\n        for (let i = 0; i < image.channels; i++) {\n            const channel = [];\n            for (const point of options.points) {\n                if (point.column < 0 ||\n                    point.column >= image.width ||\n                    point.row < 0 ||\n                    point.row >= image.height) {\n                    throw new RangeError(`Invalid coordinate: {column: ${point.column}, row: ${point.row}}.`);\n                }\n                channel.push(image.getValueByPoint(point, i));\n            }\n            pixel[i] = quickMedian(channel);\n        }\n    }\n    else {\n        for (let i = 0; i < image.channels; i++) {\n            const channel = image.getChannel(i);\n            pixel[i] = quickMedian(channel);\n        }\n    }\n    return pixel;\n}\n//# sourceMappingURL=median.js.map","import { assertUnreachable } from '../utils/validators/assert.js';\nimport checkProcessable from '../utils/validators/checkProcessable.js';\n/**\n * Checks the surrounding values of a point. If they are all bigger or smaller than the pixel in question then this point is considered an extremum.\n * @param image - Image to find extrema from.\n * @param options - ExtremaOptions\n * @returns Array of Points.\n */\nexport function getExtrema(image, options) {\n    const { kind = 'maximum', mask, algorithm = 'star', maxEquals = 2 } = options;\n    checkProcessable(image, {\n        bitDepth: [8, 16],\n    });\n    const searchingMinimum = kind === 'minimum';\n    const maskExpectedValue = searchingMinimum ? 0 : 1;\n    const dx = [1, 0, -1, 0, 1, 1, -1, -1, 2, 0, -2, 0, 2, 2, -2, -2];\n    const dy = [0, 1, 0, -1, 1, -1, 1, -1, 0, 2, 0, -2, 2, -2, 2, -2];\n    switch (algorithm) {\n        case 'cross':\n            dx.length = 4;\n            dy.length = 4;\n            break;\n        case 'square':\n            dx.length = 8;\n            dy.length = 8;\n            break;\n        case 'star':\n            break;\n        default:\n            assertUnreachable(algorithm);\n    }\n    const shift = dx.length <= 8 ? 1 : 2; // deal with borders\n    const points = [];\n    for (let channel = 0; channel < image.channels; channel++) {\n        for (let currentY = shift; currentY < image.height - shift; currentY++) {\n            for (let currentX = shift; currentX < image.width - shift; currentX++) {\n                if (mask && mask.getBit(currentX, currentY) !== maskExpectedValue) {\n                    continue;\n                }\n                let counter = 0;\n                let nbEquals = 0;\n                const currentValue = image.getValue(currentX, currentY, channel);\n                for (let dir = 0; dir < dx.length; dir++) {\n                    const currentAroundValue = image.getValue(currentX + dx[dir], currentY + dy[dir], channel);\n                    if (searchingMinimum) {\n                        // we search for minima\n                        if (currentAroundValue > currentValue) {\n                            counter++;\n                        }\n                    }\n                    else if (currentAroundValue < currentValue) {\n                        counter++;\n                    }\n                    if (currentAroundValue === currentValue) {\n                        nbEquals++;\n                    }\n                }\n                if (counter + nbEquals === dx.length && nbEquals <= maxEquals) {\n                    points.push({ column: currentX, row: currentY });\n                }\n            }\n        }\n    }\n    // TODO How to make a more performant and general way\n    // we don't deal correctly here with groups of points that should be grouped if at the\n    // beginning one of them is closer to another\n    // Seems that we would ened to calculate a matrix and then split this matrix in 'independant matrices'\n    // Or to assign a cluster to each point and regroup them if 2 clusters are close to each other\n    // later approach seems much better\n    return points;\n}\n//# sourceMappingURL=getExtrema.js.map","/**\n * Compute the variance of each channel of an image.\n * @see {@link https://en.wikipedia.org/wiki/Variance}\n * @param image - Image to process.\n * @param options - Variance options.\n * @returns The variance of the channels of the image.\n */\nexport function variance(image, options) {\n    const mean = image.mean(options);\n    const sum = new Array(image.channels).fill(0);\n    if (options) {\n        for (const point of options.points) {\n            for (let channel = 0; channel < image.channels; channel++) {\n                sum[channel] +=\n                    (image.getValue(point.column, point.row, channel) - mean[channel]) **\n                        2;\n            }\n        }\n    }\n    else {\n        for (let i = 0; i < image.size; i++) {\n            for (let channel = 0; channel < image.channels; channel++) {\n                sum[channel] +=\n                    (image.getValueByIndex(i, channel) - mean[channel]) ** 2;\n            }\n        }\n    }\n    const nbValues = options\n        ? options.points.length * image.channels\n        : image.size * image.channels;\n    return sum.map((channel) => channel / nbValues);\n}\n//# sourceMappingURL=variance.js.map","import { Matrix, SVD, pseudoInverse } from 'ml-matrix';\n\nexport default class MultivariateLinearRegression {\n  constructor(x, y, options = {}) {\n    const { intercept = true, statistics = true } = options;\n    this.statistics = statistics;\n    if (x === true) {\n      this.weights = y.weights;\n      this.inputs = y.inputs;\n      this.outputs = y.outputs;\n      this.intercept = y.intercept;\n    } else {\n      x = new Matrix(x);\n      y = new Matrix(y);\n      if (intercept) {\n        x.addColumn(new Array(x.rows).fill(1));\n      }\n      let xt = x.transpose();\n      const xx = xt.mmul(x);\n      const xy = xt.mmul(y);\n      const invxx = new SVD(xx).inverse();\n      const beta = xy.transpose().mmul(invxx).transpose();\n      this.weights = beta.to2DArray();\n      this.inputs = x.columns;\n      this.outputs = y.columns;\n      if (intercept) this.inputs--;\n      this.intercept = intercept;\n      if (statistics) {\n        /*\n         * Let's add some basic statistics about the beta's to be able to interpret them.\n         * source: http://dept.stat.lsa.umich.edu/~kshedden/Courses/Stat401/Notes/401-multreg.pdf\n         * validated against Excel Regression AddIn\n         * test: \"datamining statistics test\"\n         */\n        const fittedValues = x.mmul(beta);\n        const residuals = y.clone().addM(fittedValues.neg());\n        const variance =\n          residuals\n            .to2DArray()\n            .map((ri) => Math.pow(ri[0], 2))\n            .reduce((a, b) => a + b) /\n          (y.rows - x.columns);\n        this.stdError = Math.sqrt(variance);\n        this.stdErrorMatrix = pseudoInverse(xx).mul(variance);\n        this.stdErrors = this.stdErrorMatrix\n          .diagonal()\n          .map((d) => Math.sqrt(d));\n        this.tStats = this.weights.map((d, i) =>\n          this.stdErrors[i] === 0 ? 0 : d[0] / this.stdErrors[i],\n        );\n      }\n    }\n  }\n\n  predict(x) {\n    if (Array.isArray(x)) {\n      if (typeof x[0] === 'number') {\n        return this._predict(x);\n      } else if (Array.isArray(x[0])) {\n        const y = new Array(x.length);\n        for (let i = 0; i < x.length; i++) {\n          y[i] = this._predict(x[i]);\n        }\n        return y;\n      }\n    } else if (Matrix.isMatrix(x)) {\n      const y = new Matrix(x.rows, this.outputs);\n      for (let i = 0; i < x.rows; i++) {\n        y.setRow(i, this._predict(x.getRow(i)));\n      }\n      return y;\n    }\n    throw new TypeError('x must be a matrix or array of numbers');\n  }\n\n  _predict(x) {\n    const result = new Array(this.outputs);\n    if (this.intercept) {\n      for (let i = 0; i < this.outputs; i++) {\n        result[i] = this.weights[this.inputs][i];\n      }\n    } else {\n      result.fill(0);\n    }\n    for (let i = 0; i < this.inputs; i++) {\n      for (let j = 0; j < this.outputs; j++) {\n        result[j] += this.weights[i][j] * x[i];\n      }\n    }\n    return result;\n  }\n\n  score() {\n    throw new Error('score method is not implemented yet');\n  }\n\n  toJSON() {\n    return {\n      name: 'multivariateLinearRegression',\n      weights: this.weights,\n      inputs: this.inputs,\n      outputs: this.outputs,\n      intercept: this.intercept,\n      summary: this.statistics\n        ? {\n            regressionStatistics: {\n              standardError: this.stdError,\n              observations: this.outputs,\n            },\n            variables: this.weights.map((d, i) => {\n              return {\n                label:\n                  i === this.weights.length - 1\n                    ? 'Intercept'\n                    : `X Variable ${i + 1}`,\n                coefficients: d,\n                standardError: this.stdErrors[i],\n                tStat: this.tStats[i],\n              };\n            }),\n          }\n        : undefined,\n    };\n  }\n\n  static load(model) {\n    if (model.name !== 'multivariateLinearRegression') {\n      throw new Error('not a MLR model');\n    }\n    return new MultivariateLinearRegression(true, model);\n  }\n}\n","var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return\"string\"==typeof r?r.length>0:\"number\"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},a=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},o=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(r){var t=r.toString(16);return t.length<2?\"0\"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,a=Math.max(t,n,e),o=a-Math.min(t,n,e),i=o?a===t?(n-e)/o:a===n?2+(e-t)/o:4+(t-n)/o:0;return{h:60*(i<0?i+6:i),s:a?o/a*100:0,v:a/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var a=Math.floor(t),o=e*(1-n),i=e*(1-(t-a)*n),s=e*(1-(1-t+a)*n),h=a%6;return{r:255*[e,i,o,o,s,e][h],g:255*[s,e,e,i,o,o][h],b:255*[o,o,s,e,e,i][h],a:u}},g=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},d=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e},c=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u},l=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,p=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s+([+-]?\\d*\\.?\\d+)%\\s+([+-]?\\d*\\.?\\d+)%\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,v=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,m=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,y={string:[[function(r){var t=i.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},\"hex\"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:a({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},\"rgb\"],[function(t){var n=l.exec(t)||p.exec(t);if(!n)return null;var e,u,a=g({h:(e=n[1],u=n[2],void 0===u&&(u=\"deg\"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(a)},\"hsl\"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,o=r.a,i=void 0===o?1:o;return t(n)&&t(e)&&t(u)?a({r:Number(n),g:Number(e),b:Number(u),a:Number(i)}):null},\"rgb\"],[function(r){var n=r.h,e=r.s,u=r.l,a=r.a,o=void 0===a?1:a;if(!t(n)||!t(e)||!t(u))return null;var i=g({h:Number(n),s:Number(e),l:Number(u),a:Number(o)});return f(i)},\"hsl\"],[function(r){var n=r.h,a=r.s,o=r.v,i=r.a,s=void 0===i?1:i;if(!t(n)||!t(a)||!t(o))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(a),v:Number(o),a:Number(s)});return b(h)},\"hsv\"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return\"string\"==typeof r?N(r.trim(),y.string):\"object\"==typeof r&&null!==r?N(r,y.object):[null,void 0]},I=function(r){return x(r)[1]},M=function(r,t){var n=c(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},H=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},$=function(r,t){var n=c(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},j=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(H(this.rgba),2)},r.prototype.isDark=function(){return H(this.rgba)<.5},r.prototype.isLight=function(){return H(this.rgba)>=.5},r.prototype.toHex=function(){return r=o(this.rgba),t=r.r,e=r.g,u=r.b,i=(a=r.a)<1?s(n(255*a)):\"\",\"#\"+s(t)+s(e)+s(u)+i;var r,t,e,u,a,i},r.prototype.toRgb=function(){return o(this.rgba)},r.prototype.toRgbString=function(){return r=o(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?\"rgba(\"+t+\", \"+n+\", \"+e+\", \"+u+\")\":\"rgb(\"+t+\", \"+n+\", \"+e+\")\";var r,t,n,e,u},r.prototype.toHsl=function(){return d(c(this.rgba))},r.prototype.toHslString=function(){return r=d(c(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?\"hsla(\"+t+\", \"+n+\"%, \"+e+\"%, \"+u+\")\":\"hsl(\"+t+\", \"+n+\"%, \"+e+\"%)\";var r,t,n,e,u},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r},r.prototype.invert=function(){return w({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r},r.prototype.saturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,-r))},r.prototype.grayscale=function(){return w(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),w($(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),w($(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return\"number\"==typeof r?w({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t},r.prototype.hue=function(r){var t=c(this.rgba);return\"number\"==typeof r?w({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===w(r).toHex()},r}(),w=function(r){return r instanceof j?r:new j(r)},S=[],k=function(r){r.forEach(function(r){S.indexOf(r)<0&&(r(j,y),S.push(r))})},E=function(){return new j({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};export{j as Colord,w as colord,k as extend,I as getFormat,E as random};\n","var a=function(a){return\"string\"==typeof a?a.length>0:\"number\"==typeof a},t=function(a,t,o){return void 0===t&&(t=0),void 0===o&&(o=Math.pow(10,t)),Math.round(o*a)/o+0},o=function(a,t,o){return void 0===t&&(t=0),void 0===o&&(o=1),a>o?o:a>t?a:t},r=function(a){var t=a/255;return t<.04045?t/12.92:Math.pow((t+.055)/1.055,2.4)},h=function(a){return 255*(a>.0031308?1.055*Math.pow(a,1/2.4)-.055:12.92*a)},n=96.422,p=100,M=82.521,u=function(a){var t,r,n={x:.9555766*(t=a).x+-.0230393*t.y+.0631636*t.z,y:-.0282895*t.x+1.0099416*t.y+.0210077*t.z,z:.0122982*t.x+-.020483*t.y+1.3299098*t.z};return r={r:h(.032404542*n.x-.015371385*n.y-.004985314*n.z),g:h(-.00969266*n.x+.018760108*n.y+41556e-8*n.z),b:h(556434e-9*n.x-.002040259*n.y+.010572252*n.z),a:a.a},{r:o(r.r,0,255),g:o(r.g,0,255),b:o(r.b,0,255),a:o(r.a)}},e=function(a){var t=r(a.r),h=r(a.g),u=r(a.b);return function(a){return{x:o(a.x,0,n),y:o(a.y,0,p),z:o(a.z,0,M),a:o(a.a)}}(function(a){return{x:1.0478112*a.x+.0228866*a.y+-.050127*a.z,y:.0295424*a.x+.9904844*a.y+-.0170491*a.z,z:-.0092345*a.x+.0150436*a.y+.7521316*a.z,a:a.a}}({x:100*(.4124564*t+.3575761*h+.1804375*u),y:100*(.2126729*t+.7151522*h+.072175*u),z:100*(.0193339*t+.119192*h+.9503041*u),a:a.a}))},w=216/24389,b=24389/27,i=function(t){var r=t.l,h=t.a,n=t.b,p=t.alpha,M=void 0===p?1:p;if(!a(r)||!a(h)||!a(n))return null;var u=function(a){return{l:o(a.l,0,400),a:a.a,b:a.b,alpha:o(a.alpha)}}({l:Number(r),a:Number(h),b:Number(n),alpha:Number(M)});return l(u)},l=function(a){var t=(a.l+16)/116,o=a.a/500+t,r=t-a.b/200;return u({x:(Math.pow(o,3)>w?Math.pow(o,3):(116*o-16)/b)*n,y:(a.l>8?Math.pow((a.l+16)/116,3):a.l/b)*p,z:(Math.pow(r,3)>w?Math.pow(r,3):(116*r-16)/b)*M,a:a.alpha})};export default function(a,r){a.prototype.toLab=function(){return o=e(this.rgba),h=o.y/p,u=o.z/M,r=(r=o.x/n)>w?Math.cbrt(r):(b*r+16)/116,a={l:116*(h=h>w?Math.cbrt(h):(b*h+16)/116)-16,a:500*(r-h),b:200*(h-(u=u>w?Math.cbrt(u):(b*u+16)/116)),alpha:o.a},{l:t(a.l,2),a:t(a.a,2),b:t(a.b,2),alpha:t(a.alpha,3)};var a,o,r,h,u},a.prototype.delta=function(r){void 0===r&&(r=\"#FFF\");var h=r instanceof a?r:new a(r),n=function(a,t){var o=a.l,r=a.a,h=a.b,n=t.l,p=t.a,M=t.b,u=180/Math.PI,e=Math.PI/180,w=Math.pow(Math.pow(r,2)+Math.pow(h,2),.5),b=Math.pow(Math.pow(p,2)+Math.pow(M,2),.5),i=(o+n)/2,l=Math.pow((w+b)/2,7),c=.5*(1-Math.pow(l/(l+Math.pow(25,7)),.5)),f=r*(1+c),y=p*(1+c),v=Math.pow(Math.pow(f,2)+Math.pow(h,2),.5),x=Math.pow(Math.pow(y,2)+Math.pow(M,2),.5),z=(v+x)/2,s=0===f&&0===h?0:Math.atan2(h,f)*u,d=0===y&&0===M?0:Math.atan2(M,y)*u;s<0&&(s+=360),d<0&&(d+=360);var g=d-s,m=Math.abs(d-s);m>180&&d<=s?g+=360:m>180&&d>s&&(g-=360);var N=s+d;m<=180?N/=2:N=(s+d<360?N+360:N-360)/2;var F=1-.17*Math.cos(e*(N-30))+.24*Math.cos(2*e*N)+.32*Math.cos(e*(3*N+6))-.2*Math.cos(e*(4*N-63)),L=n-o,I=x-v,P=2*Math.sin(e*g/2)*Math.pow(v*x,.5),j=1+.015*Math.pow(i-50,2)/Math.pow(20+Math.pow(i-50,2),.5),k=1+.045*z,q=1+.015*z*F,A=30*Math.exp(-1*Math.pow((N-275)/25,2)),B=-2*Math.pow(l/(l+Math.pow(25,7)),.5)*Math.sin(2*e*A);return Math.pow(Math.pow(L/1/j,2)+Math.pow(I/1/k,2)+Math.pow(P/1/q,2)+B*I*P/(1*k*1*q),.5)}(this.toLab(),h.toLab())/100;return o(t(n,3))},r.object.push([i,\"lab\"])}\n","import { colord, extend } from 'colord';\nimport labPlugin from 'colord/plugins/lab';\nimport { getRegressionVariables } from '../correctColor.js';\n// We can't use ts-expect-error because it's not an error when compiling for CJS.\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore Module exports are not correctly typed.\nextend([labPlugin]);\n/**\n * Convert RGB array colors to RGB object colors. Used to get the properly formatted measured colors.\n * @param arrayColors - Array of RGB colors as 3 elements array.\n * @returns Array of RGB objects.\n */\nexport function getMeasuredColors(arrayColors) {\n    const objectColors = [];\n    for (const color of arrayColors) {\n        objectColors.push({ r: color[0], g: color[1], b: color[2] });\n    }\n    return objectColors;\n}\n/**\n * Extract the colors from a QP card and convert them to RGB.\n * @param qpCard - QP card containing the color reference values in L*a*b*.\n * @returns Array of reference RGB colors.\n */\nexport function getReferenceColors(qpCard) {\n    const result = [];\n    for (const square of qpCard) {\n        result.push(colord(square.lab).toRgb());\n    }\n    return result;\n}\n/**\n * Format and normalize data from a QP card to use as a reference in a multivariate linear regression.\n * @param referenceColors - Array of RGB colors used as a reference.\n * @param maxValue - Maximal acceptable value for the image to process.\n * @returns The formatted data.\n */\nexport function formatReferenceForMlr(referenceColors, maxValue) {\n    const referenceData = { r: [], g: [], b: [] };\n    for (const color of referenceColors) {\n        referenceData.r.push([color.r / maxValue]);\n        referenceData.g.push([color.g / maxValue]);\n        referenceData.b.push([color.b / maxValue]);\n    }\n    return referenceData;\n}\n/**\n * Compute the variables for the multivariate linear regression based on the the input colors. Values are normalized between 0 and 1.\n * @param inputColors - The input colors as an array of rgb objects.\n * @param maxValue - Maximal acceptable value for the image to process.\n * @returns The formatted input data for the regression.\n */\nexport function formatInputForMlr(inputColors, maxValue) {\n    const inputData = [];\n    for (const color of inputColors) {\n        inputData.push(getRegressionVariables(color.r, color.g, color.b, maxValue));\n    }\n    return inputData;\n}\n//# sourceMappingURL=formatData.js.map","import MLR from 'ml-regression-multivariate-linear';\nimport { Image } from '../Image.js';\nimport { getClamp } from '../utils/clamp.js';\nimport checkProcessable from '../utils/validators/checkProcessable.js';\nimport { formatInputForMlr, formatReferenceForMlr, } from './utils/formatData.js';\n/**\n * Correct the colors in an image using the reference colors.\n * Algorithm is based on the paper \"Color correction using improved linear regression algorithm\".\n * DOI: 10.1109/ICTS.2015.7379874.\n * @param image - Image to process.\n * @param measuredColors - Colors from the image, which will be compared to the reference.\n * @param referenceColors - Reference colors.\n * @returns Image with the colors corrected.\n */\nexport function correctColor(image, measuredColors, referenceColors) {\n    checkProcessable(image, {\n        colorModel: ['RGB', 'RGBA'],\n    });\n    if (measuredColors.length !== referenceColors.length) {\n        throw new RangeError('number of measured colors and reference colors must be the same');\n    }\n    const inputData = formatInputForMlr(measuredColors, image.maxValue);\n    const referenceData = formatReferenceForMlr(referenceColors, image.maxValue);\n    const mlrRed = new MLR(inputData, referenceData.r);\n    const mlrGreen = new MLR(inputData, referenceData.g);\n    const mlrBlue = new MLR(inputData, referenceData.b);\n    const result = Image.createFrom(image);\n    for (let row = 0; row < image.height; row++) {\n        for (let column = 0; column < image.width; column++) {\n            const pixel = image.getPixel(column, row);\n            const variables = getRegressionVariables(pixel[0], pixel[1], pixel[2], image.maxValue);\n            const clamp = getClamp(image);\n            const newPixel = [0, 0, 0];\n            const red = mlrRed.predict(variables)[0] * image.maxValue;\n            const green = mlrGreen.predict(variables)[0] * image.maxValue;\n            const blue = mlrBlue.predict(variables)[0] * image.maxValue;\n            newPixel[0] = clamp(red);\n            newPixel[1] = clamp(green);\n            newPixel[2] = clamp(blue);\n            if (image.alpha) {\n                newPixel[3] = image.getValue(column, row, 3);\n            }\n            result.setPixel(column, row, newPixel);\n        }\n    }\n    return result;\n}\n/**\n * Compute the third order variables for the regression from an RGB color.\n * @param r - Red component.\n * @param g - Green component.\n * @param b - Blue component.\n * @param maxValue - Maximal acceptable value for the image to process.\n * @returns The variables for the multivariate linear regression.\n */\nexport function getRegressionVariables(r, g, b, maxValue) {\n    r /= maxValue;\n    g /= maxValue;\n    b /= maxValue;\n    return [\n        r,\n        g,\n        b,\n        r ** 2,\n        g ** 2,\n        b ** 2,\n        r ** 3,\n        g ** 3,\n        b ** 3,\n        r * g,\n        r * b,\n        b * g,\n    ];\n}\n//# sourceMappingURL=correctColor.js.map","/**\n * Find the min and max values of each channel of the image.\n * @param image - Image to process.\n * @returns An object with arrays of the min and max values.\n */\nexport function getMinMax(image) {\n    const min = new Array(image.channels).fill(image.maxValue);\n    const max = new Array(image.channels).fill(0);\n    for (let row = 0; row < image.height; row++) {\n        for (let column = 0; column < image.width; column++) {\n            for (let channel = 0; channel < image.channels; channel++) {\n                const currentValue = image.getValue(column, row, channel);\n                if (currentValue < min[channel]) {\n                    min[channel] = currentValue;\n                }\n                if (currentValue > max[channel]) {\n                    max[channel] = currentValue;\n                }\n            }\n        }\n    }\n    return { min, max };\n}\n//# sourceMappingURL=getMinMax.js.map","import { match } from 'ts-pattern';\nimport { divide } from './compare/divide.js';\nimport { add, subtract } from './compare/index.js';\nimport { multiply } from './compare/multiply.js';\nimport { histogram, mean, median, variance } from './compute/index.js';\nimport { correctColor } from './correctColor/index.js';\nimport { drawCircleOnImage, drawLineOnImage, drawMarker, drawMarkers, drawPoints, drawPolygonOnImage, drawPolylineOnImage, drawRectangle, } from './draw/index.js';\nimport { blur, derivativeFilter, directConvolution, flip, gaussianBlur, gradientFilter, hypotenuse, increaseContrast, invert, level, medianFilter, pixelate, rawDirectConvolution, separableConvolution, } from './filters/index.js';\nimport { resize, rotate, transform, transformRotate, } from './geometry/index.js';\nimport { bottomHat, cannyEdgeDetector, close, dilate, erode, morphologicalGradient, open, topHat, } from './morphology/index.js';\nimport { convertBitDepth, convertColor, copyTo, crop, cropAlpha, cropRectangle, extract, grey, paintMaskOnImage, split, threshold, } from './operations/index.js';\nimport { colorModels } from './utils/constants/colorModels.js';\nimport { getMinMax } from './utils/getMinMax.js';\nimport { validateChannel, validateValue, } from './utils/validators/validators.js';\nexport const ImageCoordinates = {\n    CENTER: 'center',\n    TOP_LEFT: 'top-left',\n    TOP_RIGHT: 'top-right',\n    BOTTOM_LEFT: 'bottom-left',\n    BOTTOM_RIGHT: 'bottom-right',\n};\nexport class Image {\n    /**\n     * The number of columns of the image.\n     */\n    width;\n    /**\n     * The number of rows of the image.\n     */\n    height;\n    /**\n     * The total number of pixels in the image (width  height).\n     */\n    size;\n    /**\n     * The number of bits per value in each channel.\n     */\n    bitDepth;\n    /**\n     * The color model of the image.\n     */\n    colorModel;\n    /**\n     * The number of color channels in the image, excluding the alpha channel.\n     * A GREY image has 1 component. An RGB image has 3 components.\n     */\n    components;\n    /**\n     * The total number of channels in the image, including the alpha channel.\n     */\n    channels;\n    /**\n     * Whether the image has an alpha channel or not.\n     */\n    alpha;\n    /**\n     * The maximum value that a pixel channel can have.\n     */\n    maxValue;\n    /**\n     * Origin of the image relative to a the parent image.\n     */\n    origin;\n    /**\n     * Original image resolution.\n     */\n    originalResolution;\n    meta;\n    /**\n     * Typed array holding the image data.\n     */\n    data;\n    /**\n     * Construct a new Image knowing its dimensions.\n     * @param width - Image width.\n     * @param height - Image height.\n     * @param options - Image options.\n     */\n    constructor(width, height, options = {}) {\n        const { bitDepth = 8, data, colorModel = 'RGB', origin = { row: 0, column: 0 }, meta, resolution, } = options;\n        if (width < 1 || !Number.isInteger(width)) {\n            throw new RangeError(`width must be an integer and at least 1. Received ${width}`);\n        }\n        if (height < 1 || !Number.isInteger(height)) {\n            throw new RangeError(`height must be an integer and at least 1. Received ${height}`);\n        }\n        this.width = width;\n        this.height = height;\n        this.size = width * height;\n        this.bitDepth = bitDepth;\n        this.colorModel = colorModel;\n        this.origin = origin;\n        this.meta = meta;\n        this.originalResolution = resolution;\n        const colorModelDef = colorModels[colorModel];\n        this.components = colorModelDef.components;\n        this.alpha = colorModelDef.alpha;\n        this.channels = colorModelDef.channels;\n        this.maxValue = 2 ** bitDepth - 1;\n        if (data === undefined) {\n            this.data = createPixelArray(this.size, this.channels, this.alpha, this.bitDepth, this.maxValue);\n        }\n        else {\n            if (bitDepth === 8 && data instanceof Uint16Array) {\n                throw new RangeError(`bitDepth is ${bitDepth} but data is Uint16Array`);\n            }\n            else if (bitDepth === 16 && data instanceof Uint8Array) {\n                throw new RangeError(`bitDepth is ${bitDepth} but data is Uint8Array`);\n            }\n            const expectedLength = this.size * this.channels;\n            if (data.length !== expectedLength) {\n                throw new RangeError(`incorrect data size: ${data.length}. Expected ${expectedLength}`);\n            }\n            this.data = data;\n        }\n    }\n    /**\n     * Returns normalized resolution in pixels per centimeter. If resolution unit is unknown, return null.\n     * @returns Object with x and y resolutions in pixel/cm.\n     */\n    get normalizedResolution() {\n        if (!this.originalResolution) {\n            return undefined;\n        }\n        const centimetersPerInch = 2.54;\n        const centimetersPerMeter = 100;\n        switch (this.originalResolution.unit) {\n            case 'inch':\n                return {\n                    x: this.originalResolution.x / centimetersPerInch,\n                    y: this.originalResolution.y / centimetersPerInch,\n                };\n            case 'centimeter':\n                return {\n                    x: this.originalResolution.x,\n                    y: this.originalResolution.y,\n                };\n            case 'meter':\n                return {\n                    x: this.originalResolution.x / centimetersPerMeter,\n                    y: this.originalResolution.y / centimetersPerMeter,\n                };\n            case 'unknown':\n                return null;\n            default:\n                throw new Error('Unknown resolution unit.');\n        }\n    }\n    /**\n     * Create a new Image based on the properties of an existing one.\n     * @param other - Reference image.\n     * @param options - Image options.\n     * @returns New image.\n     */\n    static createFrom(other, options = {}) {\n        const { width = other.width, height = other.height } = options;\n        let bitDepth;\n        if (other instanceof Image) {\n            bitDepth = other.bitDepth;\n        }\n        else {\n            bitDepth = 8;\n        }\n        return new Image(width, height, {\n            bitDepth,\n            colorModel: other.colorModel,\n            origin: other.origin,\n            ...options,\n        });\n    }\n    /**\n     * Get all the channels of a pixel.\n     * @param column - Column index.\n     * @param row - Row index.\n     * @returns Channels of the pixel.\n     */\n    getPixel(column, row) {\n        const result = [];\n        const start = (row * this.width + column) * this.channels;\n        for (let i = 0; i < this.channels; i++) {\n            result.push(this.data[start + i]);\n        }\n        return result;\n    }\n    getColumn(column) {\n        const columnValues = [];\n        for (let i = 0; i < this.channels; i++) {\n            const channelValues = [];\n            for (let j = 0; j < this.height; j++) {\n                channelValues.push(this.getValue(column, j, i));\n            }\n            columnValues.push(channelValues);\n        }\n        return columnValues;\n    }\n    getRow(row) {\n        const rowValues = [];\n        for (let i = 0; i < this.channels; i++) {\n            const channelValues = [];\n            for (let j = 0; j < this.width; j++) {\n                channelValues.push(this.getValue(j, row, i));\n            }\n            rowValues.push(channelValues);\n        }\n        return rowValues;\n    }\n    /**\n     * Set all the channels of a pixel.\n     * @param column - Column index.\n     * @param row - Row index.\n     * @param value - New color of the pixel to set.\n     */\n    setPixel(column, row, value) {\n        const start = (row * this.width + column) * this.channels;\n        for (let i = 0; i < this.channels; i++) {\n            this.data[start + i] = value[i];\n        }\n    }\n    /**\n     * Set all the channels of a pixel if the coordinates are inside the image.\n     * @param column - Column index.\n     * @param row - Row index.\n     * @param value - New color of the pixel to set.\n     */\n    setVisiblePixel(column, row, value) {\n        if (column >= 0 && column < this.width && row >= 0 && row < this.height) {\n            this.setPixel(column, row, value);\n        }\n    }\n    /**\n     * Get all the channels of a pixel using its index.\n     * @param index - Index of the pixel.\n     * @returns Channels of the pixel.\n     */\n    getPixelByIndex(index) {\n        const result = [];\n        const start = index * this.channels;\n        for (let i = 0; i < this.channels; i++) {\n            result.push(this.data[start + i]);\n        }\n        return result;\n    }\n    /**\n     * Set all the channels of a pixel using its index.\n     * @param index - Index of the pixel.\n     * @param value - New channel values of the pixel to set.\n     */\n    setPixelByIndex(index, value) {\n        const start = index * this.channels;\n        for (let i = 0; i < this.channels; i++) {\n            this.data[start + i] = value[i];\n        }\n    }\n    /**\n     * Get the value of a specific pixel channel. Select pixel using coordinates.\n     * @param column - Column index.\n     * @param row - Row index.\n     * @param channel - Channel index.\n     * @returns Value of the specified channel of one pixel.\n     */\n    getValue(column, row, channel) {\n        return this.data[(row * this.width + column) * this.channels + channel];\n    }\n    /**\n     * Set the value of a specific pixel channel. Select pixel using coordinates.\n     * @param column - Column index.\n     * @param row - Row index.\n     * @param channel - Channel index.\n     * @param value - Value to set.\n     */\n    setValue(column, row, channel, value) {\n        this.data[(row * this.width + column) * this.channels + channel] = value;\n    }\n    /**\n     * Set the value of a specific pixel channel. Select pixel using coordinates.\n     * If the value is out of range it is set to the closest extremety.\n     * @param column - Column index.\n     * @param row - Row index.\n     * @param channel - Channel index.\n     * @param value - Value to set.\n     */\n    setClampedValue(column, row, channel, value) {\n        if (value < 0)\n            value = 0;\n        else if (value > this.maxValue)\n            value = this.maxValue;\n        this.data[(row * this.width + column) * this.channels + channel] = value;\n    }\n    /**\n     * Get the value of a specific pixel channel. Select pixel using index.\n     * @param index - Index of the pixel.\n     * @param channel - Channel index.\n     * @returns Value of the channel of the pixel.\n     */\n    getValueByIndex(index, channel) {\n        return this.data[index * this.channels + channel];\n    }\n    /**\n     * Set the value of a specific pixel channel. Select pixel using index.\n     * @param index - Index of the pixel.\n     * @param channel - Channel index.\n     * @param value - Value to set.\n     */\n    setValueByIndex(index, channel, value) {\n        this.data[index * this.channels + channel] = value;\n    }\n    /**\n     * Set the value of a specific pixel channel. Select pixel using index.\n     * If the value is out of range it is set to the closest extremety.\n     * @param index - Index of the pixel.\n     * @param channel - Channel index.\n     * @param value - Value to set.\n     */\n    setClampedValueByIndex(index, channel, value) {\n        if (value < 0)\n            value = 0;\n        else if (value > this.maxValue)\n            value = this.maxValue;\n        this.data[index * this.channels + channel] = value;\n    }\n    /**\n     * Get the value of a specific pixel channel. Select pixel using a point.\n     * @param point - Coordinates of the desired pixel.\n     * @param channel - Channel index.\n     * @returns Value of the channel of the pixel.\n     */\n    getValueByPoint(point, channel) {\n        return this.getValue(point.column, point.row, channel);\n    }\n    /**\n     * Set the value of a specific pixel channel. Select pixel using a point.\n     * @param point - Coordinates of the pixel.\n     * @param channel - Channel index.\n     * @param value - Value to set.\n     */\n    setValueByPoint(point, channel, value) {\n        this.setValue(point.column, point.row, channel, value);\n    }\n    /**\n     * Find the min and max values of each channel of the image.\n     * @returns An object with arrays of the min and max values.\n     */\n    minMax() {\n        return getMinMax(this);\n    }\n    /**\n     * Return the raw image data.\n     * @returns The raw data.\n     */\n    getRawImage() {\n        return {\n            width: this.width,\n            height: this.height,\n            data: this.data,\n            channels: this.channels,\n            bitDepth: this.bitDepth,\n        };\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        let dataString;\n        if (this.height > 20 || this.width > 20) {\n            dataString = '[...]';\n        }\n        else {\n            dataString = printData(this);\n        }\n        return `Image {\n  width: ${this.width}\n  height: ${this.height}\n  bitDepth: ${this.bitDepth}\n  colorModel: ${this.colorModel}\n  channels: ${this.channels}\n  data: ${dataString}\n}`;\n    }\n    /**\n     * Fill the image with a value or a color.\n     * @param value - Value or color.\n     * @returns The image instance.\n     */\n    fill(value) {\n        if (typeof value === 'number') {\n            validateValue(value, this);\n            this.data.fill(value);\n            return this;\n        }\n        else {\n            if (value.length !== this.channels) {\n                throw new RangeError(`the size of value must match the number of channels (${this.channels}). Received ${value.length}`);\n            }\n            for (const val of value)\n                validateValue(val, this);\n            for (let i = 0; i < this.data.length; i += this.channels) {\n                for (let j = 0; j <= this.channels; j++) {\n                    this.data[i + j] = value[j];\n                }\n            }\n            return this;\n        }\n    }\n    /**\n     * Fill one channel with a value.\n     * @param channel - The channel to fill.\n     * @param value - The new value.\n     * @returns The image instance.\n     */\n    fillChannel(channel, value) {\n        validateChannel(channel, this);\n        validateValue(value, this);\n        for (let i = channel; i < this.data.length; i += this.channels) {\n            this.data[i] = value;\n        }\n        return this;\n    }\n    /**\n     * Get one channel of the image as an array.\n     * @param channel - The channel to fill.\n     * @returns Array with the channel values.\n     */\n    getChannel(channel) {\n        validateChannel(channel, this);\n        const result = new Array(this.size);\n        for (let i = 0; i < this.size; i++) {\n            result[i] = this.data[channel + i * this.channels];\n        }\n        return result;\n    }\n    /**\n     * Fill the alpha channel with the specified value.\n     * @param value - New channel value.\n     * @returns The image instance.\n     */\n    fillAlpha(value) {\n        validateValue(value, this);\n        if (!this.alpha) {\n            throw new TypeError('fillAlpha can only be called if the image has an alpha channel');\n        }\n        const alphaIndex = this.channels - 1;\n        return this.fillChannel(alphaIndex, value);\n    }\n    /**\n     * Create a copy of this image.\n     * @returns The image clone.\n     */\n    clone() {\n        return Image.createFrom(this, { data: this.data.slice() });\n    }\n    /**\n     * Modify all the values of the image using the given callback.\n     * @param cb - Callback that modifies a given value.\n     */\n    changeEach(cb) {\n        for (let i = 0; i < this.data.length; i++) {\n            this.data[i] = cb(this.data[i]);\n        }\n    }\n    /**\n     * Get the coordinates of a point in the image. The reference is the top-left corner.\n     * @param coordinates - The point for which you want the coordinates.\n     * @param round - Whether the coordinates should be rounded. This is useful when you want the center of the image.\n     * @returns Coordinates of the point in the format [column, row].\n     */\n    getCoordinates(coordinates, round = false) {\n        return match(coordinates)\n            .with('center', () => {\n            const centerX = (this.width - 1) / 2;\n            const centerY = (this.height - 1) / 2;\n            if (round) {\n                return { column: Math.round(centerX), row: Math.round(centerY) };\n            }\n            else {\n                return { column: centerX, row: centerY };\n            }\n        })\n            .with('top-left', () => ({ column: 0, row: 0 }))\n            .with('top-right', () => ({ column: this.width - 1, row: 0 }))\n            .with('bottom-left', () => ({ column: 0, row: this.height - 1 }))\n            .with('bottom-right', () => ({\n            column: this.width - 1,\n            row: this.height - 1,\n        }))\n            .exhaustive();\n    }\n    // COMPARE\n    /**\n     * Subtract other from an image.\n     * @param other - Image to subtract.\n     * @param options - Inversion options.\n     * @returns The subtracted image.\n     */\n    subtract(other, options = {}) {\n        return subtract(this, other, options);\n    }\n    add(other) {\n        return add(this, other);\n    }\n    /**\n     *  Multiply image pixels by a constant.\n     * @param value - Value which pixels will be multiplied to.\n     * @param options - Multiply options.\n     * @returns Multiplied image.\n     */\n    multiply(value, options = {}) {\n        return multiply(this, value, options);\n    }\n    /**\n     *  Divide image pixels by a constant.\n     * @param value - Value which pixels will be divided to.\n     * @param options - Divide options.\n     * @returns Divided image.\n     */\n    divide(value, options = {}) {\n        return divide(this, value, options);\n    }\n    // COMPUTE\n    histogram(options) {\n        return histogram(this, options);\n    }\n    /**\n     * Compute the mean pixel of an image.\n     * @param options - Mean options.\n     * @returns The mean pixel.\n     */\n    mean(options) {\n        return mean(this, options);\n    }\n    /**\n     * Compute the median pixel of an image.\n     * @param options - Median options.\n     * @returns The median pixel.\n     */\n    median(options) {\n        return median(this, options);\n    }\n    /**\n     * Compute the variance of each channel of an image.\n     * @param options - Variance options.\n     * @returns The variance of the channels of the image.\n     */\n    variance(options) {\n        return variance(this, options);\n    }\n    // DRAW\n    /**\n     * Draw a set of points on an image.\n     * @param points - Array of points.\n     * @param options - Draw points on Image options.\n     * @returns New mask.\n     */\n    drawPoints(points, options = {}) {\n        return drawPoints(this, points, options);\n    }\n    /**\n     * Draw a line defined by two points onto an image.\n     * @param from - Line starting point.\n     * @param to - Line ending point.\n     * @param options - Draw Line options.\n     * @returns The mask with the line drawing.\n     */\n    drawLine(from, to, options = {}) {\n        return drawLineOnImage(this, from, to, options);\n    }\n    /**\n     * Draw a rectangle defined by position of the top-left corner, width and height.\n     * @param options - Draw rectangle options.\n     * @returns The image with the rectangle drawing.\n     */\n    drawRectangle(options = {}) {\n        return drawRectangle(this, options);\n    }\n    /**\n     * Draw a polyline defined by an array of points on an image.\n     * @param points - Polyline array of points.\n     * @param options - Draw polyline options.\n     * @returns The image with the polyline drawing.\n     */\n    drawPolyline(points, options = {}) {\n        return drawPolylineOnImage(this, points, options);\n    }\n    /**\n     * Draw a polygon defined by an array of points onto an image.\n     * @param points - Polygon vertices.\n     * @param options - Draw Line options.\n     * @returns The image with the polygon drawing.\n     */\n    drawPolygon(points, options = {}) {\n        return drawPolygonOnImage(this, points, options);\n    }\n    /**\n     * Draw a circle defined by center and radius onto an image.\n     * @param center - Circle center.\n     * @param radius - Circle radius.\n     * @param options - Draw circle options.\n     * @returns The image with the circle drawing.\n     */\n    drawCircle(center, radius, options = {}) {\n        return drawCircleOnImage(this, center, radius, options);\n    }\n    /**\n     * Draw a marker on the image.\n     * @param point - Marker center point.\n     * @param options - Draw marker options.\n     * @returns The image with the marker drawing.\n     */\n    drawMarker(point, options = {}) {\n        return drawMarker(this, point, options);\n    }\n    /**\n     * Draw markers on the image.\n     * @param points - Markers center points.\n     * @param options - Draw marker options.\n     * @returns The image with the markers drawing.\n     */\n    drawMarkers(points, options = {}) {\n        return drawMarkers(this, points, options);\n    }\n    // OPERATIONS\n    split() {\n        return split(this);\n    }\n    convertColor(colorModel, options) {\n        return convertColor(this, colorModel, options);\n    }\n    convertBitDepth(newDepth, options) {\n        return convertBitDepth(this, newDepth, options);\n    }\n    grey(options) {\n        return grey(this, options);\n    }\n    copyTo(target, options = {}) {\n        return copyTo(this, target, options);\n    }\n    threshold(options = {}) {\n        return threshold(this, options);\n    }\n    /**\n     * Crop the input image to a desired size.\n     * @param [options] - Crop options.\n     * @returns The new cropped image.\n     */\n    crop(options) {\n        return crop(this, options);\n    }\n    /**\n     * Crop an oriented rectangle from the image.\n     * If the rectangle's length or width are not an integers, its dimension is expanded in both directions such as the length and width are integers.\n     * @param points - The points of the rectangle. Points must be circling around the rectangle (clockwise or anti-clockwise)\n     * @param options - Crop options, see {@link CropRectangleOptions}\n     * @returns The cropped image. The orientation of the image is the one closest to the rectangle passed as input.\n     */\n    cropRectangle(points, options) {\n        return cropRectangle(this, points, options);\n    }\n    /**\n     * Crops the image based on the alpha channel\n     * This removes lines and columns where the alpha channel is lower than a threshold value.\n     * @param options - Crop alpha options.\n     * @returns The cropped image.\n     */\n    cropAlpha(options = {}) {\n        return cropAlpha(this, options);\n    }\n    /**\n     * Extract the pixels of an image, as specified in a mask.\n     * @param mask - The mask defining which pixels to keep.\n     * @param options - Extract options.\n     * @returns The extracted image.\n     */\n    extract(mask, options) {\n        return extract(this, mask, options);\n    }\n    /**\n     * Paint a mask onto an image and the given position and with the given color.\n     * @param mask - Mask to paint on the image.\n     * @param options - Paint mask options.\n     * @returns The painted image.\n     */\n    paintMask(mask, options) {\n        return paintMaskOnImage(this, mask, options);\n    }\n    // FILTERS\n    blur(options) {\n        return blur(this, options);\n    }\n    pixelate(options) {\n        return pixelate(this, options);\n    }\n    directConvolution(kernel, options) {\n        return directConvolution(this, kernel, options);\n    }\n    /**\n     * Compute direct convolution of an image and return an array with the raw values.\n     * @param kernel - Kernel used for the convolution.\n     * @param options - Convolution options.\n     * @returns Array with the raw convoluted values.\n     */\n    rawDirectConvolution(kernel, options) {\n        return rawDirectConvolution(this, kernel, options);\n    }\n    separableConvolution(kernelX, kernelY, options) {\n        return separableConvolution(this, kernelX, kernelY, options);\n    }\n    /**\n     * Apply a gaussian filter to an image.\n     * @param options - Gaussian blur options.\n     * @returns The blurred image.\n     */\n    gaussianBlur(options) {\n        return gaussianBlur(this, options);\n    }\n    /**\n     * Flip the image.\n     * @param options - Flip options.\n     * @returns The flipped image.\n     */\n    flip(options) {\n        return flip(this, options);\n    }\n    /**\n     *   Invert the colors of the image.\n     * @param options - Inversion options.\n     * @returns The inverted image.\n     */\n    invert(options) {\n        return invert(this, options);\n    }\n    /**\n     * Calculate a new image that is the hypotenuse between the current image and the other.\n     * @param other - Other image.\n     * @param options - Hypotenuse options.\n     * @returns Hypotenuse of the two images.\n     */\n    hypotenuse(other, options) {\n        return hypotenuse(this, other, options);\n    }\n    /**\n     * Apply a gradient filter to an image.\n     * @param options - Gradient filter options.\n     * @returns The gradient image.\n     */\n    gradientFilter(options) {\n        return gradientFilter(this, options);\n    }\n    /**\n     * Apply a derivative filter to an image.\n     * @param options - Derivative filter options.\n     * @returns The processed image.\n     */\n    derivativeFilter(options) {\n        return derivativeFilter(this, options);\n    }\n    /**\n     * Level the image using the optional input and output value. This function allows you to enhance the image's contrast.\n     * @param options - Level options.\n     * @returns The levelled image.\n     */\n    level(options) {\n        return level(this, options);\n    }\n    /**\n     * Increase the contrast of an image by spanning each channel on the range [0, image.maxValue].\n     * @param options - Increase contrast options.\n     * @returns The enhanced image.\n     */\n    increaseContrast(options = {}) {\n        return increaseContrast(this, options);\n    }\n    /**\n     * Correct the colors in an image using the reference colors.\n     * @param measuredColors - Colors from the image, which will be compared to the reference.\n     * @param referenceColors - Reference colors.\n     * @returns Image with the colors corrected.\n     */\n    correctColor(measuredColors, referenceColors) {\n        return correctColor(this, measuredColors, referenceColors);\n    }\n    /**\n     * Apply a median filter to the image.\n     * @param options - Options to apply for median filter.\n     * @returns Image after median filter.\n     */\n    medianFilter(options) {\n        return medianFilter(this, options);\n    }\n    // GEOMETRY\n    resize(options) {\n        return resize(this, options);\n    }\n    rotate(angle) {\n        return rotate(this, angle);\n    }\n    transform(transformMatrix, options) {\n        return transform(this, transformMatrix, options);\n    }\n    transformRotate(angle, options) {\n        return transformRotate(this, angle, options);\n    }\n    // MORPHOLOGY\n    /**\n     * Erode an image.\n     * @param options - Erode options.\n     * @returns The eroded image.\n     */\n    erode(options) {\n        return erode(this, options);\n    }\n    /**\n     * Dilate an image.\n     * @param options - Dilate options.\n     * @returns The dilated image.\n     */\n    dilate(options) {\n        return dilate(this, options);\n    }\n    /**\n     * Open an image.\n     * @param options - Open options.\n     * @returns The opened image.\n     */\n    open(options) {\n        return open(this, options);\n    }\n    /**\n     * Close an image.\n     * @param options - Close options.\n     * @returns The closed image.\n     */\n    close(options) {\n        return close(this, options);\n    }\n    /**\n     * Top hat of an image.\n     * @param options - Top hat options.\n     * @returns The top-hatted image.\n     */\n    topHat(options) {\n        return topHat(this, options);\n    }\n    /**\n     * Bottom hat of an image.\n     * @param options - Bottom hat options.\n     * @returns The bottom-hatted image.\n     */\n    bottomHat(options) {\n        return bottomHat(this, options);\n    }\n    /**\n     * Apply morphological gradient to an image.\n     * @param options - Morphological gradient options.\n     * @returns The processed image.\n     */\n    morphologicalGradient(options) {\n        return morphologicalGradient(this, options);\n    }\n    /**\n     * Apply Canny edge detection to an image.\n     * @param options - Canny edge detection options.\n     * @returns The processed image.\n     */\n    cannyEdgeDetector(options) {\n        return cannyEdgeDetector(this, options);\n    }\n}\n/**\n * Create data array and set alpha channel to max value if applicable.\n * @param size - Number of pixels.\n * @param channels - Number of channels.\n * @param alpha - Specify if there is alpha channel.\n * @param bitDepth - Number of bits per channel.\n * @param maxValue - Maximal acceptable value for the channels.\n * @returns The new pixel array.\n */\nfunction createPixelArray(size, channels, alpha, bitDepth, maxValue) {\n    const length = channels * size;\n    const arr = match(bitDepth)\n        .with(8, () => new Uint8Array(length))\n        .with(16, () => new Uint16Array(length))\n        .otherwise(() => {\n        throw new RangeError(`invalid bitDepth: ${bitDepth}`);\n    });\n    // Alpha channel is 100% by default.\n    if (alpha) {\n        for (let i = channels - 1; i < length; i += channels) {\n            arr[i] = maxValue;\n        }\n    }\n    return arr;\n}\n/**\n * Returns the image data as a formatted string.\n * @param img - The image instance.\n * @returns Formatted string containing the image data.\n */\nfunction printData(img) {\n    const result = [];\n    const padding = img.bitDepth === 8 ? 3 : 5;\n    for (let row = 0; row < img.height; row++) {\n        const currentRow = [];\n        for (let column = 0; column < img.width; column++) {\n            for (let channel = 0; channel < img.channels; channel++) {\n                currentRow.push(String(img.getValue(column, row, channel)).padStart(padding, ' '));\n            }\n        }\n        result.push(`[${currentRow.join(' ')}]`);\n    }\n    return `{\n    [\\n     ${result.join('\\n     ')}\\n    ]\n  }`;\n}\n//# sourceMappingURL=Image.js.map","/**\n * Copy the data of an source to the target image.\n * @param source - Image which data is copied.\n * @param target - Image to which the data must be copied.\n */\nexport function copyData(source, target) {\n    if (target.width !== source.width ||\n        target.height !== source.height ||\n        target.colorModel !== source.colorModel) {\n        throw new RangeError('images width, height or color model is different');\n    }\n    // @ts-expect-error Accessing data, which is private\n    target.data = source.data.slice();\n}\n//# sourceMappingURL=copyData.js.map","import { Image } from '../Image.js';\nimport { Mask } from '../Mask.js';\nimport { copyData } from './copyData.js';\n/**\n * Use this function to support getting the output image of an algorithm from\n * user-supplied options.\n * @param thisImage - Current image on which the algorithm is applied.\n * @param options - Options object received by the algorithm.\n * @param internalOptions - Some additional private options.\n * @returns The output image.\n */\nexport function getOutputImage(thisImage, options = {}, internalOptions = {}) {\n    const { out } = options;\n    const { newParameters, clone } = internalOptions;\n    if (out === undefined) {\n        if (clone) {\n            return thisImage.clone();\n        }\n        else {\n            return Image.createFrom(thisImage, newParameters);\n        }\n    }\n    else {\n        if (!(out instanceof Image)) {\n            throw new TypeError('out must be an Image');\n        }\n        const requirements = {\n            width: thisImage.width,\n            height: thisImage.height,\n            bitDepth: thisImage.bitDepth,\n            colorModel: thisImage.colorModel,\n            ...newParameters,\n        };\n        checkRequirements(requirements, out);\n        if (clone && thisImage !== out) {\n            copyData(thisImage, out);\n        }\n        return out;\n    }\n}\n/**\n * Use this function to support getting the output image of an algorithm from\n * user-supplied options when the input is a mask.\n * @param mask - Current mask on which the algorithm is applied.\n * @param options - Options object received by the algorithm.\n * @returns The output image.\n */\nexport function maskToOutputImage(mask, options = {}) {\n    const { out } = options;\n    if (out === undefined) {\n        return Image.createFrom(mask, {\n            colorModel: 'GREY',\n        });\n    }\n    else {\n        if (!(out instanceof Image)) {\n            throw new TypeError('out must be an Image');\n        }\n        const requirements = {\n            width: mask.width,\n            height: mask.height,\n            bitDepth: 8,\n            colorModel: 'GREY',\n        };\n        checkRequirements(requirements, out);\n        return out;\n    }\n}\n/**\n * Use this function to support getting the output mask of an algorithm from\n * user-supplied options when the input is an image.\n * @param image - Current image on which the algorithm is applied.\n * @param options - Options object received by the algorithm.\n * @returns The output mask.\n */\nexport function imageToOutputMask(image, options = {}) {\n    const { out } = options;\n    if (out === undefined) {\n        return Mask.createFrom(image);\n    }\n    else {\n        if (!(out instanceof Mask)) {\n            throw new TypeError('out must be a Mask');\n        }\n        const requirements = {\n            width: image.width,\n            height: image.height,\n            bitDepth: 1,\n            colorModel: 'BINARY',\n        };\n        checkRequirements(requirements, out);\n        return out;\n    }\n}\nfunction checkRequirements(requirements, out) {\n    for (const property in requirements) {\n        const prop = property;\n        if (out[prop] !== requirements[prop]) {\n            throw new RangeError(`cannot use out image. Its ${property} property must be ${requirements[prop]}. Received ${out[prop]}`);\n        }\n    }\n}\n/**\n * Use this function to support getting the output mask of an algorithm from\n * user-supplied options when the input is an mask.\n * @param mask - Current mask on which the algorithm is applied.\n * @param options - Options object received by the algorithm.\n * @param internalOptions - Additional private options.\n * @returns The output mask.\n */\nexport function maskToOutputMask(mask, options = {}, internalOptions = {}) {\n    const { out } = options;\n    const { newParameters, clone } = internalOptions;\n    if (out === undefined) {\n        if (clone) {\n            return mask.clone();\n        }\n        else {\n            return Mask.createFrom(mask, newParameters);\n        }\n    }\n    else {\n        if (!(out instanceof Mask)) {\n            throw new TypeError('out must be a Mask');\n        }\n        const requirements = {\n            width: mask.width,\n            height: mask.height,\n            bitDepth: 1,\n            colorModel: 'BINARY',\n        };\n        checkRequirements(requirements, out);\n        if (clone && mask !== out) {\n            copyData(mask, out);\n        }\n        return out;\n    }\n}\n//# sourceMappingURL=getOutputImage.js.map","import { getClampFromTo } from '../../utils/clamp.js';\n/**\n * Generate an array of colors to draw the keypoints depending on their score or the matches depending on the distance.\n * @param image - The source image.\n * @param baseColor - The desired shade for the colors.\n * @param options - Get score colors options.\n * @returns Array of colors.\n */\nexport function getColors(image, baseColor, options = {}) {\n    const { nbShades = 6, minValueFactor = 0.2 } = options;\n    const maxValue = Math.max(...baseColor);\n    const minValue = maxValue * minValueFactor;\n    const interval = Math.floor((maxValue - minValue) / (nbShades - 1));\n    const clamp = getClampFromTo(0, image.maxValue);\n    const colors = [];\n    for (let i = 0; i < nbShades; i++) {\n        const color = [];\n        for (const channel of baseColor) {\n            color.push(clamp(channel - i * interval));\n        }\n        colors.push(color);\n    }\n    return colors;\n}\n//# sourceMappingURL=getColors.js.map","/**\n * Get the shade the keypoint with given index should have (the color is an indicator\n * of the score). The keypoints should be sorted with highest score first.\n * @param keypoints - The sorted keypoints.\n * @param index - Index of the keypoint.\n * @param colors - The colors from which to pick (sorted from brightest to darkest).\n * @returns The color the keypoint should have.\n */\nexport function getKeypointColor(keypoints, index, colors) {\n    const maxScore = keypoints[0].score;\n    const minScore = keypoints.at(-1).score;\n    if (minScore === maxScore) {\n        return colors[0];\n    }\n    const score = keypoints[index].score;\n    const colorIndex = colors.length -\n        1 -\n        Math.floor(((colors.length - 1) * (score - minScore)) / (maxScore - minScore));\n    return colors[colorIndex];\n}\n//# sourceMappingURL=getKeypointColor.js.map","import { sum } from '../../utils/geometry/points.js';\nimport { getOutputImage } from '../../utils/getOutputImage.js';\nimport { getColors } from '../utils/getColors.js';\nimport { getKeypointColor } from '../utils/getKeypointColor.js';\n/**\n * Draw keypoints on an image.\n * @param image - The source image of the keypoints.\n * @param keypoints - The FAST keypoints.\n * @param options - Draw keypoints options.\n * @returns The image with the keypoints indicated by empty circles.\n */\nexport function drawKeypoints(image, keypoints, options = {}) {\n    const { markerSize = 10, fill = false, showScore = false, origin = { row: 0, column: 0 }, showScoreOptions, } = options;\n    let { maxNbKeypoints = keypoints.length } = options;\n    const { strokeColor = [255, 0, 0] } = options;\n    if (maxNbKeypoints > keypoints.length) {\n        maxNbKeypoints = keypoints.length;\n    }\n    let newImage = getOutputImage(image, options, { clone: true });\n    if (image.colorModel !== 'RGB') {\n        newImage = newImage.convertColor('RGB');\n    }\n    const colors = getColors(image, strokeColor, showScoreOptions);\n    const radius = Math.ceil(markerSize / 2);\n    for (let i = 0; i < maxNbKeypoints; i++) {\n        const keypoint = keypoints[i];\n        let keypointColor = strokeColor;\n        if (showScore) {\n            keypointColor = getKeypointColor(keypoints, i, colors);\n        }\n        const fillColor = fill ? keypointColor : undefined;\n        const absoluteOrigin = sum(keypoint.origin, origin);\n        newImage.drawCircle(absoluteOrigin, radius, {\n            fillColor,\n            strokeColor: keypointColor,\n            out: newImage,\n        });\n        if (isOrientedFastKeypoint(keypoint) &&\n            options.showOrientation) {\n            const angle = keypoint.angle;\n            const from = absoluteOrigin;\n            const radAngle = (angle * Math.PI) / 180;\n            const to = {\n                column: from.column + Math.round(radius * Math.cos(radAngle)),\n                row: from.row - Math.round(radius * Math.sin(radAngle)),\n            };\n            newImage.drawLine(from, to, {\n                strokeColor: keypointColor,\n                out: newImage,\n            });\n        }\n    }\n    return newImage;\n}\nfunction isOrientedFastKeypoint(kpt) {\n    return 'angle' in kpt && typeof kpt.angle === 'number';\n}\n//# sourceMappingURL=drawKeypoints.js.map","/**\n * Get the shade of the match with given index (the color is an indicator\n * of the distance). The matches should be sorted with smallest distance first.\n * @param matches - The sorted keypoints.\n * @param index - Index of the keypoint.\n * @param colors - The colors from which to pick (sorted from brightest to darkest).\n * @returns The color the keypoint should have.\n */\nexport function getMatchColor(matches, index, colors) {\n    const maxDistance = matches.at(-1).distance;\n    const minDistance = matches[0].distance;\n    if (minDistance === maxDistance) {\n        return colors[0];\n    }\n    const distance = matches[index].distance;\n    const colorIndex = Math.floor(((colors.length - 1) * (distance - minDistance)) /\n        (maxDistance - minDistance));\n    return colors[colorIndex];\n}\n//# sourceMappingURL=getMatchColor.js.map","/**\n * Source array of matches by ascending distance.\n * @param matches - Array of matches to sort.\n * @returns Sorted copy of the array of matches.\n */\nexport function sortByDistance(matches) {\n    const sorted = matches.slice();\n    sorted.sort((match1, match2) => {\n        return match1.distance - match2.distance;\n    });\n    return sorted;\n}\n//# sourceMappingURL=sortByDistance.js.map","/**\n * Scales the coordinates of the keypoints.\n * @param keypoints - Keypoints to scale.\n * @param scale - Scalar by which to multiply the coordinates.\n * @returns Scaled keypoints (copy of the original array).\n */\nexport function scaleKeypoints(keypoints, scale) {\n    if (scale === 1)\n        return keypoints.slice();\n    return keypoints.map((kpt) => {\n        return {\n            origin: {\n                row: kpt.origin.row * scale,\n                column: kpt.origin.column * scale,\n            },\n            score: kpt.score,\n        };\n    });\n}\n//# sourceMappingURL=scaleKeypoints.js.map","import { getColors } from '../utils/getColors.js';\nimport { getMatchColor } from '../utils/getMatchColor.js';\nimport { sortByDistance } from '../utils/sortByDistance.js';\nimport { scaleKeypoints } from './scaleKeypoints.js';\n/**\n * Draw the the matches between two images on their montage.\n * @param montage - The montage of two images to match.\n * @param matches - The matches between source and destination.\n * @param sourceKeypoints - Source keypoints.\n * @param destinationKeypoints - Destination keypoints.\n * @param options - Draw matches options.\n * @returns The comparison image.\n */\nexport function drawMatches(montage, matches, sourceKeypoints, destinationKeypoints, options = {}) {\n    const { circleDiameter = 10, strokeColor = [255, 0, 0], showDistance = false, showDistanceOptions, } = options;\n    let { maxNbMatches = matches.length } = options;\n    if (maxNbMatches > matches.length) {\n        maxNbMatches = matches.length;\n    }\n    const scaledSource = scaleKeypoints(sourceKeypoints, montage.scale);\n    const scaledDestination = scaleKeypoints(destinationKeypoints, montage.scale);\n    const result = montage.image;\n    const colors = getColors(result, strokeColor, showDistanceOptions);\n    const radius = Math.ceil(circleDiameter / 2);\n    const matchesSortedByDistance = sortByDistance(matches);\n    for (let i = 0; i < maxNbMatches; i++) {\n        let matchColor = strokeColor;\n        if (showDistance) {\n            matchColor = getMatchColor(matchesSortedByDistance, i, colors);\n        }\n        const sourcePoint = scaledSource[matches[i].sourceIndex].origin;\n        result.drawCircle(sourcePoint, radius, {\n            strokeColor: matchColor,\n            out: result,\n        });\n        const relativeDestinationPoint = scaledDestination[matches[i].destinationIndex].origin;\n        const destinationPoint = {\n            column: relativeDestinationPoint.column + montage.destinationOrigin.column,\n            row: relativeDestinationPoint.row + montage.destinationOrigin.row,\n        };\n        result.drawCircle(destinationPoint, radius, {\n            strokeColor: matchColor,\n            out: result,\n        });\n        result.drawLine(sourcePoint, destinationPoint, {\n            out: result,\n            strokeColor: matchColor,\n        });\n    }\n    return result;\n}\n//# sourceMappingURL=drawMatches.js.map","import { Image } from '../../Image.js';\nimport { drawKeypoints } from './drawKeypoints.js';\nimport { drawMatches } from './drawMatches.js';\nimport { scaleKeypoints } from './scaleKeypoints.js';\nexport const MontageDisposition = {\n    HORIZONTAL: 'horizontal',\n    VERTICAL: 'vertical',\n};\nexport class Montage {\n    /**\n     * Scaled width of the first image.\n     */\n    sourceWidth;\n    /**\n     * Scaled height of the first image.\n     */\n    sourceHeight;\n    /**\n     * Scaled width of the second image.\n     */\n    destinationWidth;\n    /**\n     * Scaled height of the second image.\n     */\n    destinationHeight;\n    /**\n     * Origin of the destination / second image relative to top-left corner of the Montage.\n     */\n    destinationOrigin;\n    /**\n     * Width of the Montage.\n     */\n    width;\n    /**\n     * Height of the Montage.\n     */\n    height;\n    /**\n     * Factor by which to scale the images are scaled in the montage.\n     */\n    scale;\n    disposition;\n    /**\n     * Image of the Montage.\n     */\n    image;\n    /**\n     * Create a Montage of two images. The two images are placed side by side for comparison.\n     * @param source - First image.\n     * @param destination - Second image.\n     * @param options  - Montage options.\n     */\n    constructor(source, destination, options = {}) {\n        const { scale = 1, disposition = 'horizontal' } = options;\n        if (!Number.isInteger(scale)) {\n            throw new TypeError('scale must be an integer');\n        }\n        this.scale = scale;\n        this.disposition = disposition;\n        this.sourceWidth = scale * source.width;\n        this.destinationWidth = scale * destination.width;\n        this.sourceHeight = scale * source.height;\n        this.destinationHeight = scale * destination.height;\n        if (disposition === 'horizontal') {\n            this.destinationOrigin = { row: 0, column: this.sourceWidth };\n            this.width = this.sourceWidth + this.destinationWidth;\n            this.height = Math.max(this.sourceHeight, this.destinationHeight);\n        }\n        else if (disposition === 'vertical') {\n            this.destinationOrigin = { row: this.sourceHeight, column: 0 };\n            this.width = Math.max(this.sourceWidth, this.destinationWidth);\n            this.height = this.sourceHeight + this.destinationHeight;\n        }\n        else {\n            throw new RangeError(`invalid disposition type: ${disposition}`);\n        }\n        if (source.colorModel !== 'RGB') {\n            source = source.convertColor('RGB');\n        }\n        if (destination.colorModel !== 'RGB') {\n            destination = destination.convertColor('RGB');\n        }\n        const image = new Image(this.width, this.height);\n        source\n            .resize({ xFactor: scale, yFactor: scale })\n            .copyTo(image, { out: image });\n        destination.resize({ xFactor: scale, yFactor: scale }).copyTo(image, {\n            out: image,\n            origin: this.destinationOrigin,\n        });\n        this.image = image;\n    }\n    /**\n     * Draw keypoints on the Montage.\n     * @param keypoints - Keypoints to draw.\n     * @param options - Draw keypoints options.\n     */\n    drawKeypoints(keypoints, options = {}) {\n        const scaledKeypoints = scaleKeypoints(keypoints, this.scale);\n        this.image = drawKeypoints(this.image, scaledKeypoints, options);\n    }\n    /**\n     * Draw the matches between source and destination keypoints.\n     * @param matches - Matches to draw.\n     * @param sourceKeypoints - Source keypoints.\n     * @param destinationKeypoints  - Destination keypoints.\n     * @param options - Draw matches options.\n     */\n    drawMatches(matches, sourceKeypoints, destinationKeypoints, options = {}) {\n        this.image = drawMatches(this, matches, sourceKeypoints, destinationKeypoints, options);\n    }\n}\n//# sourceMappingURL=Montage.js.map","import { Image, ImageCoordinates } from '../../Image.js';\nimport { merge } from '../../operations/index.js';\nimport { ImageColorModel } from '../../utils/constants/colorModels.js';\n/**\n * Overlap two images and specify. The first image can be translated,\n * rotated and scaled to match the second one.\n * The first image is drawn in red and the second one in green.\n * @param image1 - First image.\n * @param image2 - Second image.\n * @param options - Overlap image options.\n * @returns The overlapping images.\n */\nexport function overlapImages(image1, image2, options = {}) {\n    const { origin = { row: 0, column: 0 }, angle = 0, scale = 1 } = options;\n    if (scale === 0) {\n        throw new Error('Scale cannot be 0');\n    }\n    if (image1.colorModel !== ImageColorModel.GREY) {\n        image1 = image1.grey();\n    }\n    if (image2.colorModel !== ImageColorModel.GREY) {\n        image2 = image2.grey();\n    }\n    const inverted1 = image1.invert();\n    const inverted2 = image2.invert();\n    const rotated = inverted1.transformRotate(angle, {\n        center: ImageCoordinates.TOP_LEFT,\n    });\n    const scaled = rotated.resize({ xFactor: scale, yFactor: scale });\n    const empty = Image.createFrom(inverted2);\n    const alignedGrey1 = scaled.copyTo(empty, { origin });\n    const result = merge([alignedGrey1, inverted2, empty]);\n    return result;\n}\n//# sourceMappingURL=overlapImages.js.map","/**\n * Use this function to only keep the match from source to destination with\n * the smallest distance (score) for each destination keypoint.\n * @param matches - Matches from source to destination.\n * @param sourceKeypoints - Source keypoints.\n * @param destinationKeypoints - Destination keypoints.\n * @param options - Filter smallest distance matches options.\n * @returns Only the matches from source to destination with the smallest distance.\n */\nexport function filterEuclideanDistance(matches, sourceKeypoints, destinationKeypoints, options = {}) {\n    const { origin = { column: 0, row: 0 } } = options;\n    const sorted = matches.slice();\n    sorted.sort((a, b) => a.destinationIndex - b.destinationIndex);\n    const result = [];\n    let sameDestMatches = [];\n    let currentIndex = sorted[0].destinationIndex;\n    for (const match of sorted) {\n        if (match.destinationIndex === currentIndex) {\n            sameDestMatches.push(match);\n        }\n        else {\n            sameDestMatches.sort((a, b) => distanceSquared(a) - distanceSquared(b));\n            result.push(...sameDestMatches.slice(0, 1));\n            currentIndex = match.destinationIndex;\n            sameDestMatches = [match];\n        }\n    }\n    sameDestMatches.sort((a, b) => distanceSquared(a) - distanceSquared(b));\n    result.push(...sameDestMatches.slice(0, 1));\n    return result;\n    function distanceSquared(match) {\n        return ((sourceKeypoints[match.sourceIndex].origin.row -\n            (destinationKeypoints[match.destinationIndex].origin.row -\n                origin.row)) **\n            2 +\n            (sourceKeypoints[match.sourceIndex].origin.column -\n                destinationKeypoints[match.destinationIndex].origin.column -\n                origin.column) **\n                2);\n    }\n}\n//# sourceMappingURL=filterEuclideanDistance.js.map","/**\n * Decode bytes to text\n * @param bytes - Bytes to decode\n * @param encoding - Text encoding\n * @returns The decoded text\n */\nexport function decode(bytes, encoding = 'utf8') {\n    const decoder = new TextDecoder(encoding);\n    return decoder.decode(bytes);\n}\nconst encoder = new TextEncoder();\n/**\n * Encode text to utf8\n * @param str - Text to encode\n * @returns The encoded bytes\n */\nexport function encode(str) {\n    return encoder.encode(str);\n}\n//# sourceMappingURL=text.js.map","import { decode, encode } from \"./text.js\";\nconst defaultByteLength = 1024 * 8;\nconst hostBigEndian = (() => {\n    const array = new Uint8Array(4);\n    const view = new Uint32Array(array.buffer);\n    return !((view[0] = 1) & array[0]);\n})();\nconst typedArrays = {\n    int8: globalThis.Int8Array,\n    uint8: globalThis.Uint8Array,\n    int16: globalThis.Int16Array,\n    uint16: globalThis.Uint16Array,\n    int32: globalThis.Int32Array,\n    uint32: globalThis.Uint32Array,\n    uint64: globalThis.BigUint64Array,\n    int64: globalThis.BigInt64Array,\n    float32: globalThis.Float32Array,\n    float64: globalThis.Float64Array,\n};\nexport class IOBuffer {\n    /**\n     * Reference to the internal ArrayBuffer object.\n     */\n    buffer;\n    /**\n     * Byte length of the internal ArrayBuffer.\n     */\n    byteLength;\n    /**\n     * Byte offset of the internal ArrayBuffer.\n     */\n    byteOffset;\n    /**\n     * Byte length of the internal ArrayBuffer.\n     */\n    length;\n    /**\n     * The current offset of the buffer's pointer.\n     */\n    offset;\n    lastWrittenByte;\n    littleEndian;\n    _data;\n    _mark;\n    _marks;\n    /**\n     * Create a new IOBuffer.\n     * @param data - The data to construct the IOBuffer with.\n     * If data is a number, it will be the new buffer's length<br>\n     * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>\n     * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,\n     * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.\n     * @param options - An object for the options.\n     * @returns A new IOBuffer instance.\n     */\n    constructor(data = defaultByteLength, options = {}) {\n        let dataIsGiven = false;\n        if (typeof data === 'number') {\n            data = new ArrayBuffer(data);\n        }\n        else {\n            dataIsGiven = true;\n            this.lastWrittenByte = data.byteLength;\n        }\n        const offset = options.offset ? options.offset >>> 0 : 0;\n        const byteLength = data.byteLength - offset;\n        let dvOffset = offset;\n        if (ArrayBuffer.isView(data) || data instanceof IOBuffer) {\n            if (data.byteLength !== data.buffer.byteLength) {\n                dvOffset = data.byteOffset + offset;\n            }\n            data = data.buffer;\n        }\n        if (dataIsGiven) {\n            this.lastWrittenByte = byteLength;\n        }\n        else {\n            this.lastWrittenByte = 0;\n        }\n        this.buffer = data;\n        this.length = byteLength;\n        this.byteLength = byteLength;\n        this.byteOffset = dvOffset;\n        this.offset = 0;\n        this.littleEndian = true;\n        this._data = new DataView(this.buffer, dvOffset, byteLength);\n        this._mark = 0;\n        this._marks = [];\n    }\n    /**\n     * Checks if the memory allocated to the buffer is sufficient to store more\n     * bytes after the offset.\n     * @param byteLength - The needed memory in bytes.\n     * @returns `true` if there is sufficient space and `false` otherwise.\n     */\n    available(byteLength = 1) {\n        return this.offset + byteLength <= this.length;\n    }\n    /**\n     * Check if little-endian mode is used for reading and writing multi-byte\n     * values.\n     * @returns `true` if little-endian mode is used, `false` otherwise.\n     */\n    isLittleEndian() {\n        return this.littleEndian;\n    }\n    /**\n     * Set little-endian mode for reading and writing multi-byte values.\n     * @returns This.\n     */\n    setLittleEndian() {\n        this.littleEndian = true;\n        return this;\n    }\n    /**\n     * Check if big-endian mode is used for reading and writing multi-byte values.\n     * @returns `true` if big-endian mode is used, `false` otherwise.\n     */\n    isBigEndian() {\n        return !this.littleEndian;\n    }\n    /**\n     * Switches to big-endian mode for reading and writing multi-byte values.\n     * @returns This.\n     */\n    setBigEndian() {\n        this.littleEndian = false;\n        return this;\n    }\n    /**\n     * Move the pointer n bytes forward.\n     * @param n - Number of bytes to skip.\n     * @returns This.\n     */\n    skip(n = 1) {\n        this.offset += n;\n        return this;\n    }\n    /**\n     * Move the pointer n bytes backward.\n     * @param n - Number of bytes to move back.\n     * @returns This.\n     */\n    back(n = 1) {\n        this.offset -= n;\n        return this;\n    }\n    /**\n     * Move the pointer to the given offset.\n     * @param offset - The offset to move to.\n     * @returns This.\n     */\n    seek(offset) {\n        this.offset = offset;\n        return this;\n    }\n    /**\n     * Store the current pointer offset.\n     * @see {@link IOBuffer#reset}\n     * @returns This.\n     */\n    mark() {\n        this._mark = this.offset;\n        return this;\n    }\n    /**\n     * Move the pointer back to the last pointer offset set by mark.\n     * @see {@link IOBuffer#mark}\n     * @returns This.\n     */\n    reset() {\n        this.offset = this._mark;\n        return this;\n    }\n    /**\n     * Push the current pointer offset to the mark stack.\n     * @see {@link IOBuffer#popMark}\n     * @returns This.\n     */\n    pushMark() {\n        this._marks.push(this.offset);\n        return this;\n    }\n    /**\n     * Pop the last pointer offset from the mark stack, and set the current\n     * pointer offset to the popped value.\n     * @see {@link IOBuffer#pushMark}\n     * @returns This.\n     */\n    popMark() {\n        const offset = this._marks.pop();\n        if (offset === undefined) {\n            throw new Error('Mark stack empty');\n        }\n        this.seek(offset);\n        return this;\n    }\n    /**\n     * Move the pointer offset back to 0.\n     * @returns This.\n     */\n    rewind() {\n        this.offset = 0;\n        return this;\n    }\n    /**\n     * Make sure the buffer has sufficient memory to write a given byteLength at\n     * the current pointer offset.\n     * If the buffer's memory is insufficient, this method will create a new\n     * buffer (a copy) with a length that is twice (byteLength + current offset).\n     * @param byteLength - The needed memory in bytes.\n     * @returns This.\n     */\n    ensureAvailable(byteLength = 1) {\n        if (!this.available(byteLength)) {\n            const lengthNeeded = this.offset + byteLength;\n            const newLength = lengthNeeded * 2;\n            const newArray = new Uint8Array(newLength);\n            newArray.set(new Uint8Array(this.buffer));\n            this.buffer = newArray.buffer;\n            this.length = newLength;\n            this.byteLength = newLength;\n            this._data = new DataView(this.buffer);\n        }\n        return this;\n    }\n    /**\n     * Read a byte and return false if the byte's value is 0, or true otherwise.\n     * Moves pointer forward by one byte.\n     * @returns The read boolean.\n     */\n    readBoolean() {\n        return this.readUint8() !== 0;\n    }\n    /**\n     * Read a signed 8-bit integer and move pointer forward by 1 byte.\n     * @returns The read byte.\n     */\n    readInt8() {\n        return this._data.getInt8(this.offset++);\n    }\n    /**\n     * Read an unsigned 8-bit integer and move pointer forward by 1 byte.\n     * @returns The read byte.\n     */\n    readUint8() {\n        return this._data.getUint8(this.offset++);\n    }\n    /**\n     * Alias for {@link IOBuffer#readUint8}.\n     * @returns The read byte.\n     */\n    readByte() {\n        return this.readUint8();\n    }\n    /**\n     * Read `n` bytes and move pointer forward by `n` bytes.\n     * @param n - Number of bytes to read.\n     * @returns The read bytes.\n     */\n    readBytes(n = 1) {\n        return this.readArray(n, 'uint8');\n    }\n    /**\n     * Creates an array of corresponding to the type `type` and size `size`.\n     * For example, type `uint8` will create a `Uint8Array`.\n     * @param size - size of the resulting array\n     * @param type - number type of elements to read\n     * @returns The read array.\n     */\n    readArray(size, type) {\n        const bytes = typedArrays[type].BYTES_PER_ELEMENT * size;\n        const offset = this.byteOffset + this.offset;\n        const slice = this.buffer.slice(offset, offset + bytes);\n        if (this.littleEndian === hostBigEndian &&\n            type !== 'uint8' &&\n            type !== 'int8') {\n            const slice = new Uint8Array(this.buffer.slice(offset, offset + bytes));\n            slice.reverse();\n            const returnArray = new typedArrays[type](slice.buffer);\n            this.offset += bytes;\n            returnArray.reverse();\n            return returnArray;\n        }\n        const returnArray = new typedArrays[type](slice);\n        this.offset += bytes;\n        return returnArray;\n    }\n    /**\n     * Read a 16-bit signed integer and move pointer forward by 2 bytes.\n     * @returns The read value.\n     */\n    readInt16() {\n        const value = this._data.getInt16(this.offset, this.littleEndian);\n        this.offset += 2;\n        return value;\n    }\n    /**\n     * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.\n     * @returns The read value.\n     */\n    readUint16() {\n        const value = this._data.getUint16(this.offset, this.littleEndian);\n        this.offset += 2;\n        return value;\n    }\n    /**\n     * Read a 32-bit signed integer and move pointer forward by 4 bytes.\n     * @returns The read value.\n     */\n    readInt32() {\n        const value = this._data.getInt32(this.offset, this.littleEndian);\n        this.offset += 4;\n        return value;\n    }\n    /**\n     * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.\n     * @returns The read value.\n     */\n    readUint32() {\n        const value = this._data.getUint32(this.offset, this.littleEndian);\n        this.offset += 4;\n        return value;\n    }\n    /**\n     * Read a 32-bit floating number and move pointer forward by 4 bytes.\n     * @returns The read value.\n     */\n    readFloat32() {\n        const value = this._data.getFloat32(this.offset, this.littleEndian);\n        this.offset += 4;\n        return value;\n    }\n    /**\n     * Read a 64-bit floating number and move pointer forward by 8 bytes.\n     * @returns The read value.\n     */\n    readFloat64() {\n        const value = this._data.getFloat64(this.offset, this.littleEndian);\n        this.offset += 8;\n        return value;\n    }\n    /**\n     * Read a 64-bit signed integer number and move pointer forward by 8 bytes.\n     * @returns The read value.\n     */\n    readBigInt64() {\n        const value = this._data.getBigInt64(this.offset, this.littleEndian);\n        this.offset += 8;\n        return value;\n    }\n    /**\n     * Read a 64-bit unsigned integer number and move pointer forward by 8 bytes.\n     * @returns The read value.\n     */\n    readBigUint64() {\n        const value = this._data.getBigUint64(this.offset, this.littleEndian);\n        this.offset += 8;\n        return value;\n    }\n    /**\n     * Read a 1-byte ASCII character and move pointer forward by 1 byte.\n     * @returns The read character.\n     */\n    readChar() {\n        // eslint-disable-next-line unicorn/prefer-code-point\n        return String.fromCharCode(this.readInt8());\n    }\n    /**\n     * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.\n     * @param n - Number of characters to read.\n     * @returns The read characters.\n     */\n    readChars(n = 1) {\n        let result = '';\n        for (let i = 0; i < n; i++) {\n            result += this.readChar();\n        }\n        return result;\n    }\n    /**\n     * Read the next `n` bytes, return a UTF-8 decoded string and move pointer\n     * forward by `n` bytes.\n     * @param n - Number of bytes to read.\n     * @returns The decoded string.\n     */\n    readUtf8(n = 1) {\n        return decode(this.readBytes(n));\n    }\n    /**\n     * Read the next `n` bytes, return a string decoded with `encoding` and move pointer\n     * forward by `n` bytes.\n     * If no encoding is passed, the function is equivalent to @see {@link IOBuffer#readUtf8}\n     * @param n - Number of bytes to read.\n     * @param encoding - The encoding to use. Default is 'utf8'.\n     * @returns The decoded string.\n     */\n    decodeText(n = 1, encoding = 'utf8') {\n        return decode(this.readBytes(n), encoding);\n    }\n    /**\n     * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer\n     * forward by 1 byte.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeBoolean(value) {\n        this.writeUint8(value ? 0xff : 0x00);\n        return this;\n    }\n    /**\n     * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeInt8(value) {\n        this.ensureAvailable(1);\n        this._data.setInt8(this.offset++, value);\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as an 8-bit unsigned integer and move pointer forward by 1\n     * byte.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeUint8(value) {\n        this.ensureAvailable(1);\n        this._data.setUint8(this.offset++, value);\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * An alias for {@link IOBuffer#writeUint8}.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeByte(value) {\n        return this.writeUint8(value);\n    }\n    /**\n     * Write all elements of `bytes` as uint8 values and move pointer forward by\n     * `bytes.length` bytes.\n     * @param bytes - The array of bytes to write.\n     * @returns This.\n     */\n    writeBytes(bytes) {\n        this.ensureAvailable(bytes.length);\n        // eslint-disable-next-line @typescript-eslint/prefer-for-of\n        for (let i = 0; i < bytes.length; i++) {\n            this._data.setUint8(this.offset++, bytes[i]);\n        }\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 16-bit signed integer and move pointer forward by 2\n     * bytes.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeInt16(value) {\n        this.ensureAvailable(2);\n        this._data.setInt16(this.offset, value, this.littleEndian);\n        this.offset += 2;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 16-bit unsigned integer and move pointer forward by 2\n     * bytes.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeUint16(value) {\n        this.ensureAvailable(2);\n        this._data.setUint16(this.offset, value, this.littleEndian);\n        this.offset += 2;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 32-bit signed integer and move pointer forward by 4\n     * bytes.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeInt32(value) {\n        this.ensureAvailable(4);\n        this._data.setInt32(this.offset, value, this.littleEndian);\n        this.offset += 4;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 32-bit unsigned integer and move pointer forward by 4\n     * bytes.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeUint32(value) {\n        this.ensureAvailable(4);\n        this._data.setUint32(this.offset, value, this.littleEndian);\n        this.offset += 4;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 32-bit floating number and move pointer forward by 4\n     * bytes.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeFloat32(value) {\n        this.ensureAvailable(4);\n        this._data.setFloat32(this.offset, value, this.littleEndian);\n        this.offset += 4;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 64-bit floating number and move pointer forward by 8\n     * bytes.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeFloat64(value) {\n        this.ensureAvailable(8);\n        this._data.setFloat64(this.offset, value, this.littleEndian);\n        this.offset += 8;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 64-bit signed bigint and move pointer forward by 8\n     * bytes.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeBigInt64(value) {\n        this.ensureAvailable(8);\n        this._data.setBigInt64(this.offset, value, this.littleEndian);\n        this.offset += 8;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write `value` as a 64-bit unsigned bigint and move pointer forward by 8\n     * bytes.\n     * @param value - The value to write.\n     * @returns This.\n     */\n    writeBigUint64(value) {\n        this.ensureAvailable(8);\n        this._data.setBigUint64(this.offset, value, this.littleEndian);\n        this.offset += 8;\n        this._updateLastWrittenByte();\n        return this;\n    }\n    /**\n     * Write the charCode of `str`'s first character as an 8-bit unsigned integer\n     * and move pointer forward by 1 byte.\n     * @param str - The character to write.\n     * @returns This.\n     */\n    writeChar(str) {\n        // eslint-disable-next-line unicorn/prefer-code-point\n        return this.writeUint8(str.charCodeAt(0));\n    }\n    /**\n     * Write the charCodes of all `str`'s characters as 8-bit unsigned integers\n     * and move pointer forward by `str.length` bytes.\n     * @param str - The characters to write.\n     * @returns This.\n     */\n    writeChars(str) {\n        for (let i = 0; i < str.length; i++) {\n            // eslint-disable-next-line unicorn/prefer-code-point\n            this.writeUint8(str.charCodeAt(i));\n        }\n        return this;\n    }\n    /**\n     * UTF-8 encode and write `str` to the current pointer offset and move pointer\n     * forward according to the encoded length.\n     * @param str - The string to write.\n     * @returns This.\n     */\n    writeUtf8(str) {\n        return this.writeBytes(encode(str));\n    }\n    /**\n     * Export a Uint8Array view of the internal buffer.\n     * The view starts at the byte offset and its length\n     * is calculated to stop at the last written byte or the original length.\n     * @returns A new Uint8Array view.\n     */\n    toArray() {\n        return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);\n    }\n    /**\n     *  Get the total number of bytes written so far, regardless of the current offset.\n     * @returns - Total number of bytes.\n     */\n    getWrittenByteLength() {\n        return this.lastWrittenByte - this.byteOffset;\n    }\n    /**\n     * Update the last written byte offset\n     * @private\n     */\n    _updateLastWrittenByte() {\n        if (this.offset > this.lastWrittenByte) {\n            this.lastWrittenByte = this.offset;\n        }\n    }\n}\n//# sourceMappingURL=iobuffer.js.map","import { IOBuffer } from 'iobuffer';\nexport default class BMPDecoder {\n    bufferData;\n    pixelDataOffset;\n    width;\n    height;\n    bitsPerPixel;\n    xPixelsPerMeter;\n    yPixelsPerMeter;\n    compression;\n    colorMasks;\n    constructor(bufferData) {\n        this.bufferData = new IOBuffer(bufferData);\n        const formatCheck = this.bufferData.readBytes(2);\n        if (formatCheck[0] !== 0x42 && formatCheck[1] !== 0x4d) {\n            throw new Error('This is not a BMP image or the encoding is not correct.');\n        }\n        this.pixelDataOffset = this.bufferData.skip(8).readUint32();\n        this.width = this.bufferData.skip(4).readUint32();\n        this.height = this.bufferData.readUint32();\n        this.bitsPerPixel = this.bufferData.seek(28).readUint16();\n        if (this.bitsPerPixel !== 1 &&\n            this.bitsPerPixel !== 8 &&\n            this.bitsPerPixel !== 24 &&\n            this.bitsPerPixel !== 32) {\n            throw new Error(`Invalid number of bits per pixel. Supported number of bits per pixel: 1, 8, 24, 32. Received: ${this.bitsPerPixel}`);\n        }\n        this.compression = this.bufferData.readUint32();\n        if (this.compression !== 0 && this.compression !== 3) {\n            throw new Error(`Only BI_RGB and BI_BITFIELDS compression methods are allowed. `);\n        }\n        this.colorMasks = [\n            this.bufferData.seek(54).readUint32(),\n            this.bufferData.readUint32(),\n            this.bufferData.readUint32(),\n        ];\n        if (this.bitsPerPixel === 32 &&\n            (this.colorMasks[0] !== 0x00ff0000 ||\n                this.colorMasks[1] !== 0x0000ff00 ||\n                this.colorMasks[2] !== 0x000000ff)) {\n            throw new Error(`Unsupported color masks detected in 32-bit BMP image. Only standard RGBA (${(0x00ff0000).toString(16)}, ${(0x0000ff00).toString(16)}, ${(0x000000ff).toString(16)}) masks are supported. Received: ${this.colorMasks[0].toString(16)},${this.colorMasks[1].toString(16)},${this.colorMasks[2].toString(16)}.`);\n        }\n        this.bufferData.skip(1); // skipping image size.\n        this.xPixelsPerMeter = this.bufferData.seek(38).readInt32();\n        this.yPixelsPerMeter = this.bufferData.readInt32();\n        this.bufferData.skip(1);\n    }\n    decode() {\n        this.bufferData.seek(this.pixelDataOffset);\n        this.bufferData.setBigEndian();\n        const channels = Math.ceil(this.bitsPerPixel / 8);\n        const components = channels % 2 === 0 ? channels - 1 : channels;\n        const data = this.decodePixelData(channels, components);\n        return {\n            width: this.width,\n            height: this.height,\n            bitsPerPixel: this.bitsPerPixel,\n            compression: this.compression,\n            colorMasks: this.colorMasks,\n            channels,\n            components,\n            data,\n            yPixelsPerMeter: this.yPixelsPerMeter,\n            xPixelsPerMeter: this.xPixelsPerMeter,\n        };\n    }\n    decodePixelData(channels, components) {\n        const data = new Uint8Array(this.height * this.width * channels);\n        if (this.bitsPerPixel === 1) {\n            this.decodeBitDepth1Pixels(data);\n        }\n        else if (channels === components) {\n            this.decodeStandardPixels(data, channels);\n        }\n        else {\n            this.decodePixelsWithAlpha(data, channels, components);\n        }\n        return data;\n    }\n    decodeBitDepth1Pixels(data) {\n        let currentNumber = 0;\n        for (let row = 0; row < this.height; row++) {\n            for (let col = 0; col < this.width; col++) {\n                const bitIndex = col % 32;\n                if (bitIndex === 0) {\n                    currentNumber = this.bufferData.readUint32();\n                }\n                if (currentNumber & (1 << (31 - bitIndex))) {\n                    data[(this.height - row - 1) * this.width + col] = 1;\n                }\n            }\n        }\n    }\n    decodeStandardPixels(data, channels) {\n        const padding = this.calculatePadding(channels);\n        for (let row = 0; row < this.height; row++) {\n            const rowOffset = (this.height - row - 1) * this.width;\n            for (let col = 0; col < this.width; col++) {\n                for (let channel = channels - 1; channel >= 0; channel--) {\n                    data[(rowOffset + col) * channels + channel] =\n                        this.bufferData.readByte();\n                }\n            }\n            this.bufferData.skip(padding);\n        }\n    }\n    decodePixelsWithAlpha(data, channels, components) {\n        for (let row = 0; row < this.height; row++) {\n            const rowOffset = (this.height - row - 1) * this.width;\n            for (let col = 0; col < this.width; col++) {\n                const pixelBaseIndex = (rowOffset + col) * channels;\n                // Decode color components\n                for (let component = components - 1; component >= 0; component--) {\n                    data[pixelBaseIndex + component] = this.bufferData.readByte();\n                }\n                // Decode alpha channel\n                data[pixelBaseIndex + components] = this.bufferData.readByte();\n            }\n        }\n    }\n    calculatePadding(channels) {\n        return (this.width * channels) % 4 === 0\n            ? 0\n            : 4 - ((this.width * channels) % 4);\n    }\n}\n//# sourceMappingURL=bmp_decoder.js.map","export const BITMAPV5HEADER = {\n    LogicalColorSpace: {\n        // https://msdn.microsoft.com/en-us/library/cc250396.aspx\n        LCS_CALIBRATED_RGB: 0x00000000,\n        LCS_sRGB: 0x73524742, // eslint-disable-line camelcase\n        LCS_WINDOWS_COLOR_SPACE: 0x57696e20,\n    },\n    Compression: {\n        // https://msdn.microsoft.com/en-us/library/cc250415.aspx\n        BI_RGB: 0x0000, // No compression\n        BI_RLE8: 0x0001,\n        BI_RLE4: 0x0002,\n        BI_BITFIELDS: 0x0003,\n        BI_JPEG: 0x0004,\n        BI_PNG: 0x0005,\n        BI_CMYK: 0x000b,\n        BI_CMYKRLE8: 0x000c,\n        BI_CMYKRLE4: 0x000d,\n    },\n    GamutMappingIntent: {\n        // https://msdn.microsoft.com/en-us/library/cc250392.aspx\n        LCS_GM_ABS_COLORIMETRIC: 0x00000008,\n        LCS_GM_BUSINESS: 0x00000001,\n        LCS_GM_GRAPHICS: 0x00000002,\n        LCS_GM_IMAGES: 0x00000004,\n    },\n    // legacy resolution (72 dpi)\n    DEFAULT_PIXELS_PER_METER: 2835,\n};\n//# sourceMappingURL=constants.js.map","import { IOBuffer } from 'iobuffer';\nimport { BITMAPV5HEADER } from \"./constants.js\";\nexport default class BMPEncoder {\n    width;\n    height;\n    bitsPerPixel;\n    channels;\n    components;\n    data;\n    xPixelsPerMeter;\n    yPixelsPerMeter;\n    encoded = new IOBuffer();\n    compression;\n    colorMasks;\n    constructor(data) {\n        if (!data.height || !data.width) {\n            throw new Error('ImageData width and height are required.');\n        }\n        this.data = data.data;\n        this.width = data.width;\n        this.height = data.height;\n        if (this.data.length !== data.width * data.height * data.channels) {\n            throw new Error('Invalid data length.');\n        }\n        this.bitsPerPixel = data.bitsPerPixel;\n        if (this.bitsPerPixel !== 1 &&\n            this.bitsPerPixel !== 8 &&\n            this.bitsPerPixel !== 24 &&\n            this.bitsPerPixel !== 32) {\n            throw new Error(`Invalid number of bits per pixel. Supported number of bits per pixel: 1, 8, 24, 32. Received: ${this.bitsPerPixel}`);\n        }\n        this.channels = data.channels;\n        this.components =\n            this.channels % 2 === 0 ? this.channels - 1 : this.channels;\n        this.xPixelsPerMeter =\n            data.xPixelsPerMeter ?? BITMAPV5HEADER.DEFAULT_PIXELS_PER_METER;\n        this.yPixelsPerMeter =\n            data.yPixelsPerMeter ?? BITMAPV5HEADER.DEFAULT_PIXELS_PER_METER;\n        this.compression = data.compression ?? 0;\n        this.colorMasks = data.colorMasks ?? [\n            0x00ff0000, 0x0000ff00, 0x000000ff,\n        ];\n    }\n    encode() {\n        this.encoded = new IOBuffer();\n        this.encoded.skip(14);\n        this.writeBitmapV5Header();\n        if (this.bitsPerPixel <= 8) {\n            this.writeColorTable();\n        }\n        const offset = this.encoded.offset;\n        this.writePixelArray();\n        const imageSize = this.encoded.getWrittenByteLength();\n        this.encoded.rewind();\n        this.writeBitmapFileHeader(offset, imageSize);\n        return this.encoded.toArray();\n    }\n    writePixelArray() {\n        this.encoded.setBigEndian();\n        if (this.bitsPerPixel === 1) {\n            this.writeBitDepth1Pixels();\n        }\n        else if (this.channels === this.components) {\n            this.writeStandardPixels();\n        }\n        else {\n            this.writePixelsWithAlpha();\n        }\n        this.encoded.setLittleEndian();\n    }\n    writeBitDepth1Pixels() {\n        let byte = 0;\n        for (let row = this.height - 1; row >= 0; row--) {\n            for (let col = 0; col < this.width; col++) {\n                if (col % 32 === 0 && col !== 0) {\n                    this.encoded.writeUint32(byte);\n                    byte = 0;\n                }\n                byte |= this.data[row * this.width + col] << (31 - (col % 32));\n            }\n            this.encoded.writeUint32(byte);\n            byte = 0;\n        }\n    }\n    writeStandardPixels() {\n        for (let row = 0; row < this.height; row++) {\n            const rowOffset = this.width * (this.height - row - 1) * this.channels;\n            for (let col = 0; col < this.width; col++) {\n                for (let channel = this.channels - 1; channel >= 0; channel--) {\n                    this.encoded.writeByte(this.data[rowOffset + col * this.channels + channel]);\n                }\n            }\n            this.writePadding();\n        }\n    }\n    writePixelsWithAlpha() {\n        const pixel = 0;\n        for (let row = 0; row < this.height; row++) {\n            const rowOffset = this.width * (this.height - row - 1);\n            for (let col = 0; col < this.width; col++) {\n                const pixelIndex = (rowOffset + col) * this.channels;\n                this.encoded.writeUint32(pixel |\n                    (this.data[pixelIndex + 2] << (3 * 8)) |\n                    (this.data[pixelIndex + 1] << (2 * 8)) |\n                    (this.data[pixelIndex] << 8) |\n                    this.data[pixelIndex + 3]);\n            }\n        }\n    }\n    writePadding() {\n        const padding = (this.width * this.channels) % 4 === 0\n            ? 0\n            : 4 - ((this.width * this.channels) % 4);\n        for (let i = 0; i < padding; i++) {\n            this.encoded.writeByte(0);\n        }\n    }\n    writeColorTable() {\n        if (this.bitsPerPixel === 1) {\n            this.encoded\n                .writeUint32(0x00000000) // black\n                .writeUint32(0x00ffffff); // white\n        }\n        else {\n            //Grayscale 8 bit\n            for (let i = 0; i < 256; i++) {\n                this.encoded.writeUint32(0x00000000 | (i << (4 * 4)) | (i << (2 * 4)) | i);\n            }\n        }\n    }\n    writeBitmapFileHeader(imageOffset, fileSize) {\n        this.encoded\n            .writeChars('BM') // 14 bytes bitmap file header\n            .writeInt32(fileSize) // Size of BMP file in bytes\n            .writeUint16(0)\n            .writeUint16(0)\n            .writeUint32(imageOffset);\n    }\n    writeBitmapV5Header() {\n        const rowSize = Math.floor((this.bitsPerPixel * this.width + 31) / 32) * 4;\n        const totalBytes = rowSize * this.height;\n        // Size of the header\n        this.encoded\n            .writeUint32(124) // Header size, offset 14\n            .writeInt32(this.width) // bV5Width, offset 18\n            .writeInt32(this.height) // bV5Height, offset 22\n            .writeUint16(1) // bv5Planes - must be set to 1, offset 26\n            .writeUint16(this.bitsPerPixel) // bV5BitCount, offset 30\n            .writeUint32(this.compression) // bV5Compression - No compression, offset 34\n            .writeUint32(totalBytes) // bv5SizeImage - size of pixel buffer (can be 0 if uncompressed), offset 38\n            .writeInt32(this.xPixelsPerMeter) // bV5XPelsPerMeter - resolution, offset 42\n            .writeInt32(this.yPixelsPerMeter) // bV5YPelsPerMeter - resolution, offset 46\n            .writeUint32(this.bitsPerPixel <= 8 ? 2 ** this.bitsPerPixel : 0) // number of colors used, set to 0 if number of pixels is bigger than 8 set to 0, offset 50\n            .writeUint32(this.bitsPerPixel <= 8 ? 2 ** this.bitsPerPixel : 0); // number of important colors, set to 0 if number of pixels is bigger than 8 set to 0,  offset 54\n        if (this.bitsPerPixel === 32 &&\n            (this.colorMasks[0] !== 0x00ff0000 ||\n                this.colorMasks[1] !== 0x0000ff00 ||\n                this.colorMasks[2] !== 0x000000ff)) {\n            throw new Error(`Unsupported color masks detected in 32-bit BMP image. Only standard RGBA (${(0x00ff0000).toString(16)}, ${(0x0000ff00).toString(16)}, ${(0x000000ff).toString(16)}) masks are supported. Received: ${this.colorMasks[0].toString(16)},${this.colorMasks[1].toString(16)},${this.colorMasks[2].toString(16)}.`);\n        }\n        this.encoded\n            .writeUint32(this.colorMasks[0]) // bV5RedMask, offset 58\n            .writeUint32(this.colorMasks[1]) // bV5GreenMask, offset 62\n            .writeUint32(this.colorMasks[2]) // bV5BlueMask, offset 66\n            .writeUint32(this.channels === this.components ? 0x00000000 : 0xff000000) // bv5ReservedData\n            .writeUint32(BITMAPV5HEADER.LogicalColorSpace.LCS_sRGB)\n            .skip(36) // bV5Endpoints\n            .skip(12) // bV5GammaRed, Green, Blue\n            .writeUint32(BITMAPV5HEADER.GamutMappingIntent.LCS_GM_GRAPHICS)\n            .skip(12); // ProfileData, ProfileSize, Reserved\n    }\n}\n//# sourceMappingURL=bmp_encoder.js.map","import Decoder from \"./bmp_decoder.js\";\nimport Encoder from \"./bmp_encoder.js\";\n/**\n * Encodes data into BMP format.\n * @param data - Data for encoding.\n * @returns typed array buffer.\n */\nexport function encode(data) {\n    const encoder = new Encoder(data);\n    return encoder.encode();\n}\n/**\n * Decodes BMP format image into data.\n * @param data - Buffer with image data.\n * @returns - Decoded data.\n */\nexport function decode(data) {\n    const decoder = new Decoder(data);\n    return decoder.decode();\n}\n//# sourceMappingURL=index.js.map","import * as bmp from 'fast-bmp';\nimport { Image } from '../Image.js';\n/**\n * Creates a BMP buffer from a mask.\n * @param image - The mask instance.\n * @returns The buffer.\n */\nexport function encodeBmp(image) {\n    if (image instanceof Image) {\n        return bmp.encode({\n            width: image.width,\n            height: image.height,\n            components: image.components,\n            bitsPerPixel: image.channels * image.bitDepth,\n            channels: image.channels,\n            data: image.getRawImage().data,\n        });\n    }\n    else {\n        return bmp.encode({\n            width: image.width,\n            height: image.height,\n            components: 1,\n            bitsPerPixel: 1,\n            channels: 1,\n            data: image.getRawImage().data,\n        });\n    }\n}\n//# sourceMappingURL=encodeBmp.js.map","/*\n  Copyright (c) 2008, Adobe Systems Incorporated\n  All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without \n  modification, are permitted provided that the following conditions are\n  met:\n\n  * Redistributions of source code must retain the above copyright notice, \n    this list of conditions and the following disclaimer.\n  \n  * Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the \n    documentation and/or other materials provided with the distribution.\n  \n  * Neither the name of Adobe Systems Incorporated nor the names of its \n    contributors may be used to endorse or promote products derived from \n    this software without specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n  IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR \n  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n/*\nJPEG encoder ported to JavaScript and optimized by Andreas Ritter, www.bytestrom.eu, 11/2009\n\nBasic GUI blocking jpeg encoder\n*/\n\nvar btoa = btoa || function(buf) {\n  return Buffer.from(buf).toString('base64');\n};\n\nfunction JPEGEncoder(quality) {\n  var self = this;\n\tvar fround = Math.round;\n\tvar ffloor = Math.floor;\n\tvar YTable = new Array(64);\n\tvar UVTable = new Array(64);\n\tvar fdtbl_Y = new Array(64);\n\tvar fdtbl_UV = new Array(64);\n\tvar YDC_HT;\n\tvar UVDC_HT;\n\tvar YAC_HT;\n\tvar UVAC_HT;\n\t\n\tvar bitcode = new Array(65535);\n\tvar category = new Array(65535);\n\tvar outputfDCTQuant = new Array(64);\n\tvar DU = new Array(64);\n\tvar byteout = [];\n\tvar bytenew = 0;\n\tvar bytepos = 7;\n\t\n\tvar YDU = new Array(64);\n\tvar UDU = new Array(64);\n\tvar VDU = new Array(64);\n\tvar clt = new Array(256);\n\tvar RGB_YUV_TABLE = new Array(2048);\n\tvar currentQuality;\n\t\n\tvar ZigZag = [\n\t\t\t 0, 1, 5, 6,14,15,27,28,\n\t\t\t 2, 4, 7,13,16,26,29,42,\n\t\t\t 3, 8,12,17,25,30,41,43,\n\t\t\t 9,11,18,24,31,40,44,53,\n\t\t\t10,19,23,32,39,45,52,54,\n\t\t\t20,22,33,38,46,51,55,60,\n\t\t\t21,34,37,47,50,56,59,61,\n\t\t\t35,36,48,49,57,58,62,63\n\t\t];\n\t\n\tvar std_dc_luminance_nrcodes = [0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0];\n\tvar std_dc_luminance_values = [0,1,2,3,4,5,6,7,8,9,10,11];\n\tvar std_ac_luminance_nrcodes = [0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,0x7d];\n\tvar std_ac_luminance_values = [\n\t\t\t0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,\n\t\t\t0x21,0x31,0x41,0x06,0x13,0x51,0x61,0x07,\n\t\t\t0x22,0x71,0x14,0x32,0x81,0x91,0xa1,0x08,\n\t\t\t0x23,0x42,0xb1,0xc1,0x15,0x52,0xd1,0xf0,\n\t\t\t0x24,0x33,0x62,0x72,0x82,0x09,0x0a,0x16,\n\t\t\t0x17,0x18,0x19,0x1a,0x25,0x26,0x27,0x28,\n\t\t\t0x29,0x2a,0x34,0x35,0x36,0x37,0x38,0x39,\n\t\t\t0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,\n\t\t\t0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,\n\t\t\t0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,\n\t\t\t0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,\n\t\t\t0x7a,0x83,0x84,0x85,0x86,0x87,0x88,0x89,\n\t\t\t0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,\n\t\t\t0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,\n\t\t\t0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,\n\t\t\t0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,\n\t\t\t0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,\n\t\t\t0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xe1,0xe2,\n\t\t\t0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,\n\t\t\t0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,\n\t\t\t0xf9,0xfa\n\t\t];\n\t\n\tvar std_dc_chrominance_nrcodes = [0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0];\n\tvar std_dc_chrominance_values = [0,1,2,3,4,5,6,7,8,9,10,11];\n\tvar std_ac_chrominance_nrcodes = [0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,0x77];\n\tvar std_ac_chrominance_values = [\n\t\t\t0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,\n\t\t\t0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,\n\t\t\t0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,\n\t\t\t0xa1,0xb1,0xc1,0x09,0x23,0x33,0x52,0xf0,\n\t\t\t0x15,0x62,0x72,0xd1,0x0a,0x16,0x24,0x34,\n\t\t\t0xe1,0x25,0xf1,0x17,0x18,0x19,0x1a,0x26,\n\t\t\t0x27,0x28,0x29,0x2a,0x35,0x36,0x37,0x38,\n\t\t\t0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,\n\t\t\t0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,\n\t\t\t0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,\n\t\t\t0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,\n\t\t\t0x79,0x7a,0x82,0x83,0x84,0x85,0x86,0x87,\n\t\t\t0x88,0x89,0x8a,0x92,0x93,0x94,0x95,0x96,\n\t\t\t0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,\n\t\t\t0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,\n\t\t\t0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,\n\t\t\t0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,\n\t\t\t0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,\n\t\t\t0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,\n\t\t\t0xea,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,\n\t\t\t0xf9,0xfa\n\t\t];\n\t\n\tfunction initQuantTables(sf){\n\t\t\tvar YQT = [\n\t\t\t\t16, 11, 10, 16, 24, 40, 51, 61,\n\t\t\t\t12, 12, 14, 19, 26, 58, 60, 55,\n\t\t\t\t14, 13, 16, 24, 40, 57, 69, 56,\n\t\t\t\t14, 17, 22, 29, 51, 87, 80, 62,\n\t\t\t\t18, 22, 37, 56, 68,109,103, 77,\n\t\t\t\t24, 35, 55, 64, 81,104,113, 92,\n\t\t\t\t49, 64, 78, 87,103,121,120,101,\n\t\t\t\t72, 92, 95, 98,112,100,103, 99\n\t\t\t];\n\t\t\t\n\t\t\tfor (var i = 0; i < 64; i++) {\n\t\t\t\tvar t = ffloor((YQT[i]*sf+50)/100);\n\t\t\t\tif (t < 1) {\n\t\t\t\t\tt = 1;\n\t\t\t\t} else if (t > 255) {\n\t\t\t\t\tt = 255;\n\t\t\t\t}\n\t\t\t\tYTable[ZigZag[i]] = t;\n\t\t\t}\n\t\t\tvar UVQT = [\n\t\t\t\t17, 18, 24, 47, 99, 99, 99, 99,\n\t\t\t\t18, 21, 26, 66, 99, 99, 99, 99,\n\t\t\t\t24, 26, 56, 99, 99, 99, 99, 99,\n\t\t\t\t47, 66, 99, 99, 99, 99, 99, 99,\n\t\t\t\t99, 99, 99, 99, 99, 99, 99, 99,\n\t\t\t\t99, 99, 99, 99, 99, 99, 99, 99,\n\t\t\t\t99, 99, 99, 99, 99, 99, 99, 99,\n\t\t\t\t99, 99, 99, 99, 99, 99, 99, 99\n\t\t\t];\n\t\t\tfor (var j = 0; j < 64; j++) {\n\t\t\t\tvar u = ffloor((UVQT[j]*sf+50)/100);\n\t\t\t\tif (u < 1) {\n\t\t\t\t\tu = 1;\n\t\t\t\t} else if (u > 255) {\n\t\t\t\t\tu = 255;\n\t\t\t\t}\n\t\t\t\tUVTable[ZigZag[j]] = u;\n\t\t\t}\n\t\t\tvar aasf = [\n\t\t\t\t1.0, 1.387039845, 1.306562965, 1.175875602,\n\t\t\t\t1.0, 0.785694958, 0.541196100, 0.275899379\n\t\t\t];\n\t\t\tvar k = 0;\n\t\t\tfor (var row = 0; row < 8; row++)\n\t\t\t{\n\t\t\t\tfor (var col = 0; col < 8; col++)\n\t\t\t\t{\n\t\t\t\t\tfdtbl_Y[k]  = (1.0 / (YTable [ZigZag[k]] * aasf[row] * aasf[col] * 8.0));\n\t\t\t\t\tfdtbl_UV[k] = (1.0 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8.0));\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction computeHuffmanTbl(nrcodes, std_table){\n\t\t\tvar codevalue = 0;\n\t\t\tvar pos_in_table = 0;\n\t\t\tvar HT = new Array();\n\t\t\tfor (var k = 1; k <= 16; k++) {\n\t\t\t\tfor (var j = 1; j <= nrcodes[k]; j++) {\n\t\t\t\t\tHT[std_table[pos_in_table]] = [];\n\t\t\t\t\tHT[std_table[pos_in_table]][0] = codevalue;\n\t\t\t\t\tHT[std_table[pos_in_table]][1] = k;\n\t\t\t\t\tpos_in_table++;\n\t\t\t\t\tcodevalue++;\n\t\t\t\t}\n\t\t\t\tcodevalue*=2;\n\t\t\t}\n\t\t\treturn HT;\n\t\t}\n\t\t\n\t\tfunction initHuffmanTbl()\n\t\t{\n\t\t\tYDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes,std_dc_luminance_values);\n\t\t\tUVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes,std_dc_chrominance_values);\n\t\t\tYAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes,std_ac_luminance_values);\n\t\t\tUVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes,std_ac_chrominance_values);\n\t\t}\n\t\n\t\tfunction initCategoryNumber()\n\t\t{\n\t\t\tvar nrlower = 1;\n\t\t\tvar nrupper = 2;\n\t\t\tfor (var cat = 1; cat <= 15; cat++) {\n\t\t\t\t//Positive numbers\n\t\t\t\tfor (var nr = nrlower; nr<nrupper; nr++) {\n\t\t\t\t\tcategory[32767+nr] = cat;\n\t\t\t\t\tbitcode[32767+nr] = [];\n\t\t\t\t\tbitcode[32767+nr][1] = cat;\n\t\t\t\t\tbitcode[32767+nr][0] = nr;\n\t\t\t\t}\n\t\t\t\t//Negative numbers\n\t\t\t\tfor (var nrneg =-(nrupper-1); nrneg<=-nrlower; nrneg++) {\n\t\t\t\t\tcategory[32767+nrneg] = cat;\n\t\t\t\t\tbitcode[32767+nrneg] = [];\n\t\t\t\t\tbitcode[32767+nrneg][1] = cat;\n\t\t\t\t\tbitcode[32767+nrneg][0] = nrupper-1+nrneg;\n\t\t\t\t}\n\t\t\t\tnrlower <<= 1;\n\t\t\t\tnrupper <<= 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction initRGBYUVTable() {\n\t\t\tfor(var i = 0; i < 256;i++) {\n\t\t\t\tRGB_YUV_TABLE[i]      \t\t=  19595 * i;\n\t\t\t\tRGB_YUV_TABLE[(i+ 256)>>0] \t=  38470 * i;\n\t\t\t\tRGB_YUV_TABLE[(i+ 512)>>0] \t=   7471 * i + 0x8000;\n\t\t\t\tRGB_YUV_TABLE[(i+ 768)>>0] \t= -11059 * i;\n\t\t\t\tRGB_YUV_TABLE[(i+1024)>>0] \t= -21709 * i;\n\t\t\t\tRGB_YUV_TABLE[(i+1280)>>0] \t=  32768 * i + 0x807FFF;\n\t\t\t\tRGB_YUV_TABLE[(i+1536)>>0] \t= -27439 * i;\n\t\t\t\tRGB_YUV_TABLE[(i+1792)>>0] \t= - 5329 * i;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// IO functions\n\t\tfunction writeBits(bs)\n\t\t{\n\t\t\tvar value = bs[0];\n\t\t\tvar posval = bs[1]-1;\n\t\t\twhile ( posval >= 0 ) {\n\t\t\t\tif (value & (1 << posval) ) {\n\t\t\t\t\tbytenew |= (1 << bytepos);\n\t\t\t\t}\n\t\t\t\tposval--;\n\t\t\t\tbytepos--;\n\t\t\t\tif (bytepos < 0) {\n\t\t\t\t\tif (bytenew == 0xFF) {\n\t\t\t\t\t\twriteByte(0xFF);\n\t\t\t\t\t\twriteByte(0);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteByte(bytenew);\n\t\t\t\t\t}\n\t\t\t\t\tbytepos=7;\n\t\t\t\t\tbytenew=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction writeByte(value)\n\t\t{\n\t\t\t//byteout.push(clt[value]); // write char directly instead of converting later\n      byteout.push(value);\n\t\t}\n\t\n\t\tfunction writeWord(value)\n\t\t{\n\t\t\twriteByte((value>>8)&0xFF);\n\t\t\twriteByte((value   )&0xFF);\n\t\t}\n\t\t\n\t\t// DCT & quantization core\n\t\tfunction fDCTQuant(data, fdtbl)\n\t\t{\n\t\t\tvar d0, d1, d2, d3, d4, d5, d6, d7;\n\t\t\t/* Pass 1: process rows. */\n\t\t\tvar dataOff=0;\n\t\t\tvar i;\n\t\t\tvar I8 = 8;\n\t\t\tvar I64 = 64;\n\t\t\tfor (i=0; i<I8; ++i)\n\t\t\t{\n\t\t\t\td0 = data[dataOff];\n\t\t\t\td1 = data[dataOff+1];\n\t\t\t\td2 = data[dataOff+2];\n\t\t\t\td3 = data[dataOff+3];\n\t\t\t\td4 = data[dataOff+4];\n\t\t\t\td5 = data[dataOff+5];\n\t\t\t\td6 = data[dataOff+6];\n\t\t\t\td7 = data[dataOff+7];\n\t\t\t\t\n\t\t\t\tvar tmp0 = d0 + d7;\n\t\t\t\tvar tmp7 = d0 - d7;\n\t\t\t\tvar tmp1 = d1 + d6;\n\t\t\t\tvar tmp6 = d1 - d6;\n\t\t\t\tvar tmp2 = d2 + d5;\n\t\t\t\tvar tmp5 = d2 - d5;\n\t\t\t\tvar tmp3 = d3 + d4;\n\t\t\t\tvar tmp4 = d3 - d4;\n\t\n\t\t\t\t/* Even part */\n\t\t\t\tvar tmp10 = tmp0 + tmp3;\t/* phase 2 */\n\t\t\t\tvar tmp13 = tmp0 - tmp3;\n\t\t\t\tvar tmp11 = tmp1 + tmp2;\n\t\t\t\tvar tmp12 = tmp1 - tmp2;\n\t\n\t\t\t\tdata[dataOff] = tmp10 + tmp11; /* phase 3 */\n\t\t\t\tdata[dataOff+4] = tmp10 - tmp11;\n\t\n\t\t\t\tvar z1 = (tmp12 + tmp13) * 0.707106781; /* c4 */\n\t\t\t\tdata[dataOff+2] = tmp13 + z1; /* phase 5 */\n\t\t\t\tdata[dataOff+6] = tmp13 - z1;\n\t\n\t\t\t\t/* Odd part */\n\t\t\t\ttmp10 = tmp4 + tmp5; /* phase 2 */\n\t\t\t\ttmp11 = tmp5 + tmp6;\n\t\t\t\ttmp12 = tmp6 + tmp7;\n\t\n\t\t\t\t/* The rotator is modified from fig 4-8 to avoid extra negations. */\n\t\t\t\tvar z5 = (tmp10 - tmp12) * 0.382683433; /* c6 */\n\t\t\t\tvar z2 = 0.541196100 * tmp10 + z5; /* c2-c6 */\n\t\t\t\tvar z4 = 1.306562965 * tmp12 + z5; /* c2+c6 */\n\t\t\t\tvar z3 = tmp11 * 0.707106781; /* c4 */\n\t\n\t\t\t\tvar z11 = tmp7 + z3;\t/* phase 5 */\n\t\t\t\tvar z13 = tmp7 - z3;\n\t\n\t\t\t\tdata[dataOff+5] = z13 + z2;\t/* phase 6 */\n\t\t\t\tdata[dataOff+3] = z13 - z2;\n\t\t\t\tdata[dataOff+1] = z11 + z4;\n\t\t\t\tdata[dataOff+7] = z11 - z4;\n\t\n\t\t\t\tdataOff += 8; /* advance pointer to next row */\n\t\t\t}\n\t\n\t\t\t/* Pass 2: process columns. */\n\t\t\tdataOff = 0;\n\t\t\tfor (i=0; i<I8; ++i)\n\t\t\t{\n\t\t\t\td0 = data[dataOff];\n\t\t\t\td1 = data[dataOff + 8];\n\t\t\t\td2 = data[dataOff + 16];\n\t\t\t\td3 = data[dataOff + 24];\n\t\t\t\td4 = data[dataOff + 32];\n\t\t\t\td5 = data[dataOff + 40];\n\t\t\t\td6 = data[dataOff + 48];\n\t\t\t\td7 = data[dataOff + 56];\n\t\t\t\t\n\t\t\t\tvar tmp0p2 = d0 + d7;\n\t\t\t\tvar tmp7p2 = d0 - d7;\n\t\t\t\tvar tmp1p2 = d1 + d6;\n\t\t\t\tvar tmp6p2 = d1 - d6;\n\t\t\t\tvar tmp2p2 = d2 + d5;\n\t\t\t\tvar tmp5p2 = d2 - d5;\n\t\t\t\tvar tmp3p2 = d3 + d4;\n\t\t\t\tvar tmp4p2 = d3 - d4;\n\t\n\t\t\t\t/* Even part */\n\t\t\t\tvar tmp10p2 = tmp0p2 + tmp3p2;\t/* phase 2 */\n\t\t\t\tvar tmp13p2 = tmp0p2 - tmp3p2;\n\t\t\t\tvar tmp11p2 = tmp1p2 + tmp2p2;\n\t\t\t\tvar tmp12p2 = tmp1p2 - tmp2p2;\n\t\n\t\t\t\tdata[dataOff] = tmp10p2 + tmp11p2; /* phase 3 */\n\t\t\t\tdata[dataOff+32] = tmp10p2 - tmp11p2;\n\t\n\t\t\t\tvar z1p2 = (tmp12p2 + tmp13p2) * 0.707106781; /* c4 */\n\t\t\t\tdata[dataOff+16] = tmp13p2 + z1p2; /* phase 5 */\n\t\t\t\tdata[dataOff+48] = tmp13p2 - z1p2;\n\t\n\t\t\t\t/* Odd part */\n\t\t\t\ttmp10p2 = tmp4p2 + tmp5p2; /* phase 2 */\n\t\t\t\ttmp11p2 = tmp5p2 + tmp6p2;\n\t\t\t\ttmp12p2 = tmp6p2 + tmp7p2;\n\t\n\t\t\t\t/* The rotator is modified from fig 4-8 to avoid extra negations. */\n\t\t\t\tvar z5p2 = (tmp10p2 - tmp12p2) * 0.382683433; /* c6 */\n\t\t\t\tvar z2p2 = 0.541196100 * tmp10p2 + z5p2; /* c2-c6 */\n\t\t\t\tvar z4p2 = 1.306562965 * tmp12p2 + z5p2; /* c2+c6 */\n\t\t\t\tvar z3p2 = tmp11p2 * 0.707106781; /* c4 */\n\t\n\t\t\t\tvar z11p2 = tmp7p2 + z3p2;\t/* phase 5 */\n\t\t\t\tvar z13p2 = tmp7p2 - z3p2;\n\t\n\t\t\t\tdata[dataOff+40] = z13p2 + z2p2; /* phase 6 */\n\t\t\t\tdata[dataOff+24] = z13p2 - z2p2;\n\t\t\t\tdata[dataOff+ 8] = z11p2 + z4p2;\n\t\t\t\tdata[dataOff+56] = z11p2 - z4p2;\n\t\n\t\t\t\tdataOff++; /* advance pointer to next column */\n\t\t\t}\n\t\n\t\t\t// Quantize/descale the coefficients\n\t\t\tvar fDCTQuant;\n\t\t\tfor (i=0; i<I64; ++i)\n\t\t\t{\n\t\t\t\t// Apply the quantization and scaling factor & Round to nearest integer\n\t\t\t\tfDCTQuant = data[i]*fdtbl[i];\n\t\t\t\toutputfDCTQuant[i] = (fDCTQuant > 0.0) ? ((fDCTQuant + 0.5)|0) : ((fDCTQuant - 0.5)|0);\n\t\t\t\t//outputfDCTQuant[i] = fround(fDCTQuant);\n\n\t\t\t}\n\t\t\treturn outputfDCTQuant;\n\t\t}\n\t\t\n\t\tfunction writeAPP0()\n\t\t{\n\t\t\twriteWord(0xFFE0); // marker\n\t\t\twriteWord(16); // length\n\t\t\twriteByte(0x4A); // J\n\t\t\twriteByte(0x46); // F\n\t\t\twriteByte(0x49); // I\n\t\t\twriteByte(0x46); // F\n\t\t\twriteByte(0); // = \"JFIF\",'\\0'\n\t\t\twriteByte(1); // versionhi\n\t\t\twriteByte(1); // versionlo\n\t\t\twriteByte(0); // xyunits\n\t\t\twriteWord(1); // xdensity\n\t\t\twriteWord(1); // ydensity\n\t\t\twriteByte(0); // thumbnwidth\n\t\t\twriteByte(0); // thumbnheight\n\t\t}\n\n\t\tfunction writeAPP1(exifBuffer) {\n\t\t\tif (!exifBuffer) return;\n\n\t\t\twriteWord(0xFFE1); // APP1 marker\n\n\t\t\tif (exifBuffer[0] === 0x45 &&\n\t\t\t\t\texifBuffer[1] === 0x78 &&\n\t\t\t\t\texifBuffer[2] === 0x69 &&\n\t\t\t\t\texifBuffer[3] === 0x66) {\n\t\t\t\t// Buffer already starts with EXIF, just use it directly\n\t\t\t\twriteWord(exifBuffer.length + 2); // length is buffer + length itself!\n\t\t\t} else {\n\t\t\t\t// Buffer doesn't start with EXIF, write it for them\n\t\t\t\twriteWord(exifBuffer.length + 5 + 2); // length is buffer + EXIF\\0 + length itself!\n\t\t\t\twriteByte(0x45); // E\n\t\t\t\twriteByte(0x78); // X\n\t\t\t\twriteByte(0x69); // I\n\t\t\t\twriteByte(0x66); // F\n\t\t\t\twriteByte(0); // = \"EXIF\",'\\0'\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < exifBuffer.length; i++) {\n\t\t\t\twriteByte(exifBuffer[i]);\n\t\t\t}\n\t\t}\n\n\t\tfunction writeSOF0(width, height)\n\t\t{\n\t\t\twriteWord(0xFFC0); // marker\n\t\t\twriteWord(17);   // length, truecolor YUV JPG\n\t\t\twriteByte(8);    // precision\n\t\t\twriteWord(height);\n\t\t\twriteWord(width);\n\t\t\twriteByte(3);    // nrofcomponents\n\t\t\twriteByte(1);    // IdY\n\t\t\twriteByte(0x11); // HVY\n\t\t\twriteByte(0);    // QTY\n\t\t\twriteByte(2);    // IdU\n\t\t\twriteByte(0x11); // HVU\n\t\t\twriteByte(1);    // QTU\n\t\t\twriteByte(3);    // IdV\n\t\t\twriteByte(0x11); // HVV\n\t\t\twriteByte(1);    // QTV\n\t\t}\n\t\n\t\tfunction writeDQT()\n\t\t{\n\t\t\twriteWord(0xFFDB); // marker\n\t\t\twriteWord(132);\t   // length\n\t\t\twriteByte(0);\n\t\t\tfor (var i=0; i<64; i++) {\n\t\t\t\twriteByte(YTable[i]);\n\t\t\t}\n\t\t\twriteByte(1);\n\t\t\tfor (var j=0; j<64; j++) {\n\t\t\t\twriteByte(UVTable[j]);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction writeDHT()\n\t\t{\n\t\t\twriteWord(0xFFC4); // marker\n\t\t\twriteWord(0x01A2); // length\n\t\n\t\t\twriteByte(0); // HTYDCinfo\n\t\t\tfor (var i=0; i<16; i++) {\n\t\t\t\twriteByte(std_dc_luminance_nrcodes[i+1]);\n\t\t\t}\n\t\t\tfor (var j=0; j<=11; j++) {\n\t\t\t\twriteByte(std_dc_luminance_values[j]);\n\t\t\t}\n\t\n\t\t\twriteByte(0x10); // HTYACinfo\n\t\t\tfor (var k=0; k<16; k++) {\n\t\t\t\twriteByte(std_ac_luminance_nrcodes[k+1]);\n\t\t\t}\n\t\t\tfor (var l=0; l<=161; l++) {\n\t\t\t\twriteByte(std_ac_luminance_values[l]);\n\t\t\t}\n\t\n\t\t\twriteByte(1); // HTUDCinfo\n\t\t\tfor (var m=0; m<16; m++) {\n\t\t\t\twriteByte(std_dc_chrominance_nrcodes[m+1]);\n\t\t\t}\n\t\t\tfor (var n=0; n<=11; n++) {\n\t\t\t\twriteByte(std_dc_chrominance_values[n]);\n\t\t\t}\n\t\n\t\t\twriteByte(0x11); // HTUACinfo\n\t\t\tfor (var o=0; o<16; o++) {\n\t\t\t\twriteByte(std_ac_chrominance_nrcodes[o+1]);\n\t\t\t}\n\t\t\tfor (var p=0; p<=161; p++) {\n\t\t\t\twriteByte(std_ac_chrominance_values[p]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction writeCOM(comments)\n\t\t{\n\t\t\tif (typeof comments === \"undefined\" || comments.constructor !== Array) return;\n\t\t\tcomments.forEach(e => {\n\t\t\t\tif (typeof e !== \"string\") return;\n\t\t\t\twriteWord(0xFFFE); // marker\n\t\t\t\tvar l = e.length;\n\t\t\t\twriteWord(l + 2); // length itself as well\n\t\t\t\tvar i;\n\t\t\t\tfor (i = 0; i < l; i++)\n\t\t\t\t\twriteByte(e.charCodeAt(i));\n\t\t\t});\n\t\t}\n\t\n\t\tfunction writeSOS()\n\t\t{\n\t\t\twriteWord(0xFFDA); // marker\n\t\t\twriteWord(12); // length\n\t\t\twriteByte(3); // nrofcomponents\n\t\t\twriteByte(1); // IdY\n\t\t\twriteByte(0); // HTY\n\t\t\twriteByte(2); // IdU\n\t\t\twriteByte(0x11); // HTU\n\t\t\twriteByte(3); // IdV\n\t\t\twriteByte(0x11); // HTV\n\t\t\twriteByte(0); // Ss\n\t\t\twriteByte(0x3f); // Se\n\t\t\twriteByte(0); // Bf\n\t\t}\n\t\t\n\t\tfunction processDU(CDU, fdtbl, DC, HTDC, HTAC){\n\t\t\tvar EOB = HTAC[0x00];\n\t\t\tvar M16zeroes = HTAC[0xF0];\n\t\t\tvar pos;\n\t\t\tvar I16 = 16;\n\t\t\tvar I63 = 63;\n\t\t\tvar I64 = 64;\n\t\t\tvar DU_DCT = fDCTQuant(CDU, fdtbl);\n\t\t\t//ZigZag reorder\n\t\t\tfor (var j=0;j<I64;++j) {\n\t\t\t\tDU[ZigZag[j]]=DU_DCT[j];\n\t\t\t}\n\t\t\tvar Diff = DU[0] - DC; DC = DU[0];\n\t\t\t//Encode DC\n\t\t\tif (Diff==0) {\n\t\t\t\twriteBits(HTDC[0]); // Diff might be 0\n\t\t\t} else {\n\t\t\t\tpos = 32767+Diff;\n\t\t\t\twriteBits(HTDC[category[pos]]);\n\t\t\t\twriteBits(bitcode[pos]);\n\t\t\t}\n\t\t\t//Encode ACs\n\t\t\tvar end0pos = 63; // was const... which is crazy\n\t\t\tfor (; (end0pos>0)&&(DU[end0pos]==0); end0pos--) {};\n\t\t\t//end0pos = first element in reverse order !=0\n\t\t\tif ( end0pos == 0) {\n\t\t\t\twriteBits(EOB);\n\t\t\t\treturn DC;\n\t\t\t}\n\t\t\tvar i = 1;\n\t\t\tvar lng;\n\t\t\twhile ( i <= end0pos ) {\n\t\t\t\tvar startpos = i;\n\t\t\t\tfor (; (DU[i]==0) && (i<=end0pos); ++i) {}\n\t\t\t\tvar nrzeroes = i-startpos;\n\t\t\t\tif ( nrzeroes >= I16 ) {\n\t\t\t\t\tlng = nrzeroes>>4;\n\t\t\t\t\tfor (var nrmarker=1; nrmarker <= lng; ++nrmarker)\n\t\t\t\t\t\twriteBits(M16zeroes);\n\t\t\t\t\tnrzeroes = nrzeroes&0xF;\n\t\t\t\t}\n\t\t\t\tpos = 32767+DU[i];\n\t\t\t\twriteBits(HTAC[(nrzeroes<<4)+category[pos]]);\n\t\t\t\twriteBits(bitcode[pos]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif ( end0pos != I63 ) {\n\t\t\t\twriteBits(EOB);\n\t\t\t}\n\t\t\treturn DC;\n\t\t}\n\n\t\tfunction initCharLookupTable(){\n\t\t\tvar sfcc = String.fromCharCode;\n\t\t\tfor(var i=0; i < 256; i++){ ///// ACHTUNG // 255\n\t\t\t\tclt[i] = sfcc(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.encode = function(image,quality) // image data object\n\t\t{\n\t\t\tvar time_start = new Date().getTime();\n\t\t\t\n\t\t\tif(quality) setQuality(quality);\n\t\t\t\n\t\t\t// Initialize bit writer\n\t\t\tbyteout = new Array();\n\t\t\tbytenew=0;\n\t\t\tbytepos=7;\n\t\n\t\t\t// Add JPEG headers\n\t\t\twriteWord(0xFFD8); // SOI\n\t\t\twriteAPP0();\n\t\t\twriteCOM(image.comments);\n\t\t\twriteAPP1(image.exifBuffer);\n\t\t\twriteDQT();\n\t\t\twriteSOF0(image.width,image.height);\n\t\t\twriteDHT();\n\t\t\twriteSOS();\n\n\t\n\t\t\t// Encode 8x8 macroblocks\n\t\t\tvar DCY=0;\n\t\t\tvar DCU=0;\n\t\t\tvar DCV=0;\n\t\t\t\n\t\t\tbytenew=0;\n\t\t\tbytepos=7;\n\t\t\t\n\t\t\t\n\t\t\tthis.encode.displayName = \"_encode_\";\n\n\t\t\tvar imageData = image.data;\n\t\t\tvar width = image.width;\n\t\t\tvar height = image.height;\n\n\t\t\tvar quadWidth = width*4;\n\t\t\tvar tripleWidth = width*3;\n\t\t\t\n\t\t\tvar x, y = 0;\n\t\t\tvar r, g, b;\n\t\t\tvar start,p, col,row,pos;\n\t\t\twhile(y < height){\n\t\t\t\tx = 0;\n\t\t\t\twhile(x < quadWidth){\n\t\t\t\tstart = quadWidth * y + x;\n\t\t\t\tp = start;\n\t\t\t\tcol = -1;\n\t\t\t\trow = 0;\n\t\t\t\t\n\t\t\t\tfor(pos=0; pos < 64; pos++){\n\t\t\t\t\trow = pos >> 3;// /8\n\t\t\t\t\tcol = ( pos & 7 ) * 4; // %8\n\t\t\t\t\tp = start + ( row * quadWidth ) + col;\t\t\n\t\t\t\t\t\n\t\t\t\t\tif(y+row >= height){ // padding bottom\n\t\t\t\t\t\tp-= (quadWidth*(y+1+row-height));\n\t\t\t\t\t}\n\n\t\t\t\t\tif(x+col >= quadWidth){ // padding right\t\n\t\t\t\t\t\tp-= ((x+col) - quadWidth +4)\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tr = imageData[ p++ ];\n\t\t\t\t\tg = imageData[ p++ ];\n\t\t\t\t\tb = imageData[ p++ ];\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t/* // calculate YUV values dynamically\n\t\t\t\t\tYDU[pos]=((( 0.29900)*r+( 0.58700)*g+( 0.11400)*b))-128; //-0x80\n\t\t\t\t\tUDU[pos]=(((-0.16874)*r+(-0.33126)*g+( 0.50000)*b));\n\t\t\t\t\tVDU[pos]=((( 0.50000)*r+(-0.41869)*g+(-0.08131)*b));\n\t\t\t\t\t*/\n\t\t\t\t\t\n\t\t\t\t\t// use lookup table (slightly faster)\n\t\t\t\t\tYDU[pos] = ((RGB_YUV_TABLE[r]             + RGB_YUV_TABLE[(g +  256)>>0] + RGB_YUV_TABLE[(b +  512)>>0]) >> 16)-128;\n\t\t\t\t\tUDU[pos] = ((RGB_YUV_TABLE[(r +  768)>>0] + RGB_YUV_TABLE[(g + 1024)>>0] + RGB_YUV_TABLE[(b + 1280)>>0]) >> 16)-128;\n\t\t\t\t\tVDU[pos] = ((RGB_YUV_TABLE[(r + 1280)>>0] + RGB_YUV_TABLE[(g + 1536)>>0] + RGB_YUV_TABLE[(b + 1792)>>0]) >> 16)-128;\n\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tDCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);\n\t\t\t\tDCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);\n\t\t\t\tDCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);\n\t\t\t\tx+=32;\n\t\t\t\t}\n\t\t\t\ty+=8;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t////////////////////////////////////////////////////////////////\n\t\n\t\t\t// Do the bit alignment of the EOI marker\n\t\t\tif ( bytepos >= 0 ) {\n\t\t\t\tvar fillbits = [];\n\t\t\t\tfillbits[1] = bytepos+1;\n\t\t\t\tfillbits[0] = (1<<(bytepos+1))-1;\n\t\t\t\twriteBits(fillbits);\n\t\t\t}\n\t\n\t\t\twriteWord(0xFFD9); //EOI\n\n\t\t\tif (typeof module === 'undefined') return new Uint8Array(byteout);\n      return Buffer.from(byteout);\n\n\t\t\tvar jpegDataUri = 'data:image/jpeg;base64,' + btoa(byteout.join(''));\n\t\t\t\n\t\t\tbyteout = [];\n\t\t\t\n\t\t\t// benchmarking\n\t\t\tvar duration = new Date().getTime() - time_start;\n    \t\t//console.log('Encoding time: '+ duration + 'ms');\n    \t\t//\n\t\t\t\n\t\t\treturn jpegDataUri\t\t\t\n\t}\n\t\n\tfunction setQuality(quality){\n\t\tif (quality <= 0) {\n\t\t\tquality = 1;\n\t\t}\n\t\tif (quality > 100) {\n\t\t\tquality = 100;\n\t\t}\n\t\t\n\t\tif(currentQuality == quality) return // don't recalc if unchanged\n\t\t\n\t\tvar sf = 0;\n\t\tif (quality < 50) {\n\t\t\tsf = Math.floor(5000 / quality);\n\t\t} else {\n\t\t\tsf = Math.floor(200 - quality*2);\n\t\t}\n\t\t\n\t\tinitQuantTables(sf);\n\t\tcurrentQuality = quality;\n\t\t//console.log('Quality set to: '+quality +'%');\n\t}\n\t\n\tfunction init(){\n\t\tvar time_start = new Date().getTime();\n\t\tif(!quality) quality = 50;\n\t\t// Create tables\n\t\tinitCharLookupTable()\n\t\tinitHuffmanTbl();\n\t\tinitCategoryNumber();\n\t\tinitRGBYUVTable();\n\t\t\n\t\tsetQuality(quality);\n\t\tvar duration = new Date().getTime() - time_start;\n    \t//console.log('Initialization '+ duration + 'ms');\n\t}\n\t\n\tinit();\n\t\n};\n\nif (typeof module !== 'undefined') {\n\tmodule.exports = encode;\n} else if (typeof window !== 'undefined') {\n\twindow['jpeg-js'] = window['jpeg-js'] || {};\n\twindow['jpeg-js'].encode = encode;\n}\n\nfunction encode(imgData, qu) {\n  if (typeof qu === 'undefined') qu = 50;\n  var encoder = new JPEGEncoder(qu);\n\tvar data = encoder.encode(imgData, qu);\n  return {\n    data: data,\n    width: imgData.width,\n    height: imgData.height,\n  };\n}\n\n// helper function to get the imageData of an existing image on the current page.\nfunction getImageDataFromImage(idOrElement){\n\tvar theImg = (typeof(idOrElement)=='string')? document.getElementById(idOrElement):idOrElement;\n\tvar cvs = document.createElement('canvas');\n\tcvs.width = theImg.width;\n\tcvs.height = theImg.height;\n\tvar ctx = cvs.getContext(\"2d\");\n\tctx.drawImage(theImg,0,0);\n\t\n\treturn (ctx.getImageData(0, 0, cvs.width, cvs.height));\n}\n","/* -*- tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\n/*\n   Copyright 2011 notmasteryet\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\n// - The JPEG specification can be found in the ITU CCITT Recommendation T.81\n//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)\n// - The JFIF specification can be found in the JPEG File Interchange Format\n//   (www.w3.org/Graphics/JPEG/jfif3.pdf)\n// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters\n//   in PostScript Level 2, Technical Note #5116\n//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)\n\nvar JpegImage = (function jpegImage() {\n  \"use strict\";\n  var dctZigZag = new Int32Array([\n     0,\n     1,  8,\n    16,  9,  2,\n     3, 10, 17, 24,\n    32, 25, 18, 11, 4,\n     5, 12, 19, 26, 33, 40,\n    48, 41, 34, 27, 20, 13,  6,\n     7, 14, 21, 28, 35, 42, 49, 56,\n    57, 50, 43, 36, 29, 22, 15,\n    23, 30, 37, 44, 51, 58,\n    59, 52, 45, 38, 31,\n    39, 46, 53, 60,\n    61, 54, 47,\n    55, 62,\n    63\n  ]);\n\n  var dctCos1  =  4017   // cos(pi/16)\n  var dctSin1  =   799   // sin(pi/16)\n  var dctCos3  =  3406   // cos(3*pi/16)\n  var dctSin3  =  2276   // sin(3*pi/16)\n  var dctCos6  =  1567   // cos(6*pi/16)\n  var dctSin6  =  3784   // sin(6*pi/16)\n  var dctSqrt2 =  5793   // sqrt(2)\n  var dctSqrt1d2 = 2896  // sqrt(2) / 2\n\n  function constructor() {\n  }\n\n  function buildHuffmanTable(codeLengths, values) {\n    var k = 0, code = [], i, j, length = 16;\n    while (length > 0 && !codeLengths[length - 1])\n      length--;\n    code.push({children: [], index: 0});\n    var p = code[0], q;\n    for (i = 0; i < length; i++) {\n      for (j = 0; j < codeLengths[i]; j++) {\n        p = code.pop();\n        p.children[p.index] = values[k];\n        while (p.index > 0) {\n          if (code.length === 0)\n            throw new Error('Could not recreate Huffman Table');\n          p = code.pop();\n        }\n        p.index++;\n        code.push(p);\n        while (code.length <= i) {\n          code.push(q = {children: [], index: 0});\n          p.children[p.index] = q.children;\n          p = q;\n        }\n        k++;\n      }\n      if (i + 1 < length) {\n        // p here points to last code\n        code.push(q = {children: [], index: 0});\n        p.children[p.index] = q.children;\n        p = q;\n      }\n    }\n    return code[0].children;\n  }\n\n  function decodeScan(data, offset,\n                      frame, components, resetInterval,\n                      spectralStart, spectralEnd,\n                      successivePrev, successive, opts) {\n    var precision = frame.precision;\n    var samplesPerLine = frame.samplesPerLine;\n    var scanLines = frame.scanLines;\n    var mcusPerLine = frame.mcusPerLine;\n    var progressive = frame.progressive;\n    var maxH = frame.maxH, maxV = frame.maxV;\n\n    var startOffset = offset, bitsData = 0, bitsCount = 0;\n    function readBit() {\n      if (bitsCount > 0) {\n        bitsCount--;\n        return (bitsData >> bitsCount) & 1;\n      }\n      bitsData = data[offset++];\n      if (bitsData == 0xFF) {\n        var nextByte = data[offset++];\n        if (nextByte) {\n          throw new Error(\"unexpected marker: \" + ((bitsData << 8) | nextByte).toString(16));\n        }\n        // unstuff 0\n      }\n      bitsCount = 7;\n      return bitsData >>> 7;\n    }\n    function decodeHuffman(tree) {\n      var node = tree, bit;\n      while ((bit = readBit()) !== null) {\n        node = node[bit];\n        if (typeof node === 'number')\n          return node;\n        if (typeof node !== 'object')\n          throw new Error(\"invalid huffman sequence\");\n      }\n      return null;\n    }\n    function receive(length) {\n      var n = 0;\n      while (length > 0) {\n        var bit = readBit();\n        if (bit === null) return;\n        n = (n << 1) | bit;\n        length--;\n      }\n      return n;\n    }\n    function receiveAndExtend(length) {\n      var n = receive(length);\n      if (n >= 1 << (length - 1))\n        return n;\n      return n + (-1 << length) + 1;\n    }\n    function decodeBaseline(component, zz) {\n      var t = decodeHuffman(component.huffmanTableDC);\n      var diff = t === 0 ? 0 : receiveAndExtend(t);\n      zz[0]= (component.pred += diff);\n      var k = 1;\n      while (k < 64) {\n        var rs = decodeHuffman(component.huffmanTableAC);\n        var s = rs & 15, r = rs >> 4;\n        if (s === 0) {\n          if (r < 15)\n            break;\n          k += 16;\n          continue;\n        }\n        k += r;\n        var z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s);\n        k++;\n      }\n    }\n    function decodeDCFirst(component, zz) {\n      var t = decodeHuffman(component.huffmanTableDC);\n      var diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);\n      zz[0] = (component.pred += diff);\n    }\n    function decodeDCSuccessive(component, zz) {\n      zz[0] |= readBit() << successive;\n    }\n    var eobrun = 0;\n    function decodeACFirst(component, zz) {\n      if (eobrun > 0) {\n        eobrun--;\n        return;\n      }\n      var k = spectralStart, e = spectralEnd;\n      while (k <= e) {\n        var rs = decodeHuffman(component.huffmanTableAC);\n        var s = rs & 15, r = rs >> 4;\n        if (s === 0) {\n          if (r < 15) {\n            eobrun = receive(r) + (1 << r) - 1;\n            break;\n          }\n          k += 16;\n          continue;\n        }\n        k += r;\n        var z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s) * (1 << successive);\n        k++;\n      }\n    }\n    var successiveACState = 0, successiveACNextValue;\n    function decodeACSuccessive(component, zz) {\n      var k = spectralStart, e = spectralEnd, r = 0;\n      while (k <= e) {\n        var z = dctZigZag[k];\n        var direction = zz[z] < 0 ? -1 : 1;\n        switch (successiveACState) {\n        case 0: // initial state\n          var rs = decodeHuffman(component.huffmanTableAC);\n          var s = rs & 15, r = rs >> 4;\n          if (s === 0) {\n            if (r < 15) {\n              eobrun = receive(r) + (1 << r);\n              successiveACState = 4;\n            } else {\n              r = 16;\n              successiveACState = 1;\n            }\n          } else {\n            if (s !== 1)\n              throw new Error(\"invalid ACn encoding\");\n            successiveACNextValue = receiveAndExtend(s);\n            successiveACState = r ? 2 : 3;\n          }\n          continue;\n        case 1: // skipping r zero items\n        case 2:\n          if (zz[z])\n            zz[z] += (readBit() << successive) * direction;\n          else {\n            r--;\n            if (r === 0)\n              successiveACState = successiveACState == 2 ? 3 : 0;\n          }\n          break;\n        case 3: // set value for a zero item\n          if (zz[z])\n            zz[z] += (readBit() << successive) * direction;\n          else {\n            zz[z] = successiveACNextValue << successive;\n            successiveACState = 0;\n          }\n          break;\n        case 4: // eob\n          if (zz[z])\n            zz[z] += (readBit() << successive) * direction;\n          break;\n        }\n        k++;\n      }\n      if (successiveACState === 4) {\n        eobrun--;\n        if (eobrun === 0)\n          successiveACState = 0;\n      }\n    }\n    function decodeMcu(component, decode, mcu, row, col) {\n      var mcuRow = (mcu / mcusPerLine) | 0;\n      var mcuCol = mcu % mcusPerLine;\n      var blockRow = mcuRow * component.v + row;\n      var blockCol = mcuCol * component.h + col;\n      // If the block is missing and we're in tolerant mode, just skip it.\n      if (component.blocks[blockRow] === undefined && opts.tolerantDecoding)\n        return;\n      decode(component, component.blocks[blockRow][blockCol]);\n    }\n    function decodeBlock(component, decode, mcu) {\n      var blockRow = (mcu / component.blocksPerLine) | 0;\n      var blockCol = mcu % component.blocksPerLine;\n      // If the block is missing and we're in tolerant mode, just skip it.\n      if (component.blocks[blockRow] === undefined && opts.tolerantDecoding)\n        return;\n      decode(component, component.blocks[blockRow][blockCol]);\n    }\n\n    var componentsLength = components.length;\n    var component, i, j, k, n;\n    var decodeFn;\n    if (progressive) {\n      if (spectralStart === 0)\n        decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;\n      else\n        decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;\n    } else {\n      decodeFn = decodeBaseline;\n    }\n\n    var mcu = 0, marker;\n    var mcuExpected;\n    if (componentsLength == 1) {\n      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;\n    } else {\n      mcuExpected = mcusPerLine * frame.mcusPerColumn;\n    }\n    if (!resetInterval) resetInterval = mcuExpected;\n\n    var h, v;\n    while (mcu < mcuExpected) {\n      // reset interval stuff\n      for (i = 0; i < componentsLength; i++)\n        components[i].pred = 0;\n      eobrun = 0;\n\n      if (componentsLength == 1) {\n        component = components[0];\n        for (n = 0; n < resetInterval; n++) {\n          decodeBlock(component, decodeFn, mcu);\n          mcu++;\n        }\n      } else {\n        for (n = 0; n < resetInterval; n++) {\n          for (i = 0; i < componentsLength; i++) {\n            component = components[i];\n            h = component.h;\n            v = component.v;\n            for (j = 0; j < v; j++) {\n              for (k = 0; k < h; k++) {\n                decodeMcu(component, decodeFn, mcu, j, k);\n              }\n            }\n          }\n          mcu++;\n\n          // If we've reached our expected MCU's, stop decoding\n          if (mcu === mcuExpected) break;\n        }\n      }\n\n      if (mcu === mcuExpected) {\n        // Skip trailing bytes at the end of the scan - until we reach the next marker\n        do {\n          if (data[offset] === 0xFF) {\n            if (data[offset + 1] !== 0x00) {\n              break;\n            }\n          }\n          offset += 1;\n        } while (offset < data.length - 2);\n      }\n\n      // find marker\n      bitsCount = 0;\n      marker = (data[offset] << 8) | data[offset + 1];\n      if (marker < 0xFF00) {\n        throw new Error(\"marker was not found\");\n      }\n\n      if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx\n        offset += 2;\n      }\n      else\n        break;\n    }\n\n    return offset - startOffset;\n  }\n\n  function buildComponentData(frame, component) {\n    var lines = [];\n    var blocksPerLine = component.blocksPerLine;\n    var blocksPerColumn = component.blocksPerColumn;\n    var samplesPerLine = blocksPerLine << 3;\n    // Only 1 used per invocation of this function and garbage collected after invocation, so no need to account for its memory footprint.\n    var R = new Int32Array(64), r = new Uint8Array(64);\n\n    // A port of poppler's IDCT method which in turn is taken from:\n    //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,\n    //   \"Practical Fast 1-D DCT Algorithms with 11 Multiplications\",\n    //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,\n    //   988-991.\n    function quantizeAndInverse(zz, dataOut, dataIn) {\n      var qt = component.quantizationTable;\n      var v0, v1, v2, v3, v4, v5, v6, v7, t;\n      var p = dataIn;\n      var i;\n\n      // dequant\n      for (i = 0; i < 64; i++)\n        p[i] = zz[i] * qt[i];\n\n      // inverse DCT on rows\n      for (i = 0; i < 8; ++i) {\n        var row = 8 * i;\n\n        // check for all-zero AC coefficients\n        if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 &&\n            p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 &&\n            p[7 + row] == 0) {\n          t = (dctSqrt2 * p[0 + row] + 512) >> 10;\n          p[0 + row] = t;\n          p[1 + row] = t;\n          p[2 + row] = t;\n          p[3 + row] = t;\n          p[4 + row] = t;\n          p[5 + row] = t;\n          p[6 + row] = t;\n          p[7 + row] = t;\n          continue;\n        }\n\n        // stage 4\n        v0 = (dctSqrt2 * p[0 + row] + 128) >> 8;\n        v1 = (dctSqrt2 * p[4 + row] + 128) >> 8;\n        v2 = p[2 + row];\n        v3 = p[6 + row];\n        v4 = (dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128) >> 8;\n        v7 = (dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128) >> 8;\n        v5 = p[3 + row] << 4;\n        v6 = p[5 + row] << 4;\n\n        // stage 3\n        t = (v0 - v1+ 1) >> 1;\n        v0 = (v0 + v1 + 1) >> 1;\n        v1 = t;\n        t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;\n        v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;\n        v3 = t;\n        t = (v4 - v6 + 1) >> 1;\n        v4 = (v4 + v6 + 1) >> 1;\n        v6 = t;\n        t = (v7 + v5 + 1) >> 1;\n        v5 = (v7 - v5 + 1) >> 1;\n        v7 = t;\n\n        // stage 2\n        t = (v0 - v3 + 1) >> 1;\n        v0 = (v0 + v3 + 1) >> 1;\n        v3 = t;\n        t = (v1 - v2 + 1) >> 1;\n        v1 = (v1 + v2 + 1) >> 1;\n        v2 = t;\n        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;\n        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;\n        v7 = t;\n        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;\n        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;\n        v6 = t;\n\n        // stage 1\n        p[0 + row] = v0 + v7;\n        p[7 + row] = v0 - v7;\n        p[1 + row] = v1 + v6;\n        p[6 + row] = v1 - v6;\n        p[2 + row] = v2 + v5;\n        p[5 + row] = v2 - v5;\n        p[3 + row] = v3 + v4;\n        p[4 + row] = v3 - v4;\n      }\n\n      // inverse DCT on columns\n      for (i = 0; i < 8; ++i) {\n        var col = i;\n\n        // check for all-zero AC coefficients\n        if (p[1*8 + col] == 0 && p[2*8 + col] == 0 && p[3*8 + col] == 0 &&\n            p[4*8 + col] == 0 && p[5*8 + col] == 0 && p[6*8 + col] == 0 &&\n            p[7*8 + col] == 0) {\n          t = (dctSqrt2 * dataIn[i+0] + 8192) >> 14;\n          p[0*8 + col] = t;\n          p[1*8 + col] = t;\n          p[2*8 + col] = t;\n          p[3*8 + col] = t;\n          p[4*8 + col] = t;\n          p[5*8 + col] = t;\n          p[6*8 + col] = t;\n          p[7*8 + col] = t;\n          continue;\n        }\n\n        // stage 4\n        v0 = (dctSqrt2 * p[0*8 + col] + 2048) >> 12;\n        v1 = (dctSqrt2 * p[4*8 + col] + 2048) >> 12;\n        v2 = p[2*8 + col];\n        v3 = p[6*8 + col];\n        v4 = (dctSqrt1d2 * (p[1*8 + col] - p[7*8 + col]) + 2048) >> 12;\n        v7 = (dctSqrt1d2 * (p[1*8 + col] + p[7*8 + col]) + 2048) >> 12;\n        v5 = p[3*8 + col];\n        v6 = p[5*8 + col];\n\n        // stage 3\n        t = (v0 - v1 + 1) >> 1;\n        v0 = (v0 + v1 + 1) >> 1;\n        v1 = t;\n        t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;\n        v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;\n        v3 = t;\n        t = (v4 - v6 + 1) >> 1;\n        v4 = (v4 + v6 + 1) >> 1;\n        v6 = t;\n        t = (v7 + v5 + 1) >> 1;\n        v5 = (v7 - v5 + 1) >> 1;\n        v7 = t;\n\n        // stage 2\n        t = (v0 - v3 + 1) >> 1;\n        v0 = (v0 + v3 + 1) >> 1;\n        v3 = t;\n        t = (v1 - v2 + 1) >> 1;\n        v1 = (v1 + v2 + 1) >> 1;\n        v2 = t;\n        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;\n        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;\n        v7 = t;\n        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;\n        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;\n        v6 = t;\n\n        // stage 1\n        p[0*8 + col] = v0 + v7;\n        p[7*8 + col] = v0 - v7;\n        p[1*8 + col] = v1 + v6;\n        p[6*8 + col] = v1 - v6;\n        p[2*8 + col] = v2 + v5;\n        p[5*8 + col] = v2 - v5;\n        p[3*8 + col] = v3 + v4;\n        p[4*8 + col] = v3 - v4;\n      }\n\n      // convert to 8-bit integers\n      for (i = 0; i < 64; ++i) {\n        var sample = 128 + ((p[i] + 8) >> 4);\n        dataOut[i] = sample < 0 ? 0 : sample > 0xFF ? 0xFF : sample;\n      }\n    }\n\n    requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);\n\n    var i, j;\n    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n      var scanLine = blockRow << 3;\n      for (i = 0; i < 8; i++)\n        lines.push(new Uint8Array(samplesPerLine));\n      for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n        quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);\n\n        var offset = 0, sample = blockCol << 3;\n        for (j = 0; j < 8; j++) {\n          var line = lines[scanLine + j];\n          for (i = 0; i < 8; i++)\n            line[sample + i] = r[offset++];\n        }\n      }\n    }\n    return lines;\n  }\n\n  function clampTo8bit(a) {\n    return a < 0 ? 0 : a > 255 ? 255 : a;\n  }\n\n  constructor.prototype = {\n    load: function load(path) {\n      var xhr = new XMLHttpRequest();\n      xhr.open(\"GET\", path, true);\n      xhr.responseType = \"arraybuffer\";\n      xhr.onload = (function() {\n        // TODO catch parse error\n        var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);\n        this.parse(data);\n        if (this.onload)\n          this.onload();\n      }).bind(this);\n      xhr.send(null);\n    },\n    parse: function parse(data) {\n      var maxResolutionInPixels = this.opts.maxResolutionInMP * 1000 * 1000;\n      var offset = 0, length = data.length;\n      function readUint16() {\n        var value = (data[offset] << 8) | data[offset + 1];\n        offset += 2;\n        return value;\n      }\n      function readDataBlock() {\n        var length = readUint16();\n        var array = data.subarray(offset, offset + length - 2);\n        offset += array.length;\n        return array;\n      }\n      function prepareComponents(frame) {\n        // According to the JPEG standard, the sampling factor must be between 1 and 4\n        // See https://github.com/libjpeg-turbo/libjpeg-turbo/blob/9abeff46d87bd201a952e276f3e4339556a403a3/libjpeg.txt#L1138-L1146\n        var maxH = 1, maxV = 1;\n        var component, componentId;\n        for (componentId in frame.components) {\n          if (frame.components.hasOwnProperty(componentId)) {\n            component = frame.components[componentId];\n            if (maxH < component.h) maxH = component.h;\n            if (maxV < component.v) maxV = component.v;\n          }\n        }\n        var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);\n        var mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);\n        for (componentId in frame.components) {\n          if (frame.components.hasOwnProperty(componentId)) {\n            component = frame.components[componentId];\n            var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);\n            var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines  / 8) * component.v / maxV);\n            var blocksPerLineForMcu = mcusPerLine * component.h;\n            var blocksPerColumnForMcu = mcusPerColumn * component.v;\n            var blocksToAllocate = blocksPerColumnForMcu * blocksPerLineForMcu;\n            var blocks = [];\n\n            // Each block is a Int32Array of length 64 (4 x 64 = 256 bytes)\n            requestMemoryAllocation(blocksToAllocate * 256);\n\n            for (var i = 0; i < blocksPerColumnForMcu; i++) {\n              var row = [];\n              for (var j = 0; j < blocksPerLineForMcu; j++)\n                row.push(new Int32Array(64));\n              blocks.push(row);\n            }\n            component.blocksPerLine = blocksPerLine;\n            component.blocksPerColumn = blocksPerColumn;\n            component.blocks = blocks;\n          }\n        }\n        frame.maxH = maxH;\n        frame.maxV = maxV;\n        frame.mcusPerLine = mcusPerLine;\n        frame.mcusPerColumn = mcusPerColumn;\n      }\n      var jfif = null;\n      var adobe = null;\n      var pixels = null;\n      var frame, resetInterval;\n      var quantizationTables = [], frames = [];\n      var huffmanTablesAC = [], huffmanTablesDC = [];\n      var fileMarker = readUint16();\n      var malformedDataOffset = -1;\n      this.comments = [];\n      if (fileMarker != 0xFFD8) { // SOI (Start of Image)\n        throw new Error(\"SOI not found\");\n      }\n\n      fileMarker = readUint16();\n      while (fileMarker != 0xFFD9) { // EOI (End of image)\n        var i, j, l;\n        switch(fileMarker) {\n          case 0xFF00: break;\n          case 0xFFE0: // APP0 (Application Specific)\n          case 0xFFE1: // APP1\n          case 0xFFE2: // APP2\n          case 0xFFE3: // APP3\n          case 0xFFE4: // APP4\n          case 0xFFE5: // APP5\n          case 0xFFE6: // APP6\n          case 0xFFE7: // APP7\n          case 0xFFE8: // APP8\n          case 0xFFE9: // APP9\n          case 0xFFEA: // APP10\n          case 0xFFEB: // APP11\n          case 0xFFEC: // APP12\n          case 0xFFED: // APP13\n          case 0xFFEE: // APP14\n          case 0xFFEF: // APP15\n          case 0xFFFE: // COM (Comment)\n            var appData = readDataBlock();\n\n            if (fileMarker === 0xFFFE) {\n              var comment = String.fromCharCode.apply(null, appData);\n              this.comments.push(comment);\n            }\n\n            if (fileMarker === 0xFFE0) {\n              if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 &&\n                appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\\x00'\n                jfif = {\n                  version: { major: appData[5], minor: appData[6] },\n                  densityUnits: appData[7],\n                  xDensity: (appData[8] << 8) | appData[9],\n                  yDensity: (appData[10] << 8) | appData[11],\n                  thumbWidth: appData[12],\n                  thumbHeight: appData[13],\n                  thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])\n                };\n              }\n            }\n            // TODO APP1 - Exif\n            if (fileMarker === 0xFFE1) {\n              if (appData[0] === 0x45 &&\n                appData[1] === 0x78 &&\n                appData[2] === 0x69 &&\n                appData[3] === 0x66 &&\n                appData[4] === 0) { // 'EXIF\\x00'\n                this.exifBuffer = appData.subarray(5, appData.length);\n              }\n            }\n\n            if (fileMarker === 0xFFEE) {\n              if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F &&\n                appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\\x00'\n                adobe = {\n                  version: appData[6],\n                  flags0: (appData[7] << 8) | appData[8],\n                  flags1: (appData[9] << 8) | appData[10],\n                  transformCode: appData[11]\n                };\n              }\n            }\n            break;\n\n          case 0xFFDB: // DQT (Define Quantization Tables)\n            var quantizationTablesLength = readUint16();\n            var quantizationTablesEnd = quantizationTablesLength + offset - 2;\n            while (offset < quantizationTablesEnd) {\n              var quantizationTableSpec = data[offset++];\n              requestMemoryAllocation(64 * 4);\n              var tableData = new Int32Array(64);\n              if ((quantizationTableSpec >> 4) === 0) { // 8 bit values\n                for (j = 0; j < 64; j++) {\n                  var z = dctZigZag[j];\n                  tableData[z] = data[offset++];\n                }\n              } else if ((quantizationTableSpec >> 4) === 1) { //16 bit\n                for (j = 0; j < 64; j++) {\n                  var z = dctZigZag[j];\n                  tableData[z] = readUint16();\n                }\n              } else\n                throw new Error(\"DQT: invalid table spec\");\n              quantizationTables[quantizationTableSpec & 15] = tableData;\n            }\n            break;\n\n          case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)\n          case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)\n          case 0xFFC2: // SOF2 (Start of Frame, Progressive DCT)\n            readUint16(); // skip data length\n            frame = {};\n            frame.extended = (fileMarker === 0xFFC1);\n            frame.progressive = (fileMarker === 0xFFC2);\n            frame.precision = data[offset++];\n            frame.scanLines = readUint16();\n            frame.samplesPerLine = readUint16();\n            frame.components = {};\n            frame.componentsOrder = [];\n\n            var pixelsInFrame = frame.scanLines * frame.samplesPerLine;\n            if (pixelsInFrame > maxResolutionInPixels) {\n              var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);\n              throw new Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`);\n            }\n\n            var componentsCount = data[offset++], componentId;\n            var maxH = 0, maxV = 0;\n            for (i = 0; i < componentsCount; i++) {\n              componentId = data[offset];\n              var h = data[offset + 1] >> 4;\n              var v = data[offset + 1] & 15;\n              var qId = data[offset + 2];\n\n              if ( h <= 0 || v <= 0 ) {\n                throw new Error('Invalid sampling factor, expected values above 0');\n              }\n\n              frame.componentsOrder.push(componentId);\n              frame.components[componentId] = {\n                h: h,\n                v: v,\n                quantizationIdx: qId\n              };\n              offset += 3;\n            }\n            prepareComponents(frame);\n            frames.push(frame);\n            break;\n\n          case 0xFFC4: // DHT (Define Huffman Tables)\n            var huffmanLength = readUint16();\n            for (i = 2; i < huffmanLength;) {\n              var huffmanTableSpec = data[offset++];\n              var codeLengths = new Uint8Array(16);\n              var codeLengthSum = 0;\n              for (j = 0; j < 16; j++, offset++) {\n                codeLengthSum += (codeLengths[j] = data[offset]);\n              }\n              requestMemoryAllocation(16 + codeLengthSum);\n              var huffmanValues = new Uint8Array(codeLengthSum);\n              for (j = 0; j < codeLengthSum; j++, offset++)\n                huffmanValues[j] = data[offset];\n              i += 17 + codeLengthSum;\n\n              ((huffmanTableSpec >> 4) === 0 ?\n                huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] =\n                buildHuffmanTable(codeLengths, huffmanValues);\n            }\n            break;\n\n          case 0xFFDD: // DRI (Define Restart Interval)\n            readUint16(); // skip data length\n            resetInterval = readUint16();\n            break;\n\n          case 0xFFDC: // Number of Lines marker\n            readUint16() // skip data length\n            readUint16() // Ignore this data since it represents the image height\n            break;\n            \n          case 0xFFDA: // SOS (Start of Scan)\n            var scanLength = readUint16();\n            var selectorsCount = data[offset++];\n            var components = [], component;\n            for (i = 0; i < selectorsCount; i++) {\n              component = frame.components[data[offset++]];\n              var tableSpec = data[offset++];\n              component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];\n              component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];\n              components.push(component);\n            }\n            var spectralStart = data[offset++];\n            var spectralEnd = data[offset++];\n            var successiveApproximation = data[offset++];\n            var processed = decodeScan(data, offset,\n              frame, components, resetInterval,\n              spectralStart, spectralEnd,\n              successiveApproximation >> 4, successiveApproximation & 15, this.opts);\n            offset += processed;\n            break;\n\n          case 0xFFFF: // Fill bytes\n            if (data[offset] !== 0xFF) { // Avoid skipping a valid marker.\n              offset--;\n            }\n            break;\n          default:\n            if (data[offset - 3] == 0xFF &&\n                data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {\n              // could be incorrect encoding -- last 0xFF byte of the previous\n              // block was eaten by the encoder\n              offset -= 3;\n              break;\n            }\n            else if (fileMarker === 0xE0 || fileMarker == 0xE1) {\n              // Recover from malformed APP1 markers popular in some phone models.\n              // See https://github.com/eugeneware/jpeg-js/issues/82\n              if (malformedDataOffset !== -1) {\n                throw new Error(`first unknown JPEG marker at offset ${malformedDataOffset.toString(16)}, second unknown JPEG marker ${fileMarker.toString(16)} at offset ${(offset - 1).toString(16)}`);\n              }\n              malformedDataOffset = offset - 1;\n              const nextOffset = readUint16();\n              if (data[offset + nextOffset - 2] === 0xFF) {\n                offset += nextOffset - 2;\n                break;\n              }\n            }\n            throw new Error(\"unknown JPEG marker \" + fileMarker.toString(16));\n        }\n        fileMarker = readUint16();\n      }\n      if (frames.length != 1)\n        throw new Error(\"only single frame JPEGs supported\");\n\n      // set each frame's components quantization table\n      for (var i = 0; i < frames.length; i++) {\n        var cp = frames[i].components;\n        for (var j in cp) {\n          cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];\n          delete cp[j].quantizationIdx;\n        }\n      }\n\n      this.width = frame.samplesPerLine;\n      this.height = frame.scanLines;\n      this.jfif = jfif;\n      this.adobe = adobe;\n      this.components = [];\n      for (var i = 0; i < frame.componentsOrder.length; i++) {\n        var component = frame.components[frame.componentsOrder[i]];\n        this.components.push({\n          lines: buildComponentData(frame, component),\n          scaleX: component.h / frame.maxH,\n          scaleY: component.v / frame.maxV\n        });\n      }\n    },\n    getData: function getData(width, height) {\n      var scaleX = this.width / width, scaleY = this.height / height;\n\n      var component1, component2, component3, component4;\n      var component1Line, component2Line, component3Line, component4Line;\n      var x, y;\n      var offset = 0;\n      var Y, Cb, Cr, K, C, M, Ye, R, G, B;\n      var colorTransform;\n      var dataLength = width * height * this.components.length;\n      requestMemoryAllocation(dataLength);\n      var data = new Uint8Array(dataLength);\n      switch (this.components.length) {\n        case 1:\n          component1 = this.components[0];\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];\n            for (x = 0; x < width; x++) {\n              Y = component1Line[0 | (x * component1.scaleX * scaleX)];\n\n              data[offset++] = Y;\n            }\n          }\n          break;\n        case 2:\n          // PDF might compress two component data in custom colorspace\n          component1 = this.components[0];\n          component2 = this.components[1];\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];\n            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];\n            for (x = 0; x < width; x++) {\n              Y = component1Line[0 | (x * component1.scaleX * scaleX)];\n              data[offset++] = Y;\n              Y = component2Line[0 | (x * component2.scaleX * scaleX)];\n              data[offset++] = Y;\n            }\n          }\n          break;\n        case 3:\n          // The default transform for three components is true\n          colorTransform = true;\n          // The adobe transform marker overrides any previous setting\n          if (this.adobe && this.adobe.transformCode)\n            colorTransform = true;\n          else if (typeof this.opts.colorTransform !== 'undefined')\n            colorTransform = !!this.opts.colorTransform;\n\n          component1 = this.components[0];\n          component2 = this.components[1];\n          component3 = this.components[2];\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];\n            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];\n            component3Line = component3.lines[0 | (y * component3.scaleY * scaleY)];\n            for (x = 0; x < width; x++) {\n              if (!colorTransform) {\n                R = component1Line[0 | (x * component1.scaleX * scaleX)];\n                G = component2Line[0 | (x * component2.scaleX * scaleX)];\n                B = component3Line[0 | (x * component3.scaleX * scaleX)];\n              } else {\n                Y = component1Line[0 | (x * component1.scaleX * scaleX)];\n                Cb = component2Line[0 | (x * component2.scaleX * scaleX)];\n                Cr = component3Line[0 | (x * component3.scaleX * scaleX)];\n\n                R = clampTo8bit(Y + 1.402 * (Cr - 128));\n                G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));\n                B = clampTo8bit(Y + 1.772 * (Cb - 128));\n              }\n\n              data[offset++] = R;\n              data[offset++] = G;\n              data[offset++] = B;\n            }\n          }\n          break;\n        case 4:\n          if (!this.adobe)\n            throw new Error('Unsupported color mode (4 components)');\n          // The default transform for four components is false\n          colorTransform = false;\n          // The adobe transform marker overrides any previous setting\n          if (this.adobe && this.adobe.transformCode)\n            colorTransform = true;\n          else if (typeof this.opts.colorTransform !== 'undefined')\n            colorTransform = !!this.opts.colorTransform;\n\n          component1 = this.components[0];\n          component2 = this.components[1];\n          component3 = this.components[2];\n          component4 = this.components[3];\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];\n            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];\n            component3Line = component3.lines[0 | (y * component3.scaleY * scaleY)];\n            component4Line = component4.lines[0 | (y * component4.scaleY * scaleY)];\n            for (x = 0; x < width; x++) {\n              if (!colorTransform) {\n                C = component1Line[0 | (x * component1.scaleX * scaleX)];\n                M = component2Line[0 | (x * component2.scaleX * scaleX)];\n                Ye = component3Line[0 | (x * component3.scaleX * scaleX)];\n                K = component4Line[0 | (x * component4.scaleX * scaleX)];\n              } else {\n                Y = component1Line[0 | (x * component1.scaleX * scaleX)];\n                Cb = component2Line[0 | (x * component2.scaleX * scaleX)];\n                Cr = component3Line[0 | (x * component3.scaleX * scaleX)];\n                K = component4Line[0 | (x * component4.scaleX * scaleX)];\n\n                C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));\n                M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));\n                Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));\n              }\n              data[offset++] = 255-C;\n              data[offset++] = 255-M;\n              data[offset++] = 255-Ye;\n              data[offset++] = 255-K;\n            }\n          }\n          break;\n        default:\n          throw new Error('Unsupported color mode');\n      }\n      return data;\n    },\n    copyToImageData: function copyToImageData(imageData, formatAsRGBA) {\n      var width = imageData.width, height = imageData.height;\n      var imageDataArray = imageData.data;\n      var data = this.getData(width, height);\n      var i = 0, j = 0, x, y;\n      var Y, K, C, M, R, G, B;\n      switch (this.components.length) {\n        case 1:\n          for (y = 0; y < height; y++) {\n            for (x = 0; x < width; x++) {\n              Y = data[i++];\n\n              imageDataArray[j++] = Y;\n              imageDataArray[j++] = Y;\n              imageDataArray[j++] = Y;\n              if (formatAsRGBA) {\n                imageDataArray[j++] = 255;\n              }\n            }\n          }\n          break;\n        case 3:\n          for (y = 0; y < height; y++) {\n            for (x = 0; x < width; x++) {\n              R = data[i++];\n              G = data[i++];\n              B = data[i++];\n\n              imageDataArray[j++] = R;\n              imageDataArray[j++] = G;\n              imageDataArray[j++] = B;\n              if (formatAsRGBA) {\n                imageDataArray[j++] = 255;\n              }\n            }\n          }\n          break;\n        case 4:\n          for (y = 0; y < height; y++) {\n            for (x = 0; x < width; x++) {\n              C = data[i++];\n              M = data[i++];\n              Y = data[i++];\n              K = data[i++];\n\n              R = 255 - clampTo8bit(C * (1 - K / 255) + K);\n              G = 255 - clampTo8bit(M * (1 - K / 255) + K);\n              B = 255 - clampTo8bit(Y * (1 - K / 255) + K);\n\n              imageDataArray[j++] = R;\n              imageDataArray[j++] = G;\n              imageDataArray[j++] = B;\n              if (formatAsRGBA) {\n                imageDataArray[j++] = 255;\n              }\n            }\n          }\n          break;\n        default:\n          throw new Error('Unsupported color mode');\n      }\n    }\n  };\n\n\n  // We cap the amount of memory used by jpeg-js to avoid unexpected OOMs from untrusted content.\n  var totalBytesAllocated = 0;\n  var maxMemoryUsageBytes = 0;\n  function requestMemoryAllocation(increaseAmount = 0) {\n    var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;\n    if (totalMemoryImpactBytes > maxMemoryUsageBytes) {\n      var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);\n      throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`);\n    }\n\n    totalBytesAllocated = totalMemoryImpactBytes;\n  }\n\n  constructor.resetMaxMemoryUsage = function (maxMemoryUsageBytes_) {\n    totalBytesAllocated = 0;\n    maxMemoryUsageBytes = maxMemoryUsageBytes_;\n  };\n\n  constructor.getBytesAllocated = function () {\n    return totalBytesAllocated;\n  };\n\n  constructor.requestMemoryAllocation = requestMemoryAllocation;\n\n  return constructor;\n})();\n\nif (typeof module !== 'undefined') {\n\tmodule.exports = decode;\n} else if (typeof window !== 'undefined') {\n\twindow['jpeg-js'] = window['jpeg-js'] || {};\n\twindow['jpeg-js'].decode = decode;\n}\n\nfunction decode(jpegData, userOpts = {}) {\n  var defaultOpts = {\n    // \"undefined\" means \"Choose whether to transform colors based on the images color model.\"\n    colorTransform: undefined,\n    useTArray: false,\n    formatAsRGBA: true,\n    tolerantDecoding: true,\n    maxResolutionInMP: 100, // Don't decode more than 100 megapixels\n    maxMemoryUsageInMB: 512, // Don't decode if memory footprint is more than 512MB\n  };\n\n  var opts = {...defaultOpts, ...userOpts};\n  var arr = new Uint8Array(jpegData);\n  var decoder = new JpegImage();\n  decoder.opts = opts;\n  // If this constructor ever supports async decoding this will need to be done differently.\n  // Until then, treating as singleton limit is fine.\n  JpegImage.resetMaxMemoryUsage(opts.maxMemoryUsageInMB * 1024 * 1024);\n  decoder.parse(arr);\n\n  var channels = (opts.formatAsRGBA) ? 4 : 3;\n  var bytesNeeded = decoder.width * decoder.height * channels;\n  try {\n    JpegImage.requestMemoryAllocation(bytesNeeded);\n    var image = {\n      width: decoder.width,\n      height: decoder.height,\n      exifBuffer: decoder.exifBuffer,\n      data: opts.useTArray ?\n        new Uint8Array(bytesNeeded) :\n        Buffer.alloc(bytesNeeded)\n    };\n    if(decoder.comments.length > 0) {\n      image[\"comments\"] = decoder.comments;\n    }\n  } catch (err) {\n    if (err instanceof RangeError) {\n      throw new Error(\"Could not allocate enough memory for the image. \" +\n                      \"Required: \" + bytesNeeded);\n    } \n    \n    if (err instanceof ReferenceError) {\n      if (err.message === \"Buffer is not defined\") {\n        throw new Error(\"Buffer is not globally defined in this environment. \" +\n                        \"Consider setting useTArray to true\");\n      }\n    }\n    throw err;\n  }\n\n  decoder.copyToImageData(image, opts.formatAsRGBA);\n\n  return image;\n}\n","var encode = require('./lib/encoder'),\n    decode = require('./lib/decoder');\n\nmodule.exports = {\n  encode: encode,\n  decode: decode\n};\n","import { encode } from 'jpeg-js';\nimport { Mask } from '../Mask.js';\n/**\n * Creates a JPEG buffer from an image.\n * @param image - The image instance.\n * @param options - JPEG encoding options.\n * @returns The buffer.\n */\nexport function encodeJpeg(image, options = {}) {\n    const { quality = 50 } = options;\n    if (image.colorModel !== 'RGBA' || image instanceof Mask) {\n        image = image.convertColor('RGBA');\n    }\n    if (image.bitDepth !== 8) {\n        image = image.convertBitDepth(8);\n    }\n    // Image data after bit depth conversion will always be UInt8Array.\n    const buffer = encode(image.getRawImage(), quality).data;\n    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n}\n//# sourceMappingURL=encodeJpeg.js.map","\n/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n/* eslint-disable space-unary-ops */\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//const Z_FILTERED          = 1;\n//const Z_HUFFMAN_ONLY      = 2;\n//const Z_RLE               = 3;\nconst Z_FIXED$1               = 4;\n//const Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nconst Z_BINARY              = 0;\nconst Z_TEXT                = 1;\n//const Z_ASCII             = 1; // = Z_TEXT\nconst Z_UNKNOWN$1             = 2;\n\n/*============================================================================*/\n\n\nfunction zero$1(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nconst STORED_BLOCK = 0;\nconst STATIC_TREES = 1;\nconst DYN_TREES    = 2;\n/* The three kinds of block type */\n\nconst MIN_MATCH$1    = 3;\nconst MAX_MATCH$1    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nconst LENGTH_CODES$1  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nconst LITERALS$1      = 256;\n/* number of literal bytes 0..255 */\n\nconst L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nconst D_CODES$1       = 30;\n/* number of distance codes */\n\nconst BL_CODES$1      = 19;\n/* number of codes used to transfer the bit lengths */\n\nconst HEAP_SIZE$1     = 2 * L_CODES$1 + 1;\n/* maximum heap size */\n\nconst MAX_BITS$1      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nconst Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nconst MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nconst END_BLOCK   = 256;\n/* end of block literal code */\n\nconst REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nconst REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nconst REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nconst extra_lbits =   /* extra bits for each length code */\n  new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);\n\nconst extra_dbits =   /* extra bits for each distance code */\n  new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);\n\nconst extra_blbits =  /* extra bits for each bit length code */\n  new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);\n\nconst bl_order =\n  new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nconst DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nconst static_ltree  = new Array((L_CODES$1 + 2) * 2);\nzero$1(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nconst static_dtree  = new Array(D_CODES$1 * 2);\nzero$1(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nconst _dist_code    = new Array(DIST_CODE_LEN);\nzero$1(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nconst _length_code  = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);\nzero$1(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nconst base_length   = new Array(LENGTH_CODES$1);\nzero$1(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nconst base_dist     = new Array(D_CODES$1);\nzero$1(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nlet static_l_desc;\nlet static_d_desc;\nlet static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nconst d_code = (dist) => {\n\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n};\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nconst put_short = (s, w) => {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n};\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nconst send_bits = (s, value, length) => {\n\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n};\n\n\nconst send_code = (s, c, tree) => {\n\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n};\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nconst bi_reverse = (code, len) => {\n\n  let res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n};\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nconst bi_flush = (s) => {\n\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n};\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nconst gen_bitlen = (s, desc) => {\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n\n  const tree            = desc.dyn_tree;\n  const max_code        = desc.max_code;\n  const stree           = desc.stat_desc.static_tree;\n  const has_stree       = desc.stat_desc.has_stree;\n  const extra           = desc.stat_desc.extra_bits;\n  const base            = desc.stat_desc.extra_base;\n  const max_length      = desc.stat_desc.max_length;\n  let h;              /* heap index */\n  let n, m;           /* iterate over the tree elements */\n  let bits;           /* bit length */\n  let xbits;          /* extra bits */\n  let f;              /* frequency */\n  let overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS$1; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Tracev((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Tracev((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n};\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nconst gen_codes = (tree, max_code, bl_count) => {\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n\n  const next_code = new Array(MAX_BITS$1 + 1); /* next code value for each bit length */\n  let code = 0;              /* running code value */\n  let bits;                  /* bit index */\n  let n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS$1; bits++) {\n    code = (code + bl_count[bits - 1]) << 1;\n    next_code[bits] = code;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    let len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n};\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nconst tr_static_init = () => {\n\n  let n;        /* iterates over tree elements */\n  let bits;     /* bit counter */\n  let length;   /* length value */\n  let code;     /* code value */\n  let dist;     /* distance index */\n  const bl_count = new Array(MAX_BITS$1 + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES$1; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS$1; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES$1; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES$1, MAX_BITS$1);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES$1, MAX_BL_BITS);\n\n  //static_init_done = true;\n};\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nconst init_block = (s) => {\n\n  let n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES$1;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES$1;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES$1; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.sym_next = s.matches = 0;\n};\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nconst bi_windup = (s) =>\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n};\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nconst smaller = (tree, n, m, depth) => {\n\n  const _n2 = n * 2;\n  const _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n};\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nconst pqdownheap = (s, tree, k) => {\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n\n  const v = s.heap[k];\n  let j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n};\n\n\n// inlined manually\n// const SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nconst compress_block = (s, ltree, dtree) => {\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n\n  let dist;           /* distance of matched string */\n  let lc;             /* match length or unmatched char (if dist == 0) */\n  let sx = 0;         /* running index in sym_buf */\n  let code;           /* the code to send */\n  let extra;          /* number of extra bits to send */\n\n  if (s.sym_next !== 0) {\n    do {\n      dist = s.pending_buf[s.sym_buf + sx++] & 0xff;\n      dist += (s.pending_buf[s.sym_buf + sx++] & 0xff) << 8;\n      lc = s.pending_buf[s.sym_buf + sx++];\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS$1 + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and sym_buf is ok: */\n      //Assert(s->pending < s->lit_bufsize + sx, \"pendingBuf overflow\");\n\n    } while (sx < s.sym_next);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n};\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nconst build_tree = (s, desc) => {\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n\n  const tree     = desc.dyn_tree;\n  const stree    = desc.stat_desc.static_tree;\n  const has_stree = desc.stat_desc.has_stree;\n  const elems    = desc.stat_desc.elems;\n  let n, m;          /* iterate over heap elements */\n  let max_code = -1; /* largest code with non zero frequency */\n  let node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE$1;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n};\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nconst scan_tree = (s, tree, max_code) => {\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n\n  let n;                     /* iterates over all tree elements */\n  let prevlen = -1;          /* last emitted length */\n  let curlen;                /* length of current code */\n\n  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  let count = 0;             /* repeat count of the current code */\n  let max_count = 7;         /* max repeat count */\n  let min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n};\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nconst send_tree = (s, tree, max_code) => {\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n\n  let n;                     /* iterates over all tree elements */\n  let prevlen = -1;          /* last emitted length */\n  let curlen;                /* length of current code */\n\n  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  let count = 0;             /* repeat count of the current code */\n  let max_count = 7;         /* max repeat count */\n  let min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n};\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nconst build_bl_tree = (s) => {\n\n  let max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n};\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nconst send_all_trees = (s, lcodes, dcodes, blcodes) => {\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n\n  let rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n};\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"block list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"allow list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nconst detect_data_type = (s) => {\n  /* block_mask is the bit mask of block-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  let block_mask = 0xf3ffc07f;\n  let n;\n\n  /* Check for non-textual (\"block-listed\") bytes. */\n  for (n = 0; n <= 31; n++, block_mask >>>= 1) {\n    if ((block_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"allow-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS$1; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"block-listed\" or \"allow-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n};\n\n\nlet static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nconst _tr_init$1 = (s) =>\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n};\n\n\n/* ===========================================================================\n * Send a stored block\n */\nconst _tr_stored_block$1 = (s, buf, stored_len, last) => {\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  bi_windup(s);        /* align on byte boundary */\n  put_short(s, stored_len);\n  put_short(s, ~stored_len);\n  if (stored_len) {\n    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);\n  }\n  s.pending += stored_len;\n};\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nconst _tr_align$1 = (s) => {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n};\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and write out the encoded block.\n */\nconst _tr_flush_block$1 = (s, buf, stored_len, last) => {\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n\n  let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  let max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN$1) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->sym_next / 3));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block$1(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n};\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nconst _tr_tally$1 = (s, dist, lc) => {\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n\n  s.pending_buf[s.sym_buf + s.sym_next++] = dist;\n  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;\n  s.pending_buf[s.sym_buf + s.sym_next++] = lc;\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n  return (s.sym_next === s.sym_end);\n};\n\nvar _tr_init_1  = _tr_init$1;\nvar _tr_stored_block_1 = _tr_stored_block$1;\nvar _tr_flush_block_1  = _tr_flush_block$1;\nvar _tr_tally_1 = _tr_tally$1;\nvar _tr_align_1 = _tr_align$1;\n\nvar trees = {\n\t_tr_init: _tr_init_1,\n\t_tr_stored_block: _tr_stored_block_1,\n\t_tr_flush_block: _tr_flush_block_1,\n\t_tr_tally: _tr_tally_1,\n\t_tr_align: _tr_align_1\n};\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nconst adler32 = (adler, buf, len, pos) => {\n  let s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n};\n\n\nvar adler32_1 = adler32;\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// Use ordinary array, since untyped makes no boost here\nconst makeTable = () => {\n  let c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n};\n\n// Create table on load. Just 255 signed longs. Not a problem.\nconst crcTable = new Uint32Array(makeTable());\n\n\nconst crc32 = (crc, buf, len, pos) => {\n  const t = crcTable;\n  const end = pos + len;\n\n  crc ^= -1;\n\n  for (let i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n};\n\n\nvar crc32_1 = crc32;\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar messages = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar constants$2 = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  Z_MEM_ERROR:       -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nconst { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;\n\n\n\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1,\n  Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1,\n  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,\n  Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,\n  Z_UNKNOWN,\n  Z_DEFLATED: Z_DEFLATED$2\n} = constants$2;\n\n/*============================================================================*/\n\n\nconst MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nconst MAX_WBITS$1 = 15;\n/* 32K LZ77 window */\nconst DEF_MEM_LEVEL = 8;\n\n\nconst LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nconst LITERALS      = 256;\n/* number of literal bytes 0..255 */\nconst L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nconst D_CODES       = 30;\n/* number of distance codes */\nconst BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nconst HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nconst MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nconst MIN_MATCH = 3;\nconst MAX_MATCH = 258;\nconst MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nconst PRESET_DICT = 0x20;\n\nconst INIT_STATE    =  42;    /* zlib header -> BUSY_STATE */\n//#ifdef GZIP\nconst GZIP_STATE    =  57;    /* gzip header -> BUSY_STATE | EXTRA_STATE */\n//#endif\nconst EXTRA_STATE   =  69;    /* gzip extra block -> NAME_STATE */\nconst NAME_STATE    =  73;    /* gzip file name -> COMMENT_STATE */\nconst COMMENT_STATE =  91;    /* gzip comment -> HCRC_STATE */\nconst HCRC_STATE    = 103;    /* gzip header CRC -> BUSY_STATE */\nconst BUSY_STATE    = 113;    /* deflate -> FINISH_STATE */\nconst FINISH_STATE  = 666;    /* stream complete */\n\nconst BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nconst BS_BLOCK_DONE     = 2; /* block flush performed */\nconst BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nconst BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nconst OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nconst err = (strm, errorCode) => {\n  strm.msg = messages[errorCode];\n  return errorCode;\n};\n\nconst rank = (f) => {\n  return ((f) * 2) - ((f) > 4 ? 9 : 0);\n};\n\nconst zero = (buf) => {\n  let len = buf.length; while (--len >= 0) { buf[len] = 0; }\n};\n\n/* ===========================================================================\n * Slide the hash table when sliding the window down (could be avoided with 32\n * bit values at the expense of memory usage). We slide even when level == 0 to\n * keep the hash table consistent if we switch back to level > 0 later.\n */\nconst slide_hash = (s) => {\n  let n, m;\n  let p;\n  let wsize = s.w_size;\n\n  n = s.hash_size;\n  p = n;\n  do {\n    m = s.head[--p];\n    s.head[p] = (m >= wsize ? m - wsize : 0);\n  } while (--n);\n  n = wsize;\n//#ifndef FASTEST\n  p = n;\n  do {\n    m = s.prev[--p];\n    s.prev[p] = (m >= wsize ? m - wsize : 0);\n    /* If n is not on any hash chain, prev[n] is garbage but\n     * its value will never be used.\n     */\n  } while (--n);\n//#endif\n};\n\n/* eslint-disable new-cap */\nlet HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;\n// This hash causes less collisions, https://github.com/nodeca/pako/issues/135\n// But breaks binary compatibility\n//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;\nlet HASH = HASH_ZLIB;\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output, except for\n * some deflate_stored() output, goes through this function so some\n * applications may wish to modify it to avoid allocating a large\n * strm->next_out buffer and copying into it. (See also read_buf()).\n */\nconst flush_pending = (strm) => {\n  const s = strm.state;\n\n  //_tr_flush_bits(s);\n  let len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);\n  strm.next_out  += len;\n  s.pending_out  += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending      -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n};\n\n\nconst flush_block_only = (s, last) => {\n  _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n};\n\n\nconst put_byte = (s, b) => {\n  s.pending_buf[s.pending++] = b;\n};\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nconst putShortMSB = (s, b) => {\n\n  //  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n};\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nconst read_buf = (strm, buf, start, size) => {\n\n  let len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32_1(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32_1(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n};\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nconst longest_match = (s, cur_match) => {\n\n  let chain_length = s.max_chain_length;      /* max hash chain length */\n  let scan = s.strstart; /* current string */\n  let match;                       /* matched string */\n  let len;                           /* length of current match */\n  let best_len = s.prev_length;              /* best match length so far */\n  let nice_match = s.nice_match;             /* stop if match long enough */\n  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  const _win = s.window; // shortcut\n\n  const wmask = s.w_mask;\n  const prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  const strend = s.strstart + MAX_MATCH;\n  let scan_end1  = _win[scan + best_len - 1];\n  let scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n};\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nconst fill_window = (s) => {\n\n  const _w_size = s.w_size;\n  let n, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n      if (s.insert > s.strstart) {\n        s.insert = s.strstart;\n      }\n      slide_hash(s);\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    const curr = s.strstart + s.lookahead;\n//    let init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n};\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n *\n * In case deflateParams() is used to later switch to a non-zero compression\n * level, s->matches (otherwise unused when storing) keeps track of the number\n * of hash table slides to perform. If s->matches is 1, then one hash table\n * slide will be done when switching. If s->matches is 2, the maximum value\n * allowed here, then the hash table will be cleared, since two or more slides\n * is the same as a clear.\n *\n * deflate_stored() is written to minimize the number of times an input byte is\n * copied. It is most efficient with large input and output buffers, which\n * maximizes the opportunites to have a single copy from next_in to next_out.\n */\nconst deflate_stored = (s, flush) => {\n\n  /* Smallest worthy block size when not flushing or finishing. By default\n   * this is 32K. This can be as small as 507 bytes for memLevel == 1. For\n   * large input and output buffers, the stored block size will be larger.\n   */\n  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;\n\n  /* Copy as many min_block or larger stored blocks directly to next_out as\n   * possible. If flushing, copy the remaining available input to next_out as\n   * stored blocks, if there is enough space.\n   */\n  let len, left, have, last = 0;\n  let used = s.strm.avail_in;\n  do {\n    /* Set len to the maximum size block that we can copy directly with the\n     * available input data and output space. Set left to how much of that\n     * would be copied from what's left in the window.\n     */\n    len = 65535/* MAX_STORED */;     /* maximum deflate stored block length */\n    have = (s.bi_valid + 42) >> 3;     /* number of header bytes */\n    if (s.strm.avail_out < have) {         /* need room for header */\n      break;\n    }\n      /* maximum stored block length that will fit in avail_out: */\n    have = s.strm.avail_out - have;\n    left = s.strstart - s.block_start;  /* bytes left in window */\n    if (len > left + s.strm.avail_in) {\n      len = left + s.strm.avail_in;   /* limit len to the input */\n    }\n    if (len > have) {\n      len = have;             /* limit len to the output */\n    }\n\n    /* If the stored block would be less than min_block in length, or if\n     * unable to copy all of the available input when flushing, then try\n     * copying to the window and the pending buffer instead. Also don't\n     * write an empty block when flushing -- deflate() does that.\n     */\n    if (len < min_block && ((len === 0 && flush !== Z_FINISH$3) ||\n                        flush === Z_NO_FLUSH$2 ||\n                        len !== left + s.strm.avail_in)) {\n      break;\n    }\n\n    /* Make a dummy stored block in pending to get the header bytes,\n     * including any pending bits. This also updates the debugging counts.\n     */\n    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;\n    _tr_stored_block(s, 0, 0, last);\n\n    /* Replace the lengths in the dummy stored block with len. */\n    s.pending_buf[s.pending - 4] = len;\n    s.pending_buf[s.pending - 3] = len >> 8;\n    s.pending_buf[s.pending - 2] = ~len;\n    s.pending_buf[s.pending - 1] = ~len >> 8;\n\n    /* Write the stored block header bytes. */\n    flush_pending(s.strm);\n\n//#ifdef ZLIB_DEBUG\n//    /* Update debugging counts for the data about to be copied. */\n//    s->compressed_len += len << 3;\n//    s->bits_sent += len << 3;\n//#endif\n\n    /* Copy uncompressed bytes from the window to next_out. */\n    if (left) {\n      if (left > len) {\n        left = len;\n      }\n      //zmemcpy(s->strm->next_out, s->window + s->block_start, left);\n      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);\n      s.strm.next_out += left;\n      s.strm.avail_out -= left;\n      s.strm.total_out += left;\n      s.block_start += left;\n      len -= left;\n    }\n\n    /* Copy uncompressed bytes directly from next_in to next_out, updating\n     * the check value.\n     */\n    if (len) {\n      read_buf(s.strm, s.strm.output, s.strm.next_out, len);\n      s.strm.next_out += len;\n      s.strm.avail_out -= len;\n      s.strm.total_out += len;\n    }\n  } while (last === 0);\n\n  /* Update the sliding window with the last s->w_size bytes of the copied\n   * data, or append all of the copied data to the existing window if less\n   * than s->w_size bytes were copied. Also update the number of bytes to\n   * insert in the hash tables, in the event that deflateParams() switches to\n   * a non-zero compression level.\n   */\n  used -= s.strm.avail_in;    /* number of input bytes directly copied */\n  if (used) {\n    /* If any input was used, then no unused input remains in the window,\n     * therefore s->block_start == s->strstart.\n     */\n    if (used >= s.w_size) {  /* supplant the previous history */\n      s.matches = 2;     /* clear hash */\n      //zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);\n      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);\n      s.strstart = s.w_size;\n      s.insert = s.strstart;\n    }\n    else {\n      if (s.window_size - s.strstart <= used) {\n        /* Slide the window down. */\n        s.strstart -= s.w_size;\n        //zmemcpy(s->window, s->window + s->w_size, s->strstart);\n        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);\n        if (s.matches < 2) {\n          s.matches++;   /* add a pending slide_hash() */\n        }\n        if (s.insert > s.strstart) {\n          s.insert = s.strstart;\n        }\n      }\n      //zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);\n      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);\n      s.strstart += used;\n      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;\n    }\n    s.block_start = s.strstart;\n  }\n  if (s.high_water < s.strstart) {\n    s.high_water = s.strstart;\n  }\n\n  /* If the last block was written to next_out, then done. */\n  if (last) {\n    return BS_FINISH_DONE;\n  }\n\n  /* If flushing and all input has been consumed, then done. */\n  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 &&\n    s.strm.avail_in === 0 && s.strstart === s.block_start) {\n    return BS_BLOCK_DONE;\n  }\n\n  /* Fill the window with any remaining input. */\n  have = s.window_size - s.strstart;\n  if (s.strm.avail_in > have && s.block_start >= s.w_size) {\n    /* Slide the window down. */\n    s.block_start -= s.w_size;\n    s.strstart -= s.w_size;\n    //zmemcpy(s->window, s->window + s->w_size, s->strstart);\n    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);\n    if (s.matches < 2) {\n      s.matches++;       /* add a pending slide_hash() */\n    }\n    have += s.w_size;      /* more space now */\n    if (s.insert > s.strstart) {\n      s.insert = s.strstart;\n    }\n  }\n  if (have > s.strm.avail_in) {\n    have = s.strm.avail_in;\n  }\n  if (have) {\n    read_buf(s.strm, s.window, s.strstart, have);\n    s.strstart += have;\n    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;\n  }\n  if (s.high_water < s.strstart) {\n    s.high_water = s.strstart;\n  }\n\n  /* There was not enough avail_out to write a complete worthy or flushed\n   * stored block to next_out. Write a stored block to pending instead, if we\n   * have enough input for a worthy block, or if flushing and there is enough\n   * room for the remaining input as a stored block in the pending buffer.\n   */\n  have = (s.bi_valid + 42) >> 3;     /* number of header bytes */\n    /* maximum stored block length that will fit in pending: */\n  have = s.pending_buf_size - have > 65535/* MAX_STORED */ ? 65535/* MAX_STORED */ : s.pending_buf_size - have;\n  min_block = have > s.w_size ? s.w_size : have;\n  left = s.strstart - s.block_start;\n  if (left >= min_block ||\n     ((left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 &&\n     s.strm.avail_in === 0 && left <= have)) {\n    len = left > have ? have : left;\n    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 &&\n         len === left ? 1 : 0;\n    _tr_stored_block(s, s.block_start, len, last);\n    s.block_start += len;\n    flush_pending(s.strm);\n  }\n\n  /* We've done all we can with the available input and output. */\n  return last ? BS_FINISH_STARTED : BS_NEED_MORE;\n};\n\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nconst deflate_fast = (s, flush) => {\n\n  let hash_head;        /* head of the hash chain */\n  let bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH$3) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.sym_next) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nconst deflate_slow = (s, flush) => {\n\n  let hash_head;          /* head of hash chain */\n  let bflush;              /* set if current block must be flushed */\n\n  let max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH$3) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.sym_next) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n};\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nconst deflate_rle = (s, flush) => {\n\n  let bflush;            /* set if current block must be flushed */\n  let prev;              /* byte at distance one to match */\n  let scan, strend;      /* scan goes up to strend for length of run */\n\n  const _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH$3) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.sym_next) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nconst deflate_huff = (s, flush) => {\n\n  let bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH$2) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = _tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH$3) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.sym_next) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n};\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nconst configuration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nconst lm_init = (s) => {\n\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n};\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED$2; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);\n  this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new Uint16Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.sym_buf = 0;        /* buffer for distances and literals/lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.sym_next = 0;      /* running index in sym_buf */\n  this.sym_end = 0;       /* symbol table full when sym_next reaches this */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\n/* =========================================================================\n * Check for a valid deflate stream state. Return 0 if ok, 1 if not.\n */\nconst deflateStateCheck = (strm) => {\n\n  if (!strm) {\n    return 1;\n  }\n  const s = strm.state;\n  if (!s || s.strm !== strm || (s.status !== INIT_STATE &&\n//#ifdef GZIP\n                                s.status !== GZIP_STATE &&\n//#endif\n                                s.status !== EXTRA_STATE &&\n                                s.status !== NAME_STATE &&\n                                s.status !== COMMENT_STATE &&\n                                s.status !== HCRC_STATE &&\n                                s.status !== BUSY_STATE &&\n                                s.status !== FINISH_STATE)) {\n    return 1;\n  }\n  return 0;\n};\n\n\nconst deflateResetKeep = (strm) => {\n\n  if (deflateStateCheck(strm)) {\n    return err(strm, Z_STREAM_ERROR$2);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  const s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status =\n//#ifdef GZIP\n    s.wrap === 2 ? GZIP_STATE :\n//#endif\n    s.wrap ? INIT_STATE : BUSY_STATE;\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = -2;\n  _tr_init(s);\n  return Z_OK$3;\n};\n\n\nconst deflateReset = (strm) => {\n\n  const ret = deflateResetKeep(strm);\n  if (ret === Z_OK$3) {\n    lm_init(strm.state);\n  }\n  return ret;\n};\n\n\nconst deflateSetHeader = (strm, head) => {\n\n  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {\n    return Z_STREAM_ERROR$2;\n  }\n  strm.state.gzhead = head;\n  return Z_OK$3;\n};\n\n\nconst deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {\n\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR$2;\n  }\n  let wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION$1) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED || (windowBits === 8 && wrap !== 1)) {\n    return err(strm, Z_STREAM_ERROR$2);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  const s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n  s.status = INIT_STATE;     /* to pass state test in deflateReset() */\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new Uint8Array(s.w_size * 2);\n  s.head = new Uint16Array(s.hash_size);\n  s.prev = new Uint16Array(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  /* We overlay pending_buf and sym_buf. This works since the average size\n   * for length/distance pairs over any compressed block is assured to be 31\n   * bits or less.\n   *\n   * Analysis: The longest fixed codes are a length code of 8 bits plus 5\n   * extra bits, for lengths 131 to 257. The longest fixed distance codes are\n   * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest\n   * possible fixed-codes length/distance pair is then 31 bits total.\n   *\n   * sym_buf starts one-fourth of the way into pending_buf. So there are\n   * three bytes in sym_buf for every four bytes in pending_buf. Each symbol\n   * in sym_buf is three bytes -- two for the distance and one for the\n   * literal/length. As each symbol is consumed, the pointer to the next\n   * sym_buf value to read moves forward three bytes. From that symbol, up to\n   * 31 bits are written to pending_buf. The closest the written pending_buf\n   * bits gets to the next sym_buf symbol to read is just before the last\n   * code is written. At that time, 31*(n-2) bits have been written, just\n   * after 24*(n-2) bits have been consumed from sym_buf. sym_buf starts at\n   * 8*n bits into pending_buf. (Note that the symbol buffer fills when n-1\n   * symbols are written.) The closest the writing gets to what is unread is\n   * then n+14 bits. Here n is lit_bufsize, which is 16384 by default, and\n   * can range from 128 to 32768.\n   *\n   * Therefore, at a minimum, there are 142 bits of space between what is\n   * written and what is read in the overlain buffers, so the symbols cannot\n   * be overwritten by the compressed data. That space is actually 139 bits,\n   * due to the three-bit fixed-code block header.\n   *\n   * That covers the case where either Z_FIXED is specified, forcing fixed\n   * codes, or when the use of fixed codes is chosen, because that choice\n   * results in a smaller compressed block than dynamic codes. That latter\n   * condition then assures that the above analysis also covers all dynamic\n   * blocks. A dynamic-code block will only be chosen to be emitted if it has\n   * fewer bits than a fixed-code block would for the same set of symbols.\n   * Therefore its average symbol length is assured to be less than 31. So\n   * the compressed data for a dynamic block also cannot overwrite the\n   * symbols from which it is being constructed.\n   */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n  s.pending_buf = new Uint8Array(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->sym_buf = s->pending_buf + s->lit_bufsize;\n  s.sym_buf = s.lit_bufsize;\n\n  //s->sym_end = (s->lit_bufsize - 1) * 3;\n  s.sym_end = (s.lit_bufsize - 1) * 3;\n  /* We avoid equality with lit_bufsize*3 because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n};\n\nconst deflateInit = (strm, level) => {\n\n  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);\n};\n\n\n/* ========================================================================= */\nconst deflate$2 = (strm, flush) => {\n\n  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;\n  }\n\n  const s = strm.state;\n\n  if (!strm.output ||\n      (strm.avail_in !== 0 && !strm.input) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH$3)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);\n  }\n\n  const old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK$3;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH$3) {\n    return err(strm, Z_BUF_ERROR$1);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR$1);\n  }\n\n  /* Write the header */\n  if (s.status === INIT_STATE && s.wrap === 0) {\n    s.status = BUSY_STATE;\n  }\n  if (s.status === INIT_STATE) {\n    /* zlib header */\n    let header = (Z_DEFLATED$2 + ((s.w_bits - 8) << 4)) << 8;\n    let level_flags = -1;\n\n    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n      level_flags = 0;\n    } else if (s.level < 6) {\n      level_flags = 1;\n    } else if (s.level === 6) {\n      level_flags = 2;\n    } else {\n      level_flags = 3;\n    }\n    header |= (level_flags << 6);\n    if (s.strstart !== 0) { header |= PRESET_DICT; }\n    header += 31 - (header % 31);\n\n    putShortMSB(s, header);\n\n    /* Save the adler32 of the preset dictionary: */\n    if (s.strstart !== 0) {\n      putShortMSB(s, strm.adler >>> 16);\n      putShortMSB(s, strm.adler & 0xffff);\n    }\n    strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    s.status = BUSY_STATE;\n\n    /* Compression must start with an empty pending buffer */\n    flush_pending(strm);\n    if (s.pending !== 0) {\n      s.last_flush = -1;\n      return Z_OK$3;\n    }\n  }\n//#ifdef GZIP\n  if (s.status === GZIP_STATE) {\n    /* gzip header */\n    strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n    put_byte(s, 31);\n    put_byte(s, 139);\n    put_byte(s, 8);\n    if (!s.gzhead) { // s->gzhead == Z_NULL\n      put_byte(s, 0);\n      put_byte(s, 0);\n      put_byte(s, 0);\n      put_byte(s, 0);\n      put_byte(s, 0);\n      put_byte(s, s.level === 9 ? 2 :\n                  (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                   4 : 0));\n      put_byte(s, OS_CODE);\n      s.status = BUSY_STATE;\n\n      /* Compression must start with an empty pending buffer */\n      flush_pending(strm);\n      if (s.pending !== 0) {\n        s.last_flush = -1;\n        return Z_OK$3;\n      }\n    }\n    else {\n      put_byte(s, (s.gzhead.text ? 1 : 0) +\n                  (s.gzhead.hcrc ? 2 : 0) +\n                  (!s.gzhead.extra ? 0 : 4) +\n                  (!s.gzhead.name ? 0 : 8) +\n                  (!s.gzhead.comment ? 0 : 16)\n      );\n      put_byte(s, s.gzhead.time & 0xff);\n      put_byte(s, (s.gzhead.time >> 8) & 0xff);\n      put_byte(s, (s.gzhead.time >> 16) & 0xff);\n      put_byte(s, (s.gzhead.time >> 24) & 0xff);\n      put_byte(s, s.level === 9 ? 2 :\n                  (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                   4 : 0));\n      put_byte(s, s.gzhead.os & 0xff);\n      if (s.gzhead.extra && s.gzhead.extra.length) {\n        put_byte(s, s.gzhead.extra.length & 0xff);\n        put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n      }\n      if (s.gzhead.hcrc) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);\n      }\n      s.gzindex = 0;\n      s.status = EXTRA_STATE;\n    }\n  }\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      let beg = s.pending;   /* start of bytes to update crc */\n      let left = (s.gzhead.extra.length & 0xffff) - s.gzindex;\n      while (s.pending + left > s.pending_buf_size) {\n        let copy = s.pending_buf_size - s.pending;\n        // zmemcpy(s.pending_buf + s.pending,\n        //    s.gzhead.extra + s.gzindex, copy);\n        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);\n        s.pending = s.pending_buf_size;\n        //--- HCRC_UPDATE(beg) ---//\n        if (s.gzhead.hcrc && s.pending > beg) {\n          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n        }\n        //---//\n        s.gzindex += copy;\n        flush_pending(strm);\n        if (s.pending !== 0) {\n          s.last_flush = -1;\n          return Z_OK$3;\n        }\n        beg = 0;\n        left -= copy;\n      }\n      // JS specific: s.gzhead.extra may be TypedArray or Array for backward compatibility\n      //              TypedArray.slice and TypedArray.from don't exist in IE10-IE11\n      let gzhead_extra = new Uint8Array(s.gzhead.extra);\n      // zmemcpy(s->pending_buf + s->pending,\n      //     s->gzhead->extra + s->gzindex, left);\n      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);\n      s.pending += left;\n      //--- HCRC_UPDATE(beg) ---//\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      //---//\n      s.gzindex = 0;\n    }\n    s.status = NAME_STATE;\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      let beg = s.pending;   /* start of bytes to update crc */\n      let val;\n      do {\n        if (s.pending === s.pending_buf_size) {\n          //--- HCRC_UPDATE(beg) ---//\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          //---//\n          flush_pending(strm);\n          if (s.pending !== 0) {\n            s.last_flush = -1;\n            return Z_OK$3;\n          }\n          beg = 0;\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n      //--- HCRC_UPDATE(beg) ---//\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      //---//\n      s.gzindex = 0;\n    }\n    s.status = COMMENT_STATE;\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      let beg = s.pending;   /* start of bytes to update crc */\n      let val;\n      do {\n        if (s.pending === s.pending_buf_size) {\n          //--- HCRC_UPDATE(beg) ---//\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          //---//\n          flush_pending(strm);\n          if (s.pending !== 0) {\n            s.last_flush = -1;\n            return Z_OK$3;\n          }\n          beg = 0;\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n      //--- HCRC_UPDATE(beg) ---//\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      //---//\n    }\n    s.status = HCRC_STATE;\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n        if (s.pending !== 0) {\n          s.last_flush = -1;\n          return Z_OK$3;\n        }\n      }\n      put_byte(s, strm.adler & 0xff);\n      put_byte(s, (strm.adler >> 8) & 0xff);\n      strm.adler = 0; //crc32(0L, Z_NULL, 0);\n    }\n    s.status = BUSY_STATE;\n\n    /* Compression must start with an empty pending buffer */\n    flush_pending(strm);\n    if (s.pending !== 0) {\n      s.last_flush = -1;\n      return Z_OK$3;\n    }\n  }\n//#endif\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE)) {\n    let bstate = s.level === 0 ? deflate_stored(s, flush) :\n                 s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :\n                 s.strategy === Z_RLE ? deflate_rle(s, flush) :\n                 configuration_table[s.level].func(s, flush);\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK$3;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        _tr_align(s);\n      }\n      else if (flush !== Z_BLOCK$1) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        _tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH$1) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK$3;\n      }\n    }\n  }\n\n  if (flush !== Z_FINISH$3) { return Z_OK$3; }\n  if (s.wrap <= 0) { return Z_STREAM_END$3; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;\n};\n\n\nconst deflateEnd = (strm) => {\n\n  if (deflateStateCheck(strm)) {\n    return Z_STREAM_ERROR$2;\n  }\n\n  const status = strm.state.status;\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;\n};\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nconst deflateSetDictionary = (strm, dictionary) => {\n\n  let dictLength = dictionary.length;\n\n  if (deflateStateCheck(strm)) {\n    return Z_STREAM_ERROR$2;\n  }\n\n  const s = strm.state;\n  const wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR$2;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    let tmpDict = new Uint8Array(s.w_size);\n    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  const avail = strm.avail_in;\n  const next = strm.next_in;\n  const input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    let str = s.strstart;\n    let n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK$3;\n};\n\n\nvar deflateInit_1 = deflateInit;\nvar deflateInit2_1 = deflateInit2;\nvar deflateReset_1 = deflateReset;\nvar deflateResetKeep_1 = deflateResetKeep;\nvar deflateSetHeader_1 = deflateSetHeader;\nvar deflate_2$1 = deflate$2;\nvar deflateEnd_1 = deflateEnd;\nvar deflateSetDictionary_1 = deflateSetDictionary;\nvar deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nmodule.exports.deflateBound = deflateBound;\nmodule.exports.deflateCopy = deflateCopy;\nmodule.exports.deflateGetDictionary = deflateGetDictionary;\nmodule.exports.deflateParams = deflateParams;\nmodule.exports.deflatePending = deflatePending;\nmodule.exports.deflatePrime = deflatePrime;\nmodule.exports.deflateTune = deflateTune;\n*/\n\nvar deflate_1$2 = {\n\tdeflateInit: deflateInit_1,\n\tdeflateInit2: deflateInit2_1,\n\tdeflateReset: deflateReset_1,\n\tdeflateResetKeep: deflateResetKeep_1,\n\tdeflateSetHeader: deflateSetHeader_1,\n\tdeflate: deflate_2$1,\n\tdeflateEnd: deflateEnd_1,\n\tdeflateSetDictionary: deflateSetDictionary_1,\n\tdeflateInfo: deflateInfo\n};\n\nconst _has = (obj, key) => {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n};\n\nvar assign = function (obj /*from1, from2, from3, ...*/) {\n  const sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    const source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (const p in source) {\n      if (_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// Join array of chunks to single array.\nvar flattenChunks = (chunks) => {\n  // calculate data length\n  let len = 0;\n\n  for (let i = 0, l = chunks.length; i < l; i++) {\n    len += chunks[i].length;\n  }\n\n  // join chunks\n  const result = new Uint8Array(len);\n\n  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {\n    let chunk = chunks[i];\n    result.set(chunk, pos);\n    pos += chunk.length;\n  }\n\n  return result;\n};\n\nvar common = {\n\tassign: assign,\n\tflattenChunks: flattenChunks\n};\n\n// String encode/decode helpers\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nlet STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nconst _utf8len = new Uint8Array(256);\nfor (let q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nvar string2buf = (str) => {\n  if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {\n    return new TextEncoder().encode(str);\n  }\n\n  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new Uint8Array(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper\nconst buf2binstring = (buf, len) => {\n  // On Chrome, the arguments in a function call that are allowed is `65534`.\n  // If the length of the buffer is smaller than that, we can use this optimization,\n  // otherwise we will take a slower path.\n  if (len < 65534) {\n    if (buf.subarray && STR_APPLY_UIA_OK) {\n      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));\n    }\n  }\n\n  let result = '';\n  for (let i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n};\n\n\n// convert array to string\nvar buf2string = (buf, max) => {\n  const len = max || buf.length;\n\n  if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {\n    return new TextDecoder().decode(buf.subarray(0, max));\n  }\n\n  let i, out;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  const utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    let c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    let c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nvar utf8border = (buf, max) => {\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  let pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\nvar strings = {\n\tstring2buf: string2buf,\n\tbuf2string: buf2string,\n\tutf8border: utf8border\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nvar zstream = ZStream;\n\nconst toString$1 = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH: Z_FINISH$2,\n  Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2,\n  Z_DEFAULT_COMPRESSION,\n  Z_DEFAULT_STRATEGY,\n  Z_DEFLATED: Z_DEFLATED$1\n} = constants$2;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako')\n *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * const deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate$1(options) {\n  this.options = common.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED$1,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY\n  }, options || {});\n\n  let opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new zstream();\n  this.strm.avail_out = 0;\n\n  let status = deflate_1$2.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK$2) {\n    throw new Error(messages[status]);\n  }\n\n  if (opt.header) {\n    deflate_1$2.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    let dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = deflate_1$2.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK$2) {\n      throw new Error(messages[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, flush_mode]) -> Boolean\n * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must\n * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending\n * buffers and call [[Deflate#onEnd]].\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate$1.prototype.push = function (data, flush_mode) {\n  const strm = this.strm;\n  const chunkSize = this.options.chunkSize;\n  let status, _flush_mode;\n\n  if (this.ended) { return false; }\n\n  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;\n  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString$1.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  for (;;) {\n    if (strm.avail_out === 0) {\n      strm.output = new Uint8Array(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    // Make sure avail_out > 6 to avoid repeating markers\n    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {\n      this.onData(strm.output.subarray(0, strm.next_out));\n      strm.avail_out = 0;\n      continue;\n    }\n\n    status = deflate_1$2.deflate(strm, _flush_mode);\n\n    // Ended => flush and finish\n    if (status === Z_STREAM_END$2) {\n      if (strm.next_out > 0) {\n        this.onData(strm.output.subarray(0, strm.next_out));\n      }\n      status = deflate_1$2.deflateEnd(this.strm);\n      this.onEnd(status);\n      this.ended = true;\n      return status === Z_OK$2;\n    }\n\n    // Flush if out buffer full\n    if (strm.avail_out === 0) {\n      this.onData(strm.output);\n      continue;\n    }\n\n    // Flush if requested and has data\n    if (_flush_mode > 0 && strm.next_out > 0) {\n      this.onData(strm.output.subarray(0, strm.next_out));\n      strm.avail_out = 0;\n      continue;\n    }\n\n    if (strm.avail_in === 0) break;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array): output data.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate$1.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH). By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate$1.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK$2) {\n    this.result = common.flattenChunks(this.chunks);\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array\n * - data (Uint8Array|ArrayBuffer|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako')\n * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate$1(input, options) {\n  const deflator = new Deflate$1(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || messages[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array\n * - data (Uint8Array|ArrayBuffer|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw$1(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate$1(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array\n * - data (Uint8Array|ArrayBuffer|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip$1(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate$1(input, options);\n}\n\n\nvar Deflate_1$1 = Deflate$1;\nvar deflate_2 = deflate$1;\nvar deflateRaw_1$1 = deflateRaw$1;\nvar gzip_1$1 = gzip$1;\nvar constants$1 = constants$2;\n\nvar deflate_1$1 = {\n\tDeflate: Deflate_1$1,\n\tdeflate: deflate_2,\n\tdeflateRaw: deflateRaw_1$1,\n\tgzip: gzip_1$1,\n\tconstants: constants$1\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// See state defs from inflate.js\nconst BAD$1 = 16209;       /* got a data error -- remain here until reset */\nconst TYPE$1 = 16191;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nvar inffast = function inflate_fast(strm, start) {\n  let _in;                    /* local strm.input */\n  let last;                   /* have enough input while in < last */\n  let _out;                   /* local strm.output */\n  let beg;                    /* inflate()'s initial strm.output */\n  let end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  let dmax;                   /* maximum distance from zlib header */\n//#endif\n  let wsize;                  /* window size or zero if not using window */\n  let whave;                  /* valid bytes in the window */\n  let wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  let s_window;               /* allocated sliding window, if wsize != 0 */\n  let hold;                   /* local strm.hold */\n  let bits;                   /* local strm.bits */\n  let lcode;                  /* local strm.lencode */\n  let dcode;                  /* local strm.distcode */\n  let lmask;                  /* mask for first level of length codes */\n  let dmask;                  /* mask for first level of distance codes */\n  let here;                   /* retrieved table entry */\n  let op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  let len;                    /* match length, unused bytes */\n  let dist;                   /* match distance */\n  let from;                   /* where to copy match from */\n  let from_source;\n\n\n  let input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  const state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD$1;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD$1;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD$1;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE$1;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD$1;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nconst MAXBITS = 15;\nconst ENOUGH_LENS$1 = 852;\nconst ENOUGH_DISTS$1 = 592;\n//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nconst CODES$1 = 0;\nconst LENS$1 = 1;\nconst DISTS$1 = 2;\n\nconst lbase = new Uint16Array([ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n]);\n\nconst lext = new Uint8Array([ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n]);\n\nconst dbase = new Uint16Array([ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n]);\n\nconst dext = new Uint8Array([ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n]);\n\nconst inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>\n{\n  const bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  let len = 0;               /* a code's length in bits */\n  let sym = 0;               /* index of code symbols */\n  let min = 0, max = 0;          /* minimum and maximum code lengths */\n  let root = 0;              /* number of index bits for root table */\n  let curr = 0;              /* number of index bits for current table */\n  let drop = 0;              /* code bits to drop for sub-table */\n  let left = 0;                   /* number of prefix codes available */\n  let used = 0;              /* code entries in table used */\n  let huff = 0;              /* Huffman code */\n  let incr;              /* for incrementing code, index */\n  let fill;              /* index for replicating entries */\n  let low;               /* low bits for current root entry */\n  let mask;              /* mask for low root bits */\n  let next;             /* next available space in table */\n  let base = null;     /* base value table to use */\n//  let shoextra;    /* extra bits table to use */\n  let match;                  /* use base and extra for symbol >= match */\n  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n  let extra = null;\n\n  let here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES$1 || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES$1) {\n    base = extra = work;    /* dummy value--not used */\n    match = 20;\n\n  } else if (type === LENS$1) {\n    base = lbase;\n    extra = lext;\n    match = 257;\n\n  } else {                    /* DISTS */\n    base = dbase;\n    extra = dext;\n    match = 0;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS$1 && used > ENOUGH_LENS$1) ||\n    (type === DISTS$1 && used > ENOUGH_DISTS$1)) {\n    return 1;\n  }\n\n  /* process all codes and make table entries */\n  for (;;) {\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] + 1 < match) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] >= match) {\n      here_op = extra[work[sym] - match];\n      here_val = base[work[sym] - match];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS$1 && used > ENOUGH_LENS$1) ||\n        (type === DISTS$1 && used > ENOUGH_DISTS$1)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n\n\nvar inftrees = inflate_table;\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n\n\n\n\n\nconst CODES = 0;\nconst LENS = 1;\nconst DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES,\n  Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR,\n  Z_DEFLATED\n} = constants$2;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nconst    HEAD = 16180;       /* i: waiting for magic header */\nconst    FLAGS = 16181;      /* i: waiting for method and flags (gzip) */\nconst    TIME = 16182;       /* i: waiting for modification time (gzip) */\nconst    OS = 16183;         /* i: waiting for extra flags and operating system (gzip) */\nconst    EXLEN = 16184;      /* i: waiting for extra length (gzip) */\nconst    EXTRA = 16185;      /* i: waiting for extra bytes (gzip) */\nconst    NAME = 16186;       /* i: waiting for end of file name (gzip) */\nconst    COMMENT = 16187;    /* i: waiting for end of comment (gzip) */\nconst    HCRC = 16188;       /* i: waiting for header crc (gzip) */\nconst    DICTID = 16189;    /* i: waiting for dictionary check value */\nconst    DICT = 16190;      /* waiting for inflateSetDictionary() call */\nconst        TYPE = 16191;      /* i: waiting for type bits, including last-flag bit */\nconst        TYPEDO = 16192;    /* i: same, but skip check to exit inflate on new block */\nconst        STORED = 16193;    /* i: waiting for stored size (length and complement) */\nconst        COPY_ = 16194;     /* i/o: same as COPY below, but only first time in */\nconst        COPY = 16195;      /* i/o: waiting for input or output to copy stored block */\nconst        TABLE = 16196;     /* i: waiting for dynamic block table lengths */\nconst        LENLENS = 16197;   /* i: waiting for code length code lengths */\nconst        CODELENS = 16198;  /* i: waiting for length/lit and distance code lengths */\nconst            LEN_ = 16199;      /* i: same as LEN below, but only first time in */\nconst            LEN = 16200;       /* i: waiting for length/lit/eob code */\nconst            LENEXT = 16201;    /* i: waiting for length extra bits */\nconst            DIST = 16202;      /* i: waiting for distance code */\nconst            DISTEXT = 16203;   /* i: waiting for distance extra bits */\nconst            MATCH = 16204;     /* o: waiting for output space to copy string */\nconst            LIT = 16205;       /* o: waiting for output space to write literal */\nconst    CHECK = 16206;     /* i: waiting for 32-bit check value */\nconst    LENGTH = 16207;    /* i: waiting for 32-bit length (gzip) */\nconst    DONE = 16208;      /* finished check, done -- remain here until reset */\nconst    BAD = 16209;       /* got a data error -- remain here until reset */\nconst    MEM = 16210;       /* got an inflate() memory error -- remain here until reset */\nconst    SYNC = 16211;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nconst ENOUGH_LENS = 852;\nconst ENOUGH_DISTS = 592;\n//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nconst MAX_WBITS = 15;\n/* 32K LZ77 window */\nconst DEF_WBITS = MAX_WBITS;\n\n\nconst zswap32 = (q) => {\n\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n};\n\n\nfunction InflateState() {\n  this.strm = null;           /* pointer back to this zlib stream */\n  this.mode = 0;              /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip,\n                                 bit 2 true to validate check value */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib), or\n                                 -1 if raw or no header yet */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new Uint16Array(320); /* temporary storage for code lengths */\n  this.work = new Uint16Array(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\n\nconst inflateStateCheck = (strm) => {\n\n  if (!strm) {\n    return 1;\n  }\n  const state = strm.state;\n  if (!state || state.strm !== strm ||\n    state.mode < HEAD || state.mode > SYNC) {\n    return 1;\n  }\n  return 0;\n};\n\n\nconst inflateResetKeep = (strm) => {\n\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  const state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.flags = -1;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);\n  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK$1;\n};\n\n\nconst inflateReset = (strm) => {\n\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  const state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n};\n\n\nconst inflateReset2 = (strm, windowBits) => {\n  let wrap;\n\n  /* get the state */\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  const state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 5;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR$1;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n};\n\n\nconst inflateInit2 = (strm, windowBits) => {\n\n  if (!strm) { return Z_STREAM_ERROR$1; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  const state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.strm = strm;\n  state.window = null/*Z_NULL*/;\n  state.mode = HEAD;     /* to pass state test in inflateReset2() */\n  const ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK$1) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n};\n\n\nconst inflateInit = (strm) => {\n\n  return inflateInit2(strm, DEF_WBITS);\n};\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nlet virgin = true;\n\nlet lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\n\nconst fixedtables = (state) => {\n\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    lenfix = new Int32Array(512);\n    distfix = new Int32Array(32);\n\n    /* literal/length table */\n    let sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inftrees(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inftrees(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n};\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nconst updatewindow = (strm, src, end, copy) => {\n\n  let dist;\n  const state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new Uint8Array(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    state.window.set(src.subarray(end - state.wsize, end), 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      state.window.set(src.subarray(end - copy, end), 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n};\n\n\nconst inflate$2 = (strm, flush) => {\n\n  let state;\n  let input, output;          // input/output buffers\n  let next;                   /* next input INDEX */\n  let put;                    /* next output INDEX */\n  let have, left;             /* available input and output */\n  let hold;                   /* bit buffer */\n  let bits;                   /* bits in bit buffer */\n  let _in, _out;              /* save starting available input and output */\n  let copy;                   /* number of stored or match bytes to copy */\n  let from;                   /* where to copy match bytes from */\n  let from_source;\n  let here = 0;               /* current decoding table entry */\n  let here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //let last;                   /* parent table entry */\n  let last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  let len;                    /* length to copy for repeats, bits to drop */\n  let ret;                    /* return code */\n  const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */\n  let opts;\n\n  let n; // temporary variable for NEED_BITS\n\n  const order = /* permutation of code lengths */\n    new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);\n\n\n  if (inflateStateCheck(strm) || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR$1;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK$1;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n      case HEAD:\n        if (state.wrap === 0) {\n          state.mode = TYPEDO;\n          break;\n        }\n        //=== NEEDBITS(16);\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n          if (state.wbits === 0) {\n            state.wbits = 15;\n          }\n          state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32_1(state.check, hbuf, 2, 0);\n          //===//\n\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          state.mode = FLAGS;\n          break;\n        }\n        if (state.head) {\n          state.head.done = false;\n        }\n        if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n          strm.msg = 'incorrect header check';\n          state.mode = BAD;\n          break;\n        }\n        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n        len = (hold & 0x0f)/*BITS(4)*/ + 8;\n        if (state.wbits === 0) {\n          state.wbits = len;\n        }\n        if (len > 15 || len > state.wbits) {\n          strm.msg = 'invalid window size';\n          state.mode = BAD;\n          break;\n        }\n\n        // !!! pako patch. Force use `options.windowBits` if passed.\n        // Required to always use max window size by default.\n        state.dmax = 1 << state.wbits;\n        //state.dmax = 1 << len;\n\n        state.flags = 0;               /* indicate zlib header */\n        //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = hold & 0x200 ? DICTID : TYPE;\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        break;\n      case FLAGS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.flags = hold;\n        if ((state.flags & 0xff) !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        if (state.flags & 0xe000) {\n          strm.msg = 'unknown header flags set';\n          state.mode = BAD;\n          break;\n        }\n        if (state.head) {\n          state.head.text = ((hold >> 8) & 1);\n        }\n        if ((state.flags & 0x0200) && (state.wrap & 4)) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32_1(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = TIME;\n        /* falls through */\n      case TIME:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.time = hold;\n        }\n        if ((state.flags & 0x0200) && (state.wrap & 4)) {\n          //=== CRC4(state.check, hold)\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          hbuf[2] = (hold >>> 16) & 0xff;\n          hbuf[3] = (hold >>> 24) & 0xff;\n          state.check = crc32_1(state.check, hbuf, 4, 0);\n          //===\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = OS;\n        /* falls through */\n      case OS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.xflags = (hold & 0xff);\n          state.head.os = (hold >> 8);\n        }\n        if ((state.flags & 0x0200) && (state.wrap & 4)) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32_1(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = EXLEN;\n        /* falls through */\n      case EXLEN:\n        if (state.flags & 0x0400) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length = hold;\n          if (state.head) {\n            state.head.extra_len = hold;\n          }\n          if ((state.flags & 0x0200) && (state.wrap & 4)) {\n            //=== CRC2(state.check, hold);\n            hbuf[0] = hold & 0xff;\n            hbuf[1] = (hold >>> 8) & 0xff;\n            state.check = crc32_1(state.check, hbuf, 2, 0);\n            //===//\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        else if (state.head) {\n          state.head.extra = null/*Z_NULL*/;\n        }\n        state.mode = EXTRA;\n        /* falls through */\n      case EXTRA:\n        if (state.flags & 0x0400) {\n          copy = state.length;\n          if (copy > have) { copy = have; }\n          if (copy) {\n            if (state.head) {\n              len = state.head.extra_len - state.length;\n              if (!state.head.extra) {\n                // Use untyped array for more convenient processing later\n                state.head.extra = new Uint8Array(state.head.extra_len);\n              }\n              state.head.extra.set(\n                input.subarray(\n                  next,\n                  // extra field is limited to 65536 bytes\n                  // - no need for additional size check\n                  next + copy\n                ),\n                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n                len\n              );\n              //zmemcpy(state.head.extra + len, next,\n              //        len + copy > state.head.extra_max ?\n              //        state.head.extra_max - len : copy);\n            }\n            if ((state.flags & 0x0200) && (state.wrap & 4)) {\n              state.check = crc32_1(state.check, input, copy, next);\n            }\n            have -= copy;\n            next += copy;\n            state.length -= copy;\n          }\n          if (state.length) { break inf_leave; }\n        }\n        state.length = 0;\n        state.mode = NAME;\n        /* falls through */\n      case NAME:\n        if (state.flags & 0x0800) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            // TODO: 2 or 1 bytes?\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.name_max*/)) {\n              state.head.name += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n\n          if ((state.flags & 0x0200) && (state.wrap & 4)) {\n            state.check = crc32_1(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.name = null;\n        }\n        state.length = 0;\n        state.mode = COMMENT;\n        /* falls through */\n      case COMMENT:\n        if (state.flags & 0x1000) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.comm_max*/)) {\n              state.head.comment += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n          if ((state.flags & 0x0200) && (state.wrap & 4)) {\n            state.check = crc32_1(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.comment = null;\n        }\n        state.mode = HCRC;\n        /* falls through */\n      case HCRC:\n        if (state.flags & 0x0200) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if ((state.wrap & 4) && hold !== (state.check & 0xffff)) {\n            strm.msg = 'header crc mismatch';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        if (state.head) {\n          state.head.hcrc = ((state.flags >> 9) & 1);\n          state.head.done = true;\n        }\n        strm.adler = state.check = 0;\n        state.mode = TYPE;\n        break;\n      case DICTID:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        strm.adler = state.check = zswap32(hold);\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = DICT;\n        /* falls through */\n      case DICT:\n        if (state.havedict === 0) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          return Z_NEED_DICT$1;\n        }\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = TYPE;\n        /* falls through */\n      case TYPE:\n        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case TYPEDO:\n        if (state.last) {\n          //--- BYTEBITS() ---//\n          hold >>>= bits & 7;\n          bits -= bits & 7;\n          //---//\n          state.mode = CHECK;\n          break;\n        }\n        //=== NEEDBITS(3); */\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.last = (hold & 0x01)/*BITS(1)*/;\n        //--- DROPBITS(1) ---//\n        hold >>>= 1;\n        bits -= 1;\n        //---//\n\n        switch ((hold & 0x03)/*BITS(2)*/) {\n          case 0:                             /* stored block */\n            //Tracev((stderr, \"inflate:     stored block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = STORED;\n            break;\n          case 1:                             /* fixed block */\n            fixedtables(state);\n            //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = LEN_;             /* decode codes */\n            if (flush === Z_TREES) {\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n              break inf_leave;\n            }\n            break;\n          case 2:                             /* dynamic block */\n            //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = TABLE;\n            break;\n          case 3:\n            strm.msg = 'invalid block type';\n            state.mode = BAD;\n        }\n        //--- DROPBITS(2) ---//\n        hold >>>= 2;\n        bits -= 2;\n        //---//\n        break;\n      case STORED:\n        //--- BYTEBITS() ---// /* go to byte boundary */\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n          strm.msg = 'invalid stored block lengths';\n          state.mode = BAD;\n          break;\n        }\n        state.length = hold & 0xffff;\n        //Tracev((stderr, \"inflate:       stored length %u\\n\",\n        //        state.length));\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = COPY_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case COPY_:\n        state.mode = COPY;\n        /* falls through */\n      case COPY:\n        copy = state.length;\n        if (copy) {\n          if (copy > have) { copy = have; }\n          if (copy > left) { copy = left; }\n          if (copy === 0) { break inf_leave; }\n          //--- zmemcpy(put, next, copy); ---\n          output.set(input.subarray(next, next + copy), put);\n          //---//\n          have -= copy;\n          next += copy;\n          left -= copy;\n          put += copy;\n          state.length -= copy;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       stored end\\n\"));\n        state.mode = TYPE;\n        break;\n      case TABLE:\n        //=== NEEDBITS(14); */\n        while (bits < 14) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n        if (state.nlen > 286 || state.ndist > 30) {\n          strm.msg = 'too many length or distance symbols';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n        state.have = 0;\n        state.mode = LENLENS;\n        /* falls through */\n      case LENLENS:\n        while (state.have < state.ncode) {\n          //=== NEEDBITS(3);\n          while (bits < 3) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n          //--- DROPBITS(3) ---//\n          hold >>>= 3;\n          bits -= 3;\n          //---//\n        }\n        while (state.have < 19) {\n          state.lens[order[state.have++]] = 0;\n        }\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        //state.next = state.codes;\n        //state.lencode = state.next;\n        // Switch to use dynamic table\n        state.lencode = state.lendyn;\n        state.lenbits = 7;\n\n        opts = { bits: state.lenbits };\n        ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n        state.lenbits = opts.bits;\n\n        if (ret) {\n          strm.msg = 'invalid code lengths set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n        state.have = 0;\n        state.mode = CODELENS;\n        /* falls through */\n      case CODELENS:\n        while (state.have < state.nlen + state.ndist) {\n          for (;;) {\n            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          if (here_val < 16) {\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            state.lens[state.have++] = here_val;\n          }\n          else {\n            if (here_val === 16) {\n              //=== NEEDBITS(here.bits + 2);\n              n = here_bits + 2;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              if (state.have === 0) {\n                strm.msg = 'invalid bit length repeat';\n                state.mode = BAD;\n                break;\n              }\n              len = state.lens[state.have - 1];\n              copy = 3 + (hold & 0x03);//BITS(2);\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n            }\n            else if (here_val === 17) {\n              //=== NEEDBITS(here.bits + 3);\n              n = here_bits + 3;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 3 + (hold & 0x07);//BITS(3);\n              //--- DROPBITS(3) ---//\n              hold >>>= 3;\n              bits -= 3;\n              //---//\n            }\n            else {\n              //=== NEEDBITS(here.bits + 7);\n              n = here_bits + 7;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 11 + (hold & 0x7f);//BITS(7);\n              //--- DROPBITS(7) ---//\n              hold >>>= 7;\n              bits -= 7;\n              //---//\n            }\n            if (state.have + copy > state.nlen + state.ndist) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            while (copy--) {\n              state.lens[state.have++] = len;\n            }\n          }\n        }\n\n        /* handle error breaks in while */\n        if (state.mode === BAD) { break; }\n\n        /* check for end-of-block code (better have one) */\n        if (state.lens[256] === 0) {\n          strm.msg = 'invalid code -- missing end-of-block';\n          state.mode = BAD;\n          break;\n        }\n\n        /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */\n        state.lenbits = 9;\n\n        opts = { bits: state.lenbits };\n        ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.lenbits = opts.bits;\n        // state.lencode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid literal/lengths set';\n          state.mode = BAD;\n          break;\n        }\n\n        state.distbits = 6;\n        //state.distcode.copy(state.codes);\n        // Switch to use dynamic table\n        state.distcode = state.distdyn;\n        opts = { bits: state.distbits };\n        ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.distbits = opts.bits;\n        // state.distcode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid distances set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, 'inflate:       codes ok\\n'));\n        state.mode = LEN_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case LEN_:\n        state.mode = LEN;\n        /* falls through */\n      case LEN:\n        if (have >= 6 && left >= 258) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          inffast(strm, _out);\n          //--- LOAD() ---\n          put = strm.next_out;\n          output = strm.output;\n          left = strm.avail_out;\n          next = strm.next_in;\n          input = strm.input;\n          have = strm.avail_in;\n          hold = state.hold;\n          bits = state.bits;\n          //---\n\n          if (state.mode === TYPE) {\n            state.back = -1;\n          }\n          break;\n        }\n        state.back = 0;\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if (here_bits <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_op && (here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.lencode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        state.length = here_val;\n        if (here_op === 0) {\n          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n          //        \"inflate:         literal '%c'\\n\" :\n          //        \"inflate:         literal 0x%02x\\n\", here.val));\n          state.mode = LIT;\n          break;\n        }\n        if (here_op & 32) {\n          //Tracevv((stderr, \"inflate:         end of block\\n\"));\n          state.back = -1;\n          state.mode = TYPE;\n          break;\n        }\n        if (here_op & 64) {\n          strm.msg = 'invalid literal/length code';\n          state.mode = BAD;\n          break;\n        }\n        state.extra = here_op & 15;\n        state.mode = LENEXT;\n        /* falls through */\n      case LENEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n        state.was = state.length;\n        state.mode = DIST;\n        /* falls through */\n      case DIST:\n        for (;;) {\n          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if ((here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.distcode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        if (here_op & 64) {\n          strm.msg = 'invalid distance code';\n          state.mode = BAD;\n          break;\n        }\n        state.offset = here_val;\n        state.extra = (here_op) & 15;\n        state.mode = DISTEXT;\n        /* falls through */\n      case DISTEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n//#ifdef INFLATE_STRICT\n        if (state.offset > state.dmax) {\n          strm.msg = 'invalid distance too far back';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n        state.mode = MATCH;\n        /* falls through */\n      case MATCH:\n        if (left === 0) { break inf_leave; }\n        copy = _out - left;\n        if (state.offset > copy) {         /* copy from window */\n          copy = state.offset - copy;\n          if (copy > state.whave) {\n            if (state.sane) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break;\n            }\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n          }\n          if (copy > state.wnext) {\n            copy -= state.wnext;\n            from = state.wsize - copy;\n          }\n          else {\n            from = state.wnext - copy;\n          }\n          if (copy > state.length) { copy = state.length; }\n          from_source = state.window;\n        }\n        else {                              /* copy from output */\n          from_source = output;\n          from = put - state.offset;\n          copy = state.length;\n        }\n        if (copy > left) { copy = left; }\n        left -= copy;\n        state.length -= copy;\n        do {\n          output[put++] = from_source[from++];\n        } while (--copy);\n        if (state.length === 0) { state.mode = LEN; }\n        break;\n      case LIT:\n        if (left === 0) { break inf_leave; }\n        output[put++] = state.length;\n        left--;\n        state.mode = LEN;\n        break;\n      case CHECK:\n        if (state.wrap) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            // Use '|' instead of '+' to make sure that result is signed\n            hold |= input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          _out -= left;\n          strm.total_out += _out;\n          state.total += _out;\n          if ((state.wrap & 4) && _out) {\n            strm.adler = state.check =\n                /*UPDATE_CHECK(state.check, put - _out, _out);*/\n                (state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));\n\n          }\n          _out = left;\n          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n          if ((state.wrap & 4) && (state.flags ? hold : zswap32(hold)) !== state.check) {\n            strm.msg = 'incorrect data check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n        }\n        state.mode = LENGTH;\n        /* falls through */\n      case LENGTH:\n        if (state.wrap && state.flags) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if ((state.wrap & 4) && hold !== (state.total & 0xffffffff)) {\n            strm.msg = 'incorrect length check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n        }\n        state.mode = DONE;\n        /* falls through */\n      case DONE:\n        ret = Z_STREAM_END$1;\n        break inf_leave;\n      case BAD:\n        ret = Z_DATA_ERROR$1;\n        break inf_leave;\n      case MEM:\n        return Z_MEM_ERROR$1;\n      case SYNC:\n        /* falls through */\n      default:\n        return Z_STREAM_ERROR$1;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH$1))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if ((state.wrap & 4) && _out) {\n    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH$1) && ret === Z_OK$1) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n};\n\n\nconst inflateEnd = (strm) => {\n\n  if (inflateStateCheck(strm)) {\n    return Z_STREAM_ERROR$1;\n  }\n\n  let state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK$1;\n};\n\n\nconst inflateGetHeader = (strm, head) => {\n\n  /* check state */\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  const state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR$1; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK$1;\n};\n\n\nconst inflateSetDictionary = (strm, dictionary) => {\n  const dictLength = dictionary.length;\n\n  let state;\n  let dictid;\n  let ret;\n\n  /* check state */\n  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR$1;\n  }\n\n  /* check for correct dictionary identifier */\n  if (state.mode === DICT) {\n    dictid = 1; /* adler32(0, null, 0)*/\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n    dictid = adler32_1(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR$1;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR$1;\n  }\n  state.havedict = 1;\n  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n  return Z_OK$1;\n};\n\n\nvar inflateReset_1 = inflateReset;\nvar inflateReset2_1 = inflateReset2;\nvar inflateResetKeep_1 = inflateResetKeep;\nvar inflateInit_1 = inflateInit;\nvar inflateInit2_1 = inflateInit2;\nvar inflate_2$1 = inflate$2;\nvar inflateEnd_1 = inflateEnd;\nvar inflateGetHeader_1 = inflateGetHeader;\nvar inflateSetDictionary_1 = inflateSetDictionary;\nvar inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nmodule.exports.inflateCodesUsed = inflateCodesUsed;\nmodule.exports.inflateCopy = inflateCopy;\nmodule.exports.inflateGetDictionary = inflateGetDictionary;\nmodule.exports.inflateMark = inflateMark;\nmodule.exports.inflatePrime = inflatePrime;\nmodule.exports.inflateSync = inflateSync;\nmodule.exports.inflateSyncPoint = inflateSyncPoint;\nmodule.exports.inflateUndermine = inflateUndermine;\nmodule.exports.inflateValidate = inflateValidate;\n*/\n\nvar inflate_1$2 = {\n\tinflateReset: inflateReset_1,\n\tinflateReset2: inflateReset2_1,\n\tinflateResetKeep: inflateResetKeep_1,\n\tinflateInit: inflateInit_1,\n\tinflateInit2: inflateInit2_1,\n\tinflate: inflate_2$1,\n\tinflateEnd: inflateEnd_1,\n\tinflateGetHeader: inflateGetHeader_1,\n\tinflateSetDictionary: inflateSetDictionary_1,\n\tinflateInfo: inflateInfo\n};\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text       = 0;\n  /* modification time */\n  this.time       = 0;\n  /* extra flags (not used when writing a gzip file) */\n  this.xflags     = 0;\n  /* operating system */\n  this.os         = 0;\n  /* pointer to extra field or Z_NULL if none */\n  this.extra      = null;\n  /* extra field length (valid if extra != Z_NULL) */\n  this.extra_len  = 0; // Actually, we don't need it in JS,\n                       // but leave for few code modifications\n\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n  /* pointer to zero-terminated file name or Z_NULL */\n  this.name       = '';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n  /* pointer to zero-terminated comment or Z_NULL */\n  this.comment    = '';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n  /* true if there was or will be a header crc */\n  this.hcrc       = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n  this.done       = false;\n}\n\nvar gzheader = GZheader;\n\nconst toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nconst {\n  Z_NO_FLUSH, Z_FINISH,\n  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR\n} = constants$2;\n\n/* ===========================================================================*/\n\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako')\n * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * const inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nfunction Inflate$1(options) {\n  this.options = common.assign({\n    chunkSize: 1024 * 64,\n    windowBits: 15,\n    to: ''\n  }, options || {});\n\n  const opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new zstream();\n  this.strm.avail_out = 0;\n\n  let status  = inflate_1$2.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(messages[status]);\n  }\n\n  this.header = new gzheader();\n\n  inflate_1$2.inflateGetHeader(this.strm, this.header);\n\n  // Setup dictionary\n  if (opt.dictionary) {\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      opt.dictionary = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      opt.dictionary = new Uint8Array(opt.dictionary);\n    }\n    if (opt.raw) { //In raw mode we need to set the dictionary early\n      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);\n      if (status !== Z_OK) {\n        throw new Error(messages[status]);\n      }\n    }\n  }\n}\n\n/**\n * Inflate#push(data[, flush_mode]) -> Boolean\n * - data (Uint8Array|ArrayBuffer): input data\n * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE\n *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,\n *   `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. If end of stream detected,\n * [[Inflate#onEnd]] will be called.\n *\n * `flush_mode` is not needed for normal operation, because end of stream\n * detected automatically. You may try to use it for advanced things, but\n * this functionality was not tested.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate$1.prototype.push = function (data, flush_mode) {\n  const strm = this.strm;\n  const chunkSize = this.options.chunkSize;\n  const dictionary = this.options.dictionary;\n  let status, _flush_mode, last_avail_out;\n\n  if (this.ended) return false;\n\n  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;\n  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;\n\n  // Convert data if needed\n  if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  for (;;) {\n    if (strm.avail_out === 0) {\n      strm.output = new Uint8Array(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = inflate_1$2.inflate(strm, _flush_mode);\n\n    if (status === Z_NEED_DICT && dictionary) {\n      status = inflate_1$2.inflateSetDictionary(strm, dictionary);\n\n      if (status === Z_OK) {\n        status = inflate_1$2.inflate(strm, _flush_mode);\n      } else if (status === Z_DATA_ERROR) {\n        // Replace code with more verbose\n        status = Z_NEED_DICT;\n      }\n    }\n\n    // Skip snyc markers if more data follows and not raw mode\n    while (strm.avail_in > 0 &&\n           status === Z_STREAM_END &&\n           strm.state.wrap > 0 &&\n           data[strm.next_in] !== 0)\n    {\n      inflate_1$2.inflateReset(strm);\n      status = inflate_1$2.inflate(strm, _flush_mode);\n    }\n\n    switch (status) {\n      case Z_STREAM_ERROR:\n      case Z_DATA_ERROR:\n      case Z_NEED_DICT:\n      case Z_MEM_ERROR:\n        this.onEnd(status);\n        this.ended = true;\n        return false;\n    }\n\n    // Remember real `avail_out` value, because we may patch out buffer content\n    // to align utf8 strings boundaries.\n    last_avail_out = strm.avail_out;\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === Z_STREAM_END) {\n\n        if (this.options.to === 'string') {\n\n          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          let tail = strm.next_out - next_out_utf8;\n          let utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail & realign counters\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));\n        }\n      }\n    }\n\n    // Must repeat iteration if out buffer is full\n    if (status === Z_OK && last_avail_out === 0) continue;\n\n    // Finalize if end of stream reached.\n    if (status === Z_STREAM_END) {\n      status = inflate_1$2.inflateEnd(this.strm);\n      this.onEnd(status);\n      this.ended = true;\n      return true;\n    }\n\n    if (strm.avail_in === 0) break;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|String): output data. When string output requested,\n *   each chunk will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate$1.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH). By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate$1.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = common.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|String\n * - data (Uint8Array|ArrayBuffer): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * const pako = require('pako');\n * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));\n * let output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err) {\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate$1(input, options) {\n  const inflator = new Inflate$1(options);\n\n  inflator.push(input);\n\n  // That will never happens, if you don't cheat with options :)\n  if (inflator.err) throw inflator.msg || messages[inflator.err];\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|String\n * - data (Uint8Array|ArrayBuffer): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw$1(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate$1(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|String\n * - data (Uint8Array|ArrayBuffer): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nvar Inflate_1$1 = Inflate$1;\nvar inflate_2 = inflate$1;\nvar inflateRaw_1$1 = inflateRaw$1;\nvar ungzip$1 = inflate$1;\nvar constants = constants$2;\n\nvar inflate_1$1 = {\n\tInflate: Inflate_1$1,\n\tinflate: inflate_2,\n\tinflateRaw: inflateRaw_1$1,\n\tungzip: ungzip$1,\n\tconstants: constants\n};\n\nconst { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;\n\nconst { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;\n\n\n\nvar Deflate_1 = Deflate;\nvar deflate_1 = deflate;\nvar deflateRaw_1 = deflateRaw;\nvar gzip_1 = gzip;\nvar Inflate_1 = Inflate;\nvar inflate_1 = inflate;\nvar inflateRaw_1 = inflateRaw;\nvar ungzip_1 = ungzip;\nvar constants_1 = constants$2;\n\nvar pako = {\n\tDeflate: Deflate_1,\n\tdeflate: deflate_1,\n\tdeflateRaw: deflateRaw_1,\n\tgzip: gzip_1,\n\tInflate: Inflate_1,\n\tinflate: inflate_1,\n\tinflateRaw: inflateRaw_1,\n\tungzip: ungzip_1,\n\tconstants: constants_1\n};\n\nexport { Deflate_1 as Deflate, Inflate_1 as Inflate, constants_1 as constants, pako as default, deflate_1 as deflate, deflateRaw_1 as deflateRaw, gzip_1 as gzip, inflate_1 as inflate, inflateRaw_1 as inflateRaw, ungzip_1 as ungzip };\n","const crcTable = [];\nfor (let n = 0; n < 256; n++) {\n    let c = n;\n    for (let k = 0; k < 8; k++) {\n        if (c & 1) {\n            c = 0xedb88320 ^ (c >>> 1);\n        }\n        else {\n            c = c >>> 1;\n        }\n    }\n    crcTable[n] = c;\n}\nconst initialCrc = 0xffffffff;\nfunction updateCrc(currentCrc, data, length) {\n    let c = currentCrc;\n    for (let n = 0; n < length; n++) {\n        c = crcTable[(c ^ data[n]) & 0xff] ^ (c >>> 8);\n    }\n    return c;\n}\nfunction crc(data, length) {\n    return (updateCrc(initialCrc, data, length) ^ initialCrc) >>> 0;\n}\nexport function checkCrc(buffer, crcLength, chunkName) {\n    const expectedCrc = buffer.readUint32();\n    const actualCrc = crc(new Uint8Array(buffer.buffer, buffer.byteOffset + buffer.offset - crcLength - 4, crcLength), crcLength); // \"- 4\" because we already advanced by reading the CRC\n    if (actualCrc !== expectedCrc) {\n        throw new Error(`CRC mismatch for chunk ${chunkName}. Expected ${expectedCrc}, found ${actualCrc}`);\n    }\n}\nexport function writeCrc(buffer, length) {\n    buffer.writeUint32(crc(new Uint8Array(buffer.buffer, buffer.byteOffset + buffer.offset - length, length), length));\n}\n//# sourceMappingURL=crc.js.map","export function unfilterNone(currentLine, newLine, bytesPerLine) {\n    for (let i = 0; i < bytesPerLine; i++) {\n        newLine[i] = currentLine[i];\n    }\n}\nexport function unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel) {\n    let i = 0;\n    for (; i < bytesPerPixel; i++) {\n        // just copy first bytes\n        newLine[i] = currentLine[i];\n    }\n    for (; i < bytesPerLine; i++) {\n        newLine[i] = (currentLine[i] + newLine[i - bytesPerPixel]) & 0xff;\n    }\n}\nexport function unfilterUp(currentLine, newLine, prevLine, bytesPerLine) {\n    let i = 0;\n    if (prevLine.length === 0) {\n        // just copy bytes for first line\n        for (; i < bytesPerLine; i++) {\n            newLine[i] = currentLine[i];\n        }\n    }\n    else {\n        for (; i < bytesPerLine; i++) {\n            newLine[i] = (currentLine[i] + prevLine[i]) & 0xff;\n        }\n    }\n}\nexport function unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {\n    let i = 0;\n    if (prevLine.length === 0) {\n        for (; i < bytesPerPixel; i++) {\n            newLine[i] = currentLine[i];\n        }\n        for (; i < bytesPerLine; i++) {\n            newLine[i] = (currentLine[i] + (newLine[i - bytesPerPixel] >> 1)) & 0xff;\n        }\n    }\n    else {\n        for (; i < bytesPerPixel; i++) {\n            newLine[i] = (currentLine[i] + (prevLine[i] >> 1)) & 0xff;\n        }\n        for (; i < bytesPerLine; i++) {\n            newLine[i] =\n                (currentLine[i] + ((newLine[i - bytesPerPixel] + prevLine[i]) >> 1)) &\n                    0xff;\n        }\n    }\n}\nexport function unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {\n    let i = 0;\n    if (prevLine.length === 0) {\n        for (; i < bytesPerPixel; i++) {\n            newLine[i] = currentLine[i];\n        }\n        for (; i < bytesPerLine; i++) {\n            newLine[i] = (currentLine[i] + newLine[i - bytesPerPixel]) & 0xff;\n        }\n    }\n    else {\n        for (; i < bytesPerPixel; i++) {\n            newLine[i] = (currentLine[i] + prevLine[i]) & 0xff;\n        }\n        for (; i < bytesPerLine; i++) {\n            newLine[i] =\n                (currentLine[i] +\n                    paethPredictor(newLine[i - bytesPerPixel], prevLine[i], prevLine[i - bytesPerPixel])) &\n                    0xff;\n        }\n    }\n}\nfunction paethPredictor(a, b, c) {\n    const p = a + b - c;\n    const pa = Math.abs(p - a);\n    const pb = Math.abs(p - b);\n    const pc = Math.abs(p - c);\n    if (pa <= pb && pa <= pc)\n        return a;\n    else if (pb <= pc)\n        return b;\n    else\n        return c;\n}\n//# sourceMappingURL=unfilter.js.map","import { unfilterAverage, unfilterNone, unfilterPaeth, unfilterSub, unfilterUp, } from \"./unfilter.js\";\n/**\n * Apllies filter on scanline based on the filter type.\n * @param filterType - The filter type to apply.\n * @param currentLine - The current line of pixel data.\n * @param newLine - The new line of pixel data.\n * @param prevLine - The previous line of pixel data.\n * @param passLineBytes - The number of bytes in the pass line.\n * @param bytesPerPixel - The number of bytes per pixel.\n */\nexport function applyUnfilter(filterType, currentLine, newLine, prevLine, passLineBytes, bytesPerPixel) {\n    switch (filterType) {\n        case 0:\n            unfilterNone(currentLine, newLine, passLineBytes);\n            break;\n        case 1:\n            unfilterSub(currentLine, newLine, passLineBytes, bytesPerPixel);\n            break;\n        case 2:\n            unfilterUp(currentLine, newLine, prevLine, passLineBytes);\n            break;\n        case 3:\n            unfilterAverage(currentLine, newLine, prevLine, passLineBytes, bytesPerPixel);\n            break;\n        case 4:\n            unfilterPaeth(currentLine, newLine, prevLine, passLineBytes, bytesPerPixel);\n            break;\n        default:\n            throw new Error(`Unsupported filter: ${filterType}`);\n    }\n}\n//# sourceMappingURL=apply_unfilter.js.map","import { applyUnfilter } from \"./apply_unfilter.js\";\nconst uint16 = new Uint16Array([0x00ff]);\nconst uint8 = new Uint8Array(uint16.buffer);\nconst osIsLittleEndian = uint8[0] === 0xff;\n/**\n * Decodes the Adam7 interlaced PNG data.\n * @param params - DecodeInterlaceNullParams\n * @returns - array of pixel data.\n */\nexport function decodeInterlaceAdam7(params) {\n    const { data, width, height, channels, depth } = params;\n    // Adam7 interlacing pattern\n    const passes = [\n        { x: 0, y: 0, xStep: 8, yStep: 8 }, // Pass 1\n        { x: 4, y: 0, xStep: 8, yStep: 8 }, // Pass 2\n        { x: 0, y: 4, xStep: 4, yStep: 8 }, // Pass 3\n        { x: 2, y: 0, xStep: 4, yStep: 4 }, // Pass 4\n        { x: 0, y: 2, xStep: 2, yStep: 4 }, // Pass 5\n        { x: 1, y: 0, xStep: 2, yStep: 2 }, // Pass 6\n        { x: 0, y: 1, xStep: 1, yStep: 2 }, // Pass 7\n    ];\n    const bytesPerPixel = Math.ceil(depth / 8) * channels;\n    const resultData = new Uint8Array(height * width * bytesPerPixel);\n    let offset = 0;\n    // Process each pass\n    for (let passIndex = 0; passIndex < 7; passIndex++) {\n        const pass = passes[passIndex];\n        // Calculate pass dimensions\n        const passWidth = Math.ceil((width - pass.x) / pass.xStep);\n        const passHeight = Math.ceil((height - pass.y) / pass.yStep);\n        if (passWidth <= 0 || passHeight <= 0)\n            continue;\n        const passLineBytes = passWidth * bytesPerPixel;\n        const prevLine = new Uint8Array(passLineBytes);\n        // Process each scanline in this pass\n        for (let y = 0; y < passHeight; y++) {\n            // First byte is the filter type\n            const filterType = data[offset++];\n            const currentLine = data.subarray(offset, offset + passLineBytes);\n            offset += passLineBytes;\n            // Create a new line for the unfiltered data\n            const newLine = new Uint8Array(passLineBytes);\n            // Apply the appropriate unfilter\n            applyUnfilter(filterType, currentLine, newLine, prevLine, passLineBytes, bytesPerPixel);\n            prevLine.set(newLine);\n            for (let x = 0; x < passWidth; x++) {\n                const outputX = pass.x + x * pass.xStep;\n                const outputY = pass.y + y * pass.yStep;\n                if (outputX >= width || outputY >= height)\n                    continue;\n                for (let i = 0; i < bytesPerPixel; i++) {\n                    resultData[(outputY * width + outputX) * bytesPerPixel + i] =\n                        newLine[x * bytesPerPixel + i];\n                }\n            }\n        }\n    }\n    if (depth === 16) {\n        const uint16Data = new Uint16Array(resultData.buffer);\n        if (osIsLittleEndian) {\n            for (let k = 0; k < uint16Data.length; k++) {\n                // PNG is always big endian. Swap the bytes.\n                uint16Data[k] = swap16(uint16Data[k]);\n            }\n        }\n        return uint16Data;\n    }\n    else {\n        return resultData;\n    }\n}\nfunction swap16(val) {\n    return ((val & 0xff) << 8) | ((val >> 8) & 0xff);\n}\n//# sourceMappingURL=decode_interlace_adam7.js.map","import { unfilterAverage, unfilterNone, unfilterPaeth, unfilterSub, unfilterUp, } from \"./unfilter.js\";\nconst uint16 = new Uint16Array([0x00ff]);\nconst uint8 = new Uint8Array(uint16.buffer);\nconst osIsLittleEndian = uint8[0] === 0xff;\nconst empty = new Uint8Array(0);\nexport function decodeInterlaceNull(params) {\n    const { data, width, height, channels, depth } = params;\n    const bytesPerPixel = Math.ceil(depth / 8) * channels;\n    const bytesPerLine = Math.ceil((depth / 8) * channels * width);\n    const newData = new Uint8Array(height * bytesPerLine);\n    let prevLine = empty;\n    let offset = 0;\n    let currentLine;\n    let newLine;\n    for (let i = 0; i < height; i++) {\n        currentLine = data.subarray(offset + 1, offset + 1 + bytesPerLine);\n        newLine = newData.subarray(i * bytesPerLine, (i + 1) * bytesPerLine);\n        switch (data[offset]) {\n            case 0:\n                unfilterNone(currentLine, newLine, bytesPerLine);\n                break;\n            case 1:\n                unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel);\n                break;\n            case 2:\n                unfilterUp(currentLine, newLine, prevLine, bytesPerLine);\n                break;\n            case 3:\n                unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);\n                break;\n            case 4:\n                unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);\n                break;\n            default:\n                throw new Error(`Unsupported filter: ${data[offset]}`);\n        }\n        prevLine = newLine;\n        offset += bytesPerLine + 1;\n    }\n    if (depth === 16) {\n        const uint16Data = new Uint16Array(newData.buffer);\n        if (osIsLittleEndian) {\n            for (let k = 0; k < uint16Data.length; k++) {\n                // PNG is always big endian. Swap the bytes.\n                uint16Data[k] = swap16(uint16Data[k]);\n            }\n        }\n        return uint16Data;\n    }\n    else {\n        return newData;\n    }\n}\nfunction swap16(val) {\n    return ((val & 0xff) << 8) | ((val >> 8) & 0xff);\n}\n//# sourceMappingURL=decode_interlace_null.js.map","// https://www.w3.org/TR/PNG/#5PNG-file-signature\nconst pngSignature = Uint8Array.of(137, 80, 78, 71, 13, 10, 26, 10);\nexport function writeSignature(buffer) {\n    buffer.writeBytes(pngSignature);\n}\nexport function checkSignature(buffer) {\n    if (!hasPngSignature(buffer.readBytes(pngSignature.length))) {\n        throw new Error('wrong PNG signature');\n    }\n}\nexport function hasPngSignature(array) {\n    if (array.length < pngSignature.length) {\n        return false;\n    }\n    for (let i = 0; i < pngSignature.length; i++) {\n        if (array[i] !== pngSignature[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n//# sourceMappingURL=signature.js.map","import { writeCrc } from \"./crc.js\";\n// https://www.w3.org/TR/png/#11tEXt\nexport const textChunkName = 'tEXt';\nconst NULL = 0;\nconst latin1Decoder = new TextDecoder('latin1');\nfunction validateKeyword(keyword) {\n    validateLatin1(keyword);\n    if (keyword.length === 0 || keyword.length > 79) {\n        throw new Error('keyword length must be between 1 and 79');\n    }\n}\n// eslint-disable-next-line no-control-regex\nconst latin1Regex = /^[\\u0000-\\u00FF]*$/;\nfunction validateLatin1(text) {\n    if (!latin1Regex.test(text)) {\n        throw new Error('invalid latin1 text');\n    }\n}\nexport function decodetEXt(text, buffer, length) {\n    const keyword = readKeyword(buffer);\n    text[keyword] = readLatin1(buffer, length - keyword.length - 1);\n}\nexport function encodetEXt(buffer, keyword, text) {\n    validateKeyword(keyword);\n    validateLatin1(text);\n    const length = keyword.length + 1 /* NULL */ + text.length;\n    buffer.writeUint32(length);\n    buffer.writeChars(textChunkName);\n    buffer.writeChars(keyword);\n    buffer.writeByte(NULL);\n    buffer.writeChars(text);\n    writeCrc(buffer, length + 4);\n}\n// https://www.w3.org/TR/png/#11keywords\nexport function readKeyword(buffer) {\n    buffer.mark();\n    while (buffer.readByte() !== NULL) {\n        /* advance */\n    }\n    const end = buffer.offset;\n    buffer.reset();\n    const keyword = latin1Decoder.decode(buffer.readBytes(end - buffer.offset - 1));\n    // NULL\n    buffer.skip(1);\n    validateKeyword(keyword);\n    return keyword;\n}\nexport function readLatin1(buffer, length) {\n    return latin1Decoder.decode(buffer.readBytes(length));\n}\n//# sourceMappingURL=text.js.map","export const ColorType = {\n    UNKNOWN: -1,\n    GREYSCALE: 0,\n    TRUECOLOUR: 2,\n    INDEXED_COLOUR: 3,\n    GREYSCALE_ALPHA: 4,\n    TRUECOLOUR_ALPHA: 6,\n};\nexport const CompressionMethod = {\n    UNKNOWN: -1,\n    DEFLATE: 0,\n};\nexport const FilterMethod = {\n    UNKNOWN: -1,\n    ADAPTIVE: 0,\n};\nexport const InterlaceMethod = {\n    UNKNOWN: -1,\n    NO_INTERLACE: 0,\n    ADAM7: 1,\n};\nexport const DisposeOpType = {\n    NONE: 0,\n    BACKGROUND: 1,\n    PREVIOUS: 2,\n};\nexport const BlendOpType = {\n    SOURCE: 0,\n    OVER: 1,\n};\n//# sourceMappingURL=internal_types.js.map","import { IOBuffer } from 'iobuffer';\nimport { Inflate as Inflator, inflate } from 'pako';\nimport { checkCrc } from \"./helpers/crc.js\";\nimport { decodeInterlaceAdam7 } from \"./helpers/decode_interlace_adam7.js\";\nimport { decodeInterlaceNull } from \"./helpers/decode_interlace_null.js\";\nimport { checkSignature } from \"./helpers/signature.js\";\nimport { decodetEXt, readKeyword, textChunkName } from \"./helpers/text.js\";\nimport { BlendOpType, ColorType, CompressionMethod, DisposeOpType, FilterMethod, InterlaceMethod, } from \"./internal_types.js\";\nexport default class PngDecoder extends IOBuffer {\n    _checkCrc;\n    _inflator;\n    _png;\n    _apng;\n    _end;\n    _hasPalette;\n    _palette;\n    _hasTransparency;\n    _transparency;\n    _compressionMethod;\n    _filterMethod;\n    _interlaceMethod;\n    _colorType;\n    _isAnimated;\n    _numberOfFrames;\n    _numberOfPlays;\n    _frames;\n    _writingDataChunks;\n    constructor(data, options = {}) {\n        super(data);\n        const { checkCrc = false } = options;\n        this._checkCrc = checkCrc;\n        this._inflator = new Inflator();\n        this._png = {\n            width: -1,\n            height: -1,\n            channels: -1,\n            data: new Uint8Array(0),\n            depth: 1,\n            text: {},\n        };\n        this._apng = {\n            width: -1,\n            height: -1,\n            channels: -1,\n            depth: 1,\n            numberOfFrames: 1,\n            numberOfPlays: 0,\n            text: {},\n            frames: [],\n        };\n        this._end = false;\n        this._hasPalette = false;\n        this._palette = [];\n        this._hasTransparency = false;\n        this._transparency = new Uint16Array(0);\n        this._compressionMethod = CompressionMethod.UNKNOWN;\n        this._filterMethod = FilterMethod.UNKNOWN;\n        this._interlaceMethod = InterlaceMethod.UNKNOWN;\n        this._colorType = ColorType.UNKNOWN;\n        this._isAnimated = false;\n        this._numberOfFrames = 1;\n        this._numberOfPlays = 0;\n        this._frames = [];\n        this._writingDataChunks = false;\n        // PNG is always big endian\n        // https://www.w3.org/TR/PNG/#7Integers-and-byte-order\n        this.setBigEndian();\n    }\n    decode() {\n        checkSignature(this);\n        while (!this._end) {\n            const length = this.readUint32();\n            const type = this.readChars(4);\n            this.decodeChunk(length, type);\n        }\n        this.decodeImage();\n        return this._png;\n    }\n    decodeApng() {\n        checkSignature(this);\n        while (!this._end) {\n            const length = this.readUint32();\n            const type = this.readChars(4);\n            this.decodeApngChunk(length, type);\n        }\n        this.decodeApngImage();\n        return this._apng;\n    }\n    // https://www.w3.org/TR/PNG/#5Chunk-layout\n    decodeChunk(length, type) {\n        const offset = this.offset;\n        switch (type) {\n            // 11.2 Critical chunks\n            case 'IHDR': // 11.2.2 IHDR Image header\n                this.decodeIHDR();\n                break;\n            case 'PLTE': // 11.2.3 PLTE Palette\n                this.decodePLTE(length);\n                break;\n            case 'IDAT': // 11.2.4 IDAT Image data\n                this.decodeIDAT(length);\n                break;\n            case 'IEND': // 11.2.5 IEND Image trailer\n                this._end = true;\n                break;\n            // 11.3 Ancillary chunks\n            case 'tRNS': // 11.3.2.1 tRNS Transparency\n                this.decodetRNS(length);\n                break;\n            case 'iCCP': // 11.3.3.3 iCCP Embedded ICC profile\n                this.decodeiCCP(length);\n                break;\n            case textChunkName: // 11.3.4.3 tEXt Textual data\n                decodetEXt(this._png.text, this, length);\n                break;\n            case 'pHYs': // 11.3.5.3 pHYs Physical pixel dimensions\n                this.decodepHYs();\n                break;\n            default:\n                this.skip(length);\n                break;\n        }\n        if (this.offset - offset !== length) {\n            throw new Error(`Length mismatch while decoding chunk ${type}`);\n        }\n        if (this._checkCrc) {\n            checkCrc(this, length + 4, type);\n        }\n        else {\n            this.skip(4);\n        }\n    }\n    decodeApngChunk(length, type) {\n        const offset = this.offset;\n        if (type !== 'fdAT' && type !== 'IDAT' && this._writingDataChunks) {\n            this.pushDataToFrame();\n        }\n        switch (type) {\n            case 'acTL':\n                this.decodeACTL();\n                break;\n            case 'fcTL':\n                this.decodeFCTL();\n                break;\n            case 'fdAT':\n                this.decodeFDAT(length);\n                break;\n            default:\n                this.decodeChunk(length, type);\n                this.offset = offset + length;\n                break;\n        }\n        if (this.offset - offset !== length) {\n            throw new Error(`Length mismatch while decoding chunk ${type}`);\n        }\n        if (this._checkCrc) {\n            checkCrc(this, length + 4, type);\n        }\n        else {\n            this.skip(4);\n        }\n    }\n    // https://www.w3.org/TR/PNG/#11IHDR\n    decodeIHDR() {\n        const image = this._png;\n        image.width = this.readUint32();\n        image.height = this.readUint32();\n        image.depth = checkBitDepth(this.readUint8());\n        const colorType = this.readUint8();\n        this._colorType = colorType;\n        let channels;\n        switch (colorType) {\n            case ColorType.GREYSCALE:\n                channels = 1;\n                break;\n            case ColorType.TRUECOLOUR:\n                channels = 3;\n                break;\n            case ColorType.INDEXED_COLOUR:\n                channels = 1;\n                break;\n            case ColorType.GREYSCALE_ALPHA:\n                channels = 2;\n                break;\n            case ColorType.TRUECOLOUR_ALPHA:\n                channels = 4;\n                break;\n            // Kept for exhaustiveness.\n            // eslint-disable-next-line unicorn/no-useless-switch-case\n            case ColorType.UNKNOWN:\n            default:\n                throw new Error(`Unknown color type: ${colorType}`);\n        }\n        this._png.channels = channels;\n        this._compressionMethod = this.readUint8();\n        if (this._compressionMethod !== CompressionMethod.DEFLATE) {\n            throw new Error(`Unsupported compression method: ${this._compressionMethod}`);\n        }\n        this._filterMethod = this.readUint8();\n        this._interlaceMethod = this.readUint8();\n    }\n    decodeACTL() {\n        this._numberOfFrames = this.readUint32();\n        this._numberOfPlays = this.readUint32();\n        this._isAnimated = true;\n    }\n    decodeFCTL() {\n        const image = {\n            sequenceNumber: this.readUint32(),\n            width: this.readUint32(),\n            height: this.readUint32(),\n            xOffset: this.readUint32(),\n            yOffset: this.readUint32(),\n            delayNumber: this.readUint16(),\n            delayDenominator: this.readUint16(),\n            disposeOp: this.readUint8(),\n            blendOp: this.readUint8(),\n            data: new Uint8Array(0),\n        };\n        this._frames.push(image);\n    }\n    // https://www.w3.org/TR/PNG/#11PLTE\n    decodePLTE(length) {\n        if (length % 3 !== 0) {\n            throw new RangeError(`PLTE field length must be a multiple of 3. Got ${length}`);\n        }\n        const l = length / 3;\n        this._hasPalette = true;\n        const palette = [];\n        this._palette = palette;\n        for (let i = 0; i < l; i++) {\n            palette.push([this.readUint8(), this.readUint8(), this.readUint8()]);\n        }\n    }\n    // https://www.w3.org/TR/PNG/#11IDAT\n    decodeIDAT(length) {\n        this._writingDataChunks = true;\n        const dataLength = length;\n        const dataOffset = this.offset + this.byteOffset;\n        this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));\n        if (this._inflator.err) {\n            throw new Error(`Error while decompressing the data: ${this._inflator.err}`);\n        }\n        this.skip(length);\n    }\n    decodeFDAT(length) {\n        this._writingDataChunks = true;\n        let dataLength = length;\n        let dataOffset = this.offset + this.byteOffset;\n        dataOffset += 4;\n        dataLength -= 4;\n        this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));\n        if (this._inflator.err) {\n            throw new Error(`Error while decompressing the data: ${this._inflator.err}`);\n        }\n        this.skip(length);\n    }\n    // https://www.w3.org/TR/PNG/#11tRNS\n    decodetRNS(length) {\n        switch (this._colorType) {\n            case ColorType.GREYSCALE:\n            case ColorType.TRUECOLOUR: {\n                if (length % 2 !== 0) {\n                    throw new RangeError(`tRNS chunk length must be a multiple of 2. Got ${length}`);\n                }\n                if (length / 2 > this._png.width * this._png.height) {\n                    throw new Error(`tRNS chunk contains more alpha values than there are pixels (${length / 2} vs ${this._png.width * this._png.height})`);\n                }\n                this._hasTransparency = true;\n                this._transparency = new Uint16Array(length / 2);\n                for (let i = 0; i < length / 2; i++) {\n                    this._transparency[i] = this.readUint16();\n                }\n                break;\n            }\n            case ColorType.INDEXED_COLOUR: {\n                if (length > this._palette.length) {\n                    throw new Error(`tRNS chunk contains more alpha values than there are palette colors (${length} vs ${this._palette.length})`);\n                }\n                let i = 0;\n                for (; i < length; i++) {\n                    const alpha = this.readByte();\n                    this._palette[i].push(alpha);\n                }\n                for (; i < this._palette.length; i++) {\n                    this._palette[i].push(255);\n                }\n                break;\n            }\n            // Kept for exhaustiveness.\n            /* eslint-disable unicorn/no-useless-switch-case */\n            case ColorType.UNKNOWN:\n            case ColorType.GREYSCALE_ALPHA:\n            case ColorType.TRUECOLOUR_ALPHA:\n            default: {\n                throw new Error(`tRNS chunk is not supported for color type ${this._colorType}`);\n            }\n            /* eslint-enable unicorn/no-useless-switch-case */\n        }\n    }\n    // https://www.w3.org/TR/PNG/#11iCCP\n    decodeiCCP(length) {\n        const name = readKeyword(this);\n        const compressionMethod = this.readUint8();\n        if (compressionMethod !== CompressionMethod.DEFLATE) {\n            throw new Error(`Unsupported iCCP compression method: ${compressionMethod}`);\n        }\n        const compressedProfile = this.readBytes(length - name.length - 2);\n        this._png.iccEmbeddedProfile = {\n            name,\n            profile: inflate(compressedProfile),\n        };\n    }\n    // https://www.w3.org/TR/PNG/#11pHYs\n    decodepHYs() {\n        const ppuX = this.readUint32();\n        const ppuY = this.readUint32();\n        const unitSpecifier = this.readByte();\n        this._png.resolution = {\n            x: ppuX,\n            y: ppuY,\n            unit: unitSpecifier,\n        };\n    }\n    decodeApngImage() {\n        this._apng.width = this._png.width;\n        this._apng.height = this._png.height;\n        this._apng.channels = this._png.channels;\n        this._apng.depth = this._png.depth;\n        this._apng.numberOfFrames = this._numberOfFrames;\n        this._apng.numberOfPlays = this._numberOfPlays;\n        this._apng.text = this._png.text;\n        this._apng.resolution = this._png.resolution;\n        for (let i = 0; i < this._numberOfFrames; i++) {\n            const newFrame = {\n                sequenceNumber: this._frames[i].sequenceNumber,\n                delayNumber: this._frames[i].delayNumber,\n                delayDenominator: this._frames[i].delayDenominator,\n                data: this._apng.depth === 8\n                    ? new Uint8Array(this._apng.width * this._apng.height * this._apng.channels)\n                    : new Uint16Array(this._apng.width * this._apng.height * this._apng.channels),\n            };\n            const frame = this._frames.at(i);\n            if (frame) {\n                frame.data = decodeInterlaceNull({\n                    data: frame.data,\n                    width: frame.width,\n                    height: frame.height,\n                    channels: this._apng.channels,\n                    depth: this._apng.depth,\n                });\n                if (this._hasPalette) {\n                    this._apng.palette = this._palette;\n                }\n                if (this._hasTransparency) {\n                    this._apng.transparency = this._transparency;\n                }\n                if (i === 0 ||\n                    (frame.xOffset === 0 &&\n                        frame.yOffset === 0 &&\n                        frame.width === this._png.width &&\n                        frame.height === this._png.height)) {\n                    newFrame.data = frame.data;\n                }\n                else {\n                    const prevFrame = this._apng.frames.at(i - 1);\n                    this.disposeFrame(frame, prevFrame, newFrame);\n                    this.addFrameDataToCanvas(newFrame, frame);\n                }\n                this._apng.frames.push(newFrame);\n            }\n        }\n        return this._apng;\n    }\n    disposeFrame(frame, prevFrame, imageFrame) {\n        switch (frame.disposeOp) {\n            case DisposeOpType.NONE:\n                break;\n            case DisposeOpType.BACKGROUND:\n                for (let row = 0; row < this._png.height; row++) {\n                    for (let col = 0; col < this._png.width; col++) {\n                        const index = (row * frame.width + col) * this._png.channels;\n                        for (let channel = 0; channel < this._png.channels; channel++) {\n                            imageFrame.data[index + channel] = 0;\n                        }\n                    }\n                }\n                break;\n            case DisposeOpType.PREVIOUS:\n                imageFrame.data.set(prevFrame.data);\n                break;\n            default:\n                throw new Error('Unknown disposeOp');\n        }\n    }\n    addFrameDataToCanvas(imageFrame, frame) {\n        const maxValue = 1 << this._png.depth;\n        const calculatePixelIndices = (row, col) => {\n            const index = ((row + frame.yOffset) * this._png.width + frame.xOffset + col) *\n                this._png.channels;\n            const frameIndex = (row * frame.width + col) * this._png.channels;\n            return { index, frameIndex };\n        };\n        switch (frame.blendOp) {\n            case BlendOpType.SOURCE:\n                for (let row = 0; row < frame.height; row++) {\n                    for (let col = 0; col < frame.width; col++) {\n                        const { index, frameIndex } = calculatePixelIndices(row, col);\n                        for (let channel = 0; channel < this._png.channels; channel++) {\n                            imageFrame.data[index + channel] =\n                                frame.data[frameIndex + channel];\n                        }\n                    }\n                }\n                break;\n            // https://www.w3.org/TR/png-3/#13Alpha-channel-processing\n            case BlendOpType.OVER:\n                for (let row = 0; row < frame.height; row++) {\n                    for (let col = 0; col < frame.width; col++) {\n                        const { index, frameIndex } = calculatePixelIndices(row, col);\n                        for (let channel = 0; channel < this._png.channels; channel++) {\n                            const sourceAlpha = frame.data[frameIndex + this._png.channels - 1] / maxValue;\n                            const foregroundValue = channel % (this._png.channels - 1) === 0\n                                ? 1\n                                : frame.data[frameIndex + channel];\n                            const value = Math.floor(sourceAlpha * foregroundValue +\n                                (1 - sourceAlpha) * imageFrame.data[index + channel]);\n                            imageFrame.data[index + channel] += value;\n                        }\n                    }\n                }\n                break;\n            default:\n                throw new Error('Unknown blendOp');\n        }\n    }\n    decodeImage() {\n        if (this._inflator.err) {\n            throw new Error(`Error while decompressing the data: ${this._inflator.err}`);\n        }\n        const data = this._isAnimated\n            ? (this._frames?.at(0)).data\n            : this._inflator.result;\n        if (this._filterMethod !== FilterMethod.ADAPTIVE) {\n            throw new Error(`Filter method ${this._filterMethod} not supported`);\n        }\n        if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {\n            this._png.data = decodeInterlaceNull({\n                data: data,\n                width: this._png.width,\n                height: this._png.height,\n                channels: this._png.channels,\n                depth: this._png.depth,\n            });\n        }\n        else if (this._interlaceMethod === InterlaceMethod.ADAM7) {\n            this._png.data = decodeInterlaceAdam7({\n                data: data,\n                width: this._png.width,\n                height: this._png.height,\n                channels: this._png.channels,\n                depth: this._png.depth,\n            });\n        }\n        else {\n            throw new Error(`Interlace method ${this._interlaceMethod} not supported`);\n        }\n        if (this._hasPalette) {\n            this._png.palette = this._palette;\n        }\n        if (this._hasTransparency) {\n            this._png.transparency = this._transparency;\n        }\n    }\n    pushDataToFrame() {\n        const result = this._inflator.result;\n        const lastFrame = this._frames.at(-1);\n        if (lastFrame) {\n            lastFrame.data = result;\n        }\n        else {\n            this._frames.push({\n                sequenceNumber: 0,\n                width: this._png.width,\n                height: this._png.height,\n                xOffset: 0,\n                yOffset: 0,\n                delayNumber: 0,\n                delayDenominator: 0,\n                disposeOp: DisposeOpType.NONE,\n                blendOp: BlendOpType.SOURCE,\n                data: result,\n            });\n        }\n        this._inflator = new Inflator();\n        this._writingDataChunks = false;\n    }\n}\nfunction checkBitDepth(value) {\n    if (value !== 1 &&\n        value !== 2 &&\n        value !== 4 &&\n        value !== 8 &&\n        value !== 16) {\n        throw new Error(`invalid bit depth: ${value}`);\n    }\n    return value;\n}\n//# sourceMappingURL=png_decoder.js.map","import { IOBuffer } from 'iobuffer';\nimport { deflate } from 'pako';\nimport { writeCrc } from \"./helpers/crc.js\";\nimport { writeSignature } from \"./helpers/signature.js\";\nimport { encodetEXt } from \"./helpers/text.js\";\nimport { ColorType, CompressionMethod, FilterMethod, InterlaceMethod, } from \"./internal_types.js\";\nconst defaultZlibOptions = {\n    level: 3,\n};\nexport default class PngEncoder extends IOBuffer {\n    _png;\n    _zlibOptions;\n    _colorType;\n    _interlaceMethod;\n    constructor(data, options = {}) {\n        super();\n        this._colorType = ColorType.UNKNOWN;\n        this._zlibOptions = { ...defaultZlibOptions, ...options.zlib };\n        this._png = this._checkData(data);\n        this._interlaceMethod =\n            (options.interlace === 'Adam7'\n                ? InterlaceMethod.ADAM7\n                : InterlaceMethod.NO_INTERLACE) ?? InterlaceMethod.NO_INTERLACE;\n        this.setBigEndian();\n    }\n    encode() {\n        writeSignature(this);\n        this.encodeIHDR();\n        if (this._png.palette) {\n            this.encodePLTE();\n            if (this._png.palette[0].length === 4) {\n                this.encodeTRNS();\n            }\n        }\n        this.encodeData();\n        if (this._png.text) {\n            for (const [keyword, text] of Object.entries(this._png.text)) {\n                encodetEXt(this, keyword, text);\n            }\n        }\n        this.encodeIEND();\n        return this.toArray();\n    }\n    // https://www.w3.org/TR/PNG/#11IHDR\n    encodeIHDR() {\n        this.writeUint32(13);\n        this.writeChars('IHDR');\n        this.writeUint32(this._png.width);\n        this.writeUint32(this._png.height);\n        this.writeByte(this._png.depth);\n        this.writeByte(this._colorType);\n        this.writeByte(CompressionMethod.DEFLATE);\n        this.writeByte(FilterMethod.ADAPTIVE);\n        this.writeByte(this._interlaceMethod);\n        writeCrc(this, 17);\n    }\n    // https://www.w3.org/TR/PNG/#11IEND\n    encodeIEND() {\n        this.writeUint32(0);\n        this.writeChars('IEND');\n        writeCrc(this, 4);\n    }\n    encodePLTE() {\n        const paletteLength = this._png.palette?.length * 3;\n        this.writeUint32(paletteLength);\n        this.writeChars('PLTE');\n        for (const color of this._png.palette) {\n            this.writeByte(color[0]);\n            this.writeByte(color[1]);\n            this.writeByte(color[2]);\n        }\n        writeCrc(this, 4 + paletteLength);\n    }\n    encodeTRNS() {\n        const alpha = this._png.palette.filter((color) => {\n            return color.at(-1) !== 255;\n        });\n        this.writeUint32(alpha.length);\n        this.writeChars('tRNS');\n        for (const el of alpha) {\n            this.writeByte(el.at(-1));\n        }\n        writeCrc(this, 4 + alpha.length);\n    }\n    // https://www.w3.org/TR/PNG/#11IDAT\n    encodeIDAT(data) {\n        this.writeUint32(data.length);\n        this.writeChars('IDAT');\n        this.writeBytes(data);\n        writeCrc(this, data.length + 4);\n    }\n    encodeData() {\n        const { width, height, channels, depth, data } = this._png;\n        const slotsPerLine = depth <= 8\n            ? Math.ceil((width * depth) / 8) * channels\n            : Math.ceil((((width * depth) / 8) * channels) / 2);\n        const newData = new IOBuffer().setBigEndian();\n        let offset = 0;\n        if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {\n            for (let i = 0; i < height; i++) {\n                newData.writeByte(0); // no filter\n                if (depth === 16) {\n                    offset = writeDataUint16(data, newData, slotsPerLine, offset);\n                }\n                else {\n                    offset = writeDataBytes(data, newData, slotsPerLine, offset);\n                }\n            }\n        }\n        else if (this._interlaceMethod === InterlaceMethod.ADAM7) {\n            // Adam7 interlacing\n            offset = writeDataInterlaced(this._png, data, newData, offset);\n        }\n        const buffer = newData.toArray();\n        const compressed = deflate(buffer, this._zlibOptions);\n        this.encodeIDAT(compressed);\n    }\n    _checkData(data) {\n        const { colorType, channels, depth } = getColorType(data, data.palette);\n        const png = {\n            width: checkInteger(data.width, 'width'),\n            height: checkInteger(data.height, 'height'),\n            channels,\n            data: data.data,\n            depth,\n            text: data.text,\n            palette: data.palette,\n        };\n        this._colorType = colorType;\n        const expectedSize = depth < 8\n            ? Math.ceil((png.width * depth) / 8) * png.height * channels\n            : png.width * png.height * channels;\n        if (png.data.length !== expectedSize) {\n            throw new RangeError(`wrong data size. Found ${png.data.length}, expected ${expectedSize}`);\n        }\n        return png;\n    }\n}\nfunction checkInteger(value, name) {\n    if (Number.isInteger(value) && value > 0) {\n        return value;\n    }\n    throw new TypeError(`${name} must be a positive integer`);\n}\nfunction getColorType(data, palette) {\n    const { channels = 4, depth = 8 } = data;\n    if (channels !== 4 && channels !== 3 && channels !== 2 && channels !== 1) {\n        throw new RangeError(`unsupported number of channels: ${channels}`);\n    }\n    const returnValue = {\n        channels,\n        depth,\n        colorType: ColorType.UNKNOWN,\n    };\n    switch (channels) {\n        case 4:\n            returnValue.colorType = ColorType.TRUECOLOUR_ALPHA;\n            break;\n        case 3:\n            returnValue.colorType = ColorType.TRUECOLOUR;\n            break;\n        case 1:\n            if (palette) {\n                returnValue.colorType = ColorType.INDEXED_COLOUR;\n            }\n            else {\n                returnValue.colorType = ColorType.GREYSCALE;\n            }\n            break;\n        case 2:\n            returnValue.colorType = ColorType.GREYSCALE_ALPHA;\n            break;\n        default:\n            throw new Error('unsupported number of channels');\n    }\n    return returnValue;\n}\nfunction writeDataBytes(data, newData, slotsPerLine, offset) {\n    for (let j = 0; j < slotsPerLine; j++) {\n        newData.writeByte(data[offset++]);\n    }\n    return offset;\n}\nfunction writeDataInterlaced(imageData, data, newData, offset) {\n    const passes = [\n        { x: 0, y: 0, xStep: 8, yStep: 8 },\n        { x: 4, y: 0, xStep: 8, yStep: 8 },\n        { x: 0, y: 4, xStep: 4, yStep: 8 },\n        { x: 2, y: 0, xStep: 4, yStep: 4 },\n        { x: 0, y: 2, xStep: 2, yStep: 4 },\n        { x: 1, y: 0, xStep: 2, yStep: 2 },\n        { x: 0, y: 1, xStep: 1, yStep: 2 },\n    ];\n    const { width, height, channels, depth } = imageData;\n    let pixelSize;\n    if (depth === 16) {\n        pixelSize = (channels * depth) / 8 / 2;\n    }\n    else {\n        pixelSize = (channels * depth) / 8;\n    }\n    // Process each pass\n    for (let passIndex = 0; passIndex < 7; passIndex++) {\n        const pass = passes[passIndex];\n        const passWidth = Math.floor((width - pass.x + pass.xStep - 1) / pass.xStep);\n        const passHeight = Math.floor((height - pass.y + pass.yStep - 1) / pass.yStep);\n        if (passWidth <= 0 || passHeight <= 0)\n            continue;\n        const passLineBytes = passWidth * pixelSize;\n        // For each scanline in this pass\n        for (let y = 0; y < passHeight; y++) {\n            const imageY = pass.y + y * pass.yStep;\n            // Extract raw scanline data\n            const rawScanline = depth <= 8\n                ? new Uint8Array(passLineBytes)\n                : new Uint16Array(passLineBytes);\n            let rawOffset = 0;\n            for (let x = 0; x < passWidth; x++) {\n                const imageX = pass.x + x * pass.xStep;\n                if (imageX < width && imageY < height) {\n                    const srcPos = (imageY * width + imageX) * pixelSize;\n                    for (let i = 0; i < pixelSize; i++) {\n                        rawScanline[rawOffset++] = data[srcPos + i];\n                    }\n                }\n            }\n            newData.writeByte(0); // no filter\n            if (depth === 8) {\n                newData.writeBytes(rawScanline);\n            }\n            else if (depth === 16) {\n                for (const value of rawScanline) {\n                    newData.writeByte((value >> 8) & 0xff); // High byte\n                    newData.writeByte(value & 0xff);\n                }\n            }\n        }\n    }\n    return offset;\n}\nfunction writeDataUint16(data, newData, slotsPerLine, offset) {\n    for (let j = 0; j < slotsPerLine; j++) {\n        newData.writeUint16(data[offset++]);\n    }\n    return offset;\n}\n//# sourceMappingURL=png_encoder.js.map","import PngDecoder from \"./png_decoder.js\";\nimport PngEncoder from \"./png_encoder.js\";\nexport { hasPngSignature } from \"./helpers/signature.js\";\nexport * from \"./types.js\";\nfunction decodePng(data, options) {\n    const decoder = new PngDecoder(data, options);\n    return decoder.decode();\n}\nfunction encodePng(png, options) {\n    const encoder = new PngEncoder(png, options);\n    return encoder.encode();\n}\nfunction decodeApng(data, options) {\n    const decoder = new PngDecoder(data, options);\n    return decoder.decodeApng();\n}\nexport { decodeApng, decodePng as decode, encodePng as encode };\nexport { convertIndexedToRgb } from \"./convert_indexed_to_rgb.js\";\n//# sourceMappingURL=index.js.map","import { encode } from 'fast-png';\nimport { Mask } from '../Mask.js';\n/**\n * Creates a PNG buffer from an image.\n * @param image - The image instance.\n * @param options - PNG encoding options.\n * @returns The buffer.\n */\nexport function encodePng(image, options) {\n    if ((image.colorModel !== 'RGB' &&\n        image.colorModel !== 'RGBA' &&\n        image.colorModel !== 'GREY' &&\n        image.colorModel !== 'GREYA') ||\n        image instanceof Mask) {\n        image = image.convertColor('GREY');\n    }\n    const { bitDepth: depth, ...other } = image.getRawImage();\n    return encode({\n        depth,\n        ...other,\n    }, options);\n}\n//# sourceMappingURL=encodePng.js.map","import { P, match } from 'ts-pattern';\nimport { encodeBmp } from './encodeBmp.js';\nimport { encodeJpeg } from './encodeJpeg.js';\nimport { encodePng } from './encodePng.js';\nexport const ImageFormat = {\n    PNG: 'png',\n    JPG: 'jpg',\n    JPEG: 'jpeg',\n    BMP: 'bmp',\n};\nexport const defaultPng = { format: 'png' };\n/**\n * Encodes the image to the specified format\n * @param image - Image to encode.\n * @param options - Format and options passed to the encoder.\n * @returns The encoded image.\n */\nexport function encode(image, options = defaultPng) {\n    return match(options)\n        .with({ format: 'png' }, (options) => encodePng(image, options.encoderOptions))\n        .with({ format: P.union('jpg', 'jpeg') }, (options) => encodeJpeg(image, options.encoderOptions))\n        .with({ format: 'bmp' }, () => encodeBmp(image))\n        .exhaustive();\n}\n//# sourceMappingURL=encode.js.map","/**\n * Returns builtin Node.js modules or throws an error saying that the method is only implemented in Node.js.\n * @param methodName - Name of the method that calls this function\n * @returns - The `fs`, `path` and `url` Node.js modules.\n */\nexport function getNodeApiOrThrow(methodName) {\n    if (!isNode()) {\n        throw new Error(`${methodName} is only implemented for Node.js`);\n    }\n    return {\n        fs: process.getBuiltinModule('node:fs'),\n        path: process.getBuiltinModule('node:path'),\n        url: process.getBuiltinModule('node:url'),\n    };\n}\nlet CanvasCtorBrowser;\nlet CanvasCtorNode;\n/**\n * Returns a 2D canvas context for rendering on the browser or Node.js.\n * @param width - Width of the canvas.\n * @param height - Height of the canvas.\n * @returns The initialised canvas context.\n */\nexport function getCanvasContext(width, height) {\n    if (isNode()) {\n        CanvasCtorNode ??= getRequireFn()('skia-canvas').Canvas;\n        return new CanvasCtorNode(width, height).getContext('2d');\n    }\n    else {\n        CanvasCtorBrowser ??= globalThis.OffscreenCanvas;\n        const context = new CanvasCtorBrowser(width, height).getContext('2d');\n        if (!context) {\n            throw new Error('Failed to create canvas context');\n        }\n        return context;\n    }\n}\nfunction isNode() {\n    return (typeof process !== 'undefined' &&\n        typeof process.getBuiltinModule === 'function');\n}\nlet requireFn;\nfunction getRequireFn() {\n    requireFn ??= process\n        .getBuiltinModule('node:module')\n        .createRequire(import.meta.url);\n    return requireFn;\n}\n//# sourceMappingURL=cross_platform.js.map","import { Mask } from '../Mask.js';\nimport { getNodeApiOrThrow } from '../utils/cross_platform.js';\nimport { encode } from './encode.js';\n/**\n * Asynchronously write an image to the disk.\n * This method is only implemented for Node.js.\n * @param path - Path where the image should be written.\n * @param image - Image to save.\n * @param options - Encode options.\n */\nexport async function write(path, image, options) {\n    const nodeApi = getNodeApiOrThrow('write');\n    if (typeof path !== 'string') {\n        path = nodeApi.url.fileURLToPath(path);\n    }\n    if (image instanceof Mask) {\n        image = image.convertColor('GREY');\n    }\n    const toWrite = getDataToWrite(path, image, options, nodeApi);\n    if (options?.recursive) {\n        const dir = nodeApi.path.dirname(path);\n        await nodeApi.fs.promises.mkdir(dir, { recursive: true });\n    }\n    await nodeApi.fs.promises.writeFile(path, toWrite);\n}\n/**\n * Synchronous version of {@link write}.\n * This method is only implemented for Node.js.\n * @param path - Path where the image should be written.\n * @param image - Image to save.\n * @param options - Encode options.\n */\nexport function writeSync(path, image, options) {\n    const nodeApi = getNodeApiOrThrow('writeSync');\n    if (typeof path !== 'string') {\n        path = nodeApi.url.fileURLToPath(path);\n    }\n    const toWrite = getDataToWrite(path, image, options, nodeApi);\n    if (options?.recursive) {\n        const dir = nodeApi.path.dirname(path);\n        nodeApi.fs.mkdirSync(dir, { recursive: true });\n    }\n    nodeApi.fs.writeFileSync(path, toWrite);\n}\n/**\n * Encode the image to the format specified by the file's extension.\n * @param destinationPath - Image destination.\n * @param image - Image to save.\n * @param options - Encode options.\n * @param nodeApi - Object with Node.js APIs.\n * @returns Buffer containing the encoded image.\n */\nfunction getDataToWrite(destinationPath, image, options, nodeApi) {\n    if (!options || !('format' in options)) {\n        const extension = nodeApi.path\n            .extname(destinationPath)\n            .slice(1)\n            .toLowerCase();\n        if (extension === 'png' ||\n            extension === 'jpg' ||\n            extension === 'jpeg' ||\n            extension === 'bmp') {\n            return encode(image, { ...options, format: extension });\n        }\n        else {\n            throw new RangeError('image format could not be determined from file extension. Use a supported extension or specify the format option');\n        }\n    }\n    else {\n        return encode(image, options);\n    }\n}\n//# sourceMappingURL=write.js.map","import { Image } from '../Image.js';\nimport { assert } from '../utils/validators/assert.js';\n// TODO: Create nodejs version that throws an error\n/**\n * Draw the image in an HTML canvas.\n * @param image - The image to draw.\n * @param canvas - The HTML canvas.\n * @param options - Write canvas options.\n */\nexport function writeCanvas(image, canvas, options = {}) {\n    if (image.colorModel !== 'RGBA') {\n        image = image.convertColor('RGBA');\n    }\n    if (image.bitDepth !== 8 && image instanceof Image) {\n        image = image.convertBitDepth(8);\n    }\n    const { resizeCanvas = true, dx = 0, dy = 0, dirtyX = 0, dirtyY = 0, dirtyWidth = image.width, dirtyHeight = image.height, } = options;\n    if (resizeCanvas) {\n        canvas.width = image.width;\n        canvas.height = image.height;\n    }\n    const ctx = canvas.getContext('2d');\n    assert(ctx);\n    const data = image.getRawImage().data;\n    ctx.putImageData(new ImageData(\n    // @ts-expect-error ImageData types don't support SharedArrayBuffer.\n    new Uint8ClampedArray(data.buffer, data.byteOffset, data.byteLength), image.width, image.height), dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);\n}\n//# sourceMappingURL=writeCanvas.js.map","const base64codes = Uint8Array.from([\n    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62, 255, 255,\n    255, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255, 255, 255, 0, 255, 255,\n    255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\n    21, 22, 23, 24, 25, 255, 255, 255, 255, 255, 255, 26, 27, 28, 29, 30, 31, 32,\n    33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,\n]);\n/**\n * Convert a Uint8Array containing a base64 encoded bytes to a Uint8Array containing decoded values\n * @param input\n * @returns a Uint8Array containing the decoded bytes\n */\nexport function decode(input) {\n    if (!ArrayBuffer.isView(input)) {\n        input = new Uint8Array(input);\n    }\n    if (input.length % 4 !== 0) {\n        throw new Error('Unable to parse base64 string.');\n    }\n    const output = new Uint8Array(3 * (input.length / 4));\n    if (input.length === 0)\n        return output;\n    const missingOctets = input.at(-2) === 61 ? 2 : input.at(-1) === 61 ? 1 : 0;\n    for (let i = 0, j = 0; i < input.length; i += 4, j += 3) {\n        const buffer = (base64codes[input[i]] << 18) |\n            (base64codes[input[i + 1]] << 12) |\n            (base64codes[input[i + 2]] << 6) |\n            base64codes[input[i + 3]];\n        output[j] = buffer >> 16;\n        output[j + 1] = (buffer >> 8) & 0xff;\n        output[j + 2] = buffer & 0xff;\n    }\n    return output.subarray(0, output.length - missingOctets);\n}\n//# sourceMappingURL=decode.js.map","export const base64codes = Uint8Array.from([\n    65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83,\n    84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106,\n    107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121,\n    122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47,\n]);\n//# sourceMappingURL=base64codes.js.map","import { base64codes } from './base64codes';\n/*\n3 bytes are encoded in 4 bytes of base64\n11111122 22223333 33444444\nWe want to be the fastest possible, so we will use a lookup table to convert 12 bits to 2 bytes of base64\nBut in order still to avoid one operation we will create 2 of those lookup tables.\n- One for 2222 11111122\n- One for 3333 33444444\n*/\n// 2222 11111122\nconst base64codes1 = new Uint32Array(64 * 64);\nfor (let i = 0; i < 64; i++) {\n    for (let j = 0; j < 64; j++) {\n        const index = (i << 2) | ((j & 0x30) >> 4) | ((j & 0x0f) << 8);\n        base64codes1[index] = base64codes[i] | (base64codes[j] << 8);\n    }\n}\n// 3333 33444444 that we store on the bits 16->31 just to allow to make directly the OR with the previous value\nconst base64codes2 = new Uint32Array(64 * 64);\nfor (let i = 0; i < 64; i++) {\n    for (let j = 0; j < 64; j++) {\n        const index = (i << 6) | j;\n        base64codes2[index] = (base64codes[i] << 16) | (base64codes[j] << 24);\n    }\n}\n/**\n * Convert a Uint8Array containing bytes to a Uint8Array containing the base64 encoded values\n * @param input\n * @returns a Uint8Array containing the encoded bytes\n */\nexport function encodeFast(input) {\n    const output32 = new Uint32Array(Math.ceil(input.length / 3));\n    let i, j;\n    for (i = 2, j = 0; i < input.length; i += 3, j++) {\n        output32[j] =\n            base64codes1[input[i - 2] | ((input[i - 1] & 0xf0) << 4)] |\n                base64codes2[input[i] | ((input[i - 1] & 0x0f) << 8)];\n    }\n    if (i === input.length + 1) {\n        // 1 octet yet to write\n        output32[j] =\n            base64codes[input[i - 2] >> 2] |\n                (base64codes[(input[i - 2] & 0x03) << 4] << 8) |\n                (15677 << 16);\n    }\n    if (i === input.length) {\n        // 2 octets yet to write\n        output32[j] =\n            base64codes[input[i - 2] >> 2] |\n                (base64codes[((input[i - 2] & 0x03) << 4) | (input[i - 1] >> 4)] << 8) |\n                (base64codes[(input[i - 1] & 0x0f) << 2] << 16) |\n                (61 << 24);\n    }\n    const output8 = new Uint8Array(output32.buffer);\n    return output8;\n}\n//# sourceMappingURL=encodeFast.js.map","import { encode as uint8encode } from 'uint8-base64';\nimport { defaultPng, encode } from './encode.js';\n/**\n * Converts image into Data URL string.\n * @param image - Image to get base64 encoding from.\n * @param options - Encoding options.\n * @returns base64 string.\n */\nexport function encodeDataURL(image, options = defaultPng) {\n    const buffer = encode(image, options);\n    const base64 = uint8encode(buffer);\n    const base64Data = new TextDecoder().decode(base64);\n    return `data:image/${options.format};base64,${base64Data}`;\n}\n//# sourceMappingURL=encodeDataURL.js.map","import { Matrix } from 'ml-matrix';\n/**\n * Convert row/column points to a matrix.\n * Last row is padded with **ones** (ignore third dimension).\n * @param points - Points to process.\n * @returns The matrix.\n */\nexport function getMatrixFromPoints(points) {\n    const matrix = new Matrix(3, points.length);\n    for (let i = 0; i < points.length; i++) {\n        matrix.set(0, i, points[i].column);\n        matrix.set(1, i, points[i].row);\n        matrix.set(2, i, 1);\n    }\n    return matrix;\n}\n//# sourceMappingURL=getMatrixFromPoints.js.map","import { getAffineTransform } from 'ml-affine-transform';\nimport { getMatrixFromPoints } from './getMatrixFromPoints.js';\n/**\n * The fit function for an affine transformation.\n * Get the best transformation parameters for the given source and destination.\n * @param source - Source points.\n * @param destination - Destination points.\n * @returns The model parameters in the format [angle, xTranslation, yTranslation]\n */\nexport function affineFitFunction(source, destination) {\n    const sourceMatrix = getMatrixFromPoints(source);\n    const destinationMatrix = getMatrixFromPoints(destination);\n    const result = getAffineTransform(sourceMatrix, destinationMatrix);\n    return [\n        result.rotation,\n        result.translation.x,\n        result.translation.y,\n        result.scale,\n    ];\n}\n//# sourceMappingURL=affineFitFunction.js.map","/**\n * Generate a function that applies the given transformation parameters to a point.\n * The transform is an array of number in the format: [angle, x, y, scale].\n * @param transform - Transformation to apply.\n * @returns Function to transform a point.\n */\nexport function createAffineTransformModel(transform) {\n    if (transform.length !== 4) {\n        throw new Error('Transform had wrong number of parameters');\n    }\n    return (point) => {\n        const angle = (transform[0] * Math.PI) / 180;\n        const xTranslation = transform[1];\n        const yTranslation = transform[2];\n        const scale = transform[3];\n        const column = scale * (Math.cos(angle) * point.column - Math.sin(angle) * point.row) +\n            xTranslation;\n        const row = scale * (Math.sin(angle) * point.column + Math.cos(angle) * point.row) +\n            yTranslation;\n        return { column, row };\n    };\n}\n//# sourceMappingURL=createAffineTransformModel.js.map","/**\n * Compute the distance between point 1 and point 2.\n * @param point1 - First point.\n * @param point2 - Second  point.\n * @returns Euclidean distance.\n */\nexport function getEuclideanDistance(point1, point2) {\n    return Math.hypot(point1.row - point2.row, point1.column - point2.column);\n}\n//# sourceMappingURL=getEuclideanDistance.js.map","/**\n * Crop source image for contrast enhancement.\n * @param source - Source image enlarged compared to the destination image.\n * @param destination - Destination image.\n * @param destinationOrigin - Estimated origin of the destination image in the source image (relative to top-left corner).\n * @returns The source image without margins.\n */\nexport function getSourceWithoutMargins(source, destination, destinationOrigin) {\n    const width = Math.min(destination.width, source.width - destinationOrigin.column);\n    const height = Math.min(destination.height, source.height - destinationOrigin.row);\n    return source.crop({\n        origin: { row: destinationOrigin.row, column: destinationOrigin.column },\n        width,\n        height,\n    });\n}\n//# sourceMappingURL=getSourceWithoutMargins.js.map","import { getAffineTransform as matrixGetAffineTransform } from 'ml-affine-transform';\nimport { ransac } from 'ml-ransac';\nimport { getBrief } from '../../featureMatching/descriptors/getBrief.js';\nimport { Montage, MontageDisposition, bruteForceOneMatch, getCrosscheckMatches, } from '../../featureMatching/index.js';\nimport { filterEuclideanDistance } from '../../featureMatching/matching/filterEuclideanDistance.js';\nimport { writeSync } from '../../save/index.js';\nimport { ImageColorModel } from '../../utils/constants/colorModels.js';\nimport { getMinMax } from '../../utils/getMinMax.js';\nimport { affineFitFunction } from './affineFitFunction.js';\nimport { createAffineTransformModel } from './createAffineTransformModel.js';\nimport { getEuclideanDistance } from './getEuclideanDistance.js';\nimport { getMatrixFromPoints } from './getMatrixFromPoints.js';\nimport { getSourceWithoutMargins } from './utils/getSourceWithoutMargins.js';\n/**\n * Get the affine transformation from the source to the destination image.\n * @param source - Source image. Should be the image to align on the reference image.\n * It can have an additional margin, specified in the options.\n * @param destination - Destination image. Should be the reference image.\n * @param options - Get destination translation options.\n * @returns The affine transformation from source to destination image.\n */\nexport function getAffineTransform(source, destination, options = {}) {\n    const { centroidPatchDiameter = 31, bestKeypointRadius = 5, enhanceContrast = true, crosscheck = true, destinationOrigin = { column: 0, row: 0 }, maxRansacNbIterations, debug = false, debugImagePath = `${import.meta.dirname}/montage.png`, } = options;\n    if (source.colorModel !== ImageColorModel.GREY) {\n        source = source.grey();\n    }\n    if (destination.colorModel !== ImageColorModel.GREY) {\n        destination = destination.grey();\n    }\n    // enhance images contrast\n    if (enhanceContrast) {\n        const sourceWithoutMargin = getSourceWithoutMargins(source, destination, destinationOrigin);\n        const sourceExtremums = getMinMax(sourceWithoutMargin);\n        source.level({\n            inputMin: sourceExtremums.min[0],\n            inputMax: sourceExtremums.max[0],\n            out: source,\n        });\n        const destinationExtremums = getMinMax(destination);\n        destination.level({\n            inputMin: destinationExtremums.min[0],\n            inputMax: destinationExtremums.max[0],\n            out: destination,\n        });\n    }\n    // compute briefs\n    const sourceBrief = getBrief(source, {\n        centroidPatchDiameter,\n        bestKptRadius: bestKeypointRadius,\n    });\n    const destinationBrief = getBrief(destination, {\n        centroidPatchDiameter,\n        bestKptRadius: bestKeypointRadius,\n    });\n    const nbSourceKeypoints = sourceBrief.keypoints.length;\n    const nbDestinationKeypoints = destinationBrief.keypoints.length;\n    // match reference and destination keypoints\n    let matches = [];\n    if (crosscheck) {\n        matches = getCrosscheckMatches(sourceBrief.descriptors, destinationBrief.descriptors);\n    }\n    else {\n        matches = bruteForceOneMatch(sourceBrief.descriptors, destinationBrief.descriptors);\n        matches = filterEuclideanDistance(matches, sourceBrief.keypoints, destinationBrief.keypoints, { origin: destinationOrigin });\n    }\n    if (matches.length < 2) {\n        throw new Error('Insufficient number of matches found to compute affine transform (less than 2).');\n    }\n    // extract source and destination points\n    let sourcePoints = [];\n    let destinationPoints = [];\n    for (const match of matches) {\n        sourcePoints.push(sourceBrief.keypoints[match.sourceIndex].origin);\n        destinationPoints.push(destinationBrief.keypoints[match.destinationIndex].origin);\n    }\n    // find inliers with ransac\n    let nbInliers = sourcePoints.length;\n    let nbRansacIterations = 0;\n    let inliers = [0, 1];\n    if (sourcePoints.length > 2) {\n        const ransacResult = ransac(sourcePoints, destinationPoints, {\n            distanceFunction: getEuclideanDistance,\n            modelFunction: createAffineTransformModel,\n            fitFunction: affineFitFunction,\n            maxNbIterations: maxRansacNbIterations,\n        });\n        nbRansacIterations = ransacResult.nbIterations;\n        inliers = ransacResult.inliers;\n        nbInliers = inliers.length;\n        const newSrcPoints = [];\n        const newDstPoints = [];\n        for (const inlier of inliers) {\n            newSrcPoints.push(sourcePoints[inlier]);\n            newDstPoints.push(destinationPoints[inlier]);\n        }\n        sourcePoints = newSrcPoints;\n        destinationPoints = newDstPoints;\n    }\n    // create debug image\n    if (debug) {\n        const montage = new Montage(source, destination, {\n            disposition: MontageDisposition.VERTICAL,\n        });\n        montage.drawMatches(matches, sourceBrief.keypoints, destinationBrief.keypoints, { showDistance: true });\n        const inlierMatches = [];\n        for (const inlier of inliers) {\n            inlierMatches.push(matches[inlier]);\n        }\n        montage.drawMatches(inlierMatches, sourceBrief.keypoints, destinationBrief.keypoints, { strokeColor: [0, 0, 255] });\n        const drawKeypointsBaseOptions = {\n            fill: true,\n            color: [0, 255, 0],\n            showScore: true,\n            markerSize: 3,\n        };\n        montage.drawKeypoints(sourceBrief.keypoints, drawKeypointsBaseOptions);\n        montage.drawKeypoints(destinationBrief.keypoints, {\n            origin: montage.destinationOrigin,\n            ...drawKeypointsBaseOptions,\n        });\n        writeSync(debugImagePath, montage.image);\n    }\n    // compute affine transform from destination to reference\n    const sourceMatrix = getMatrixFromPoints(sourcePoints);\n    const destinationMatrix = getMatrixFromPoints(destinationPoints);\n    const affineTransform = matrixGetAffineTransform(sourceMatrix, destinationMatrix);\n    return {\n        transform: {\n            rotation: affineTransform.rotation,\n            scale: affineTransform.scale,\n            translation: {\n                column: Math.round(affineTransform.translation.x),\n                row: Math.round(affineTransform.translation.y),\n            },\n        },\n        stats: {\n            nbMatches: matches.length,\n            nbInliers,\n            nbRansacIterations,\n            nbSourceKeypoints,\n            nbDestinationKeypoints,\n        },\n    };\n}\n//# sourceMappingURL=getAffineTransform.js.map","import checkProcessable from '../utils/validators/checkProcessable.js';\n/**\n * Aligns two images by finding the translation that minimizes the mean difference of all channels.\n * between them. The source image should fit entirely in the destination image.\n * @param source - Image to align.\n * @param destination - Image to align to.\n * @param options - Align images min difference options.\n * @returns Translation that minimizes the mean difference between the images.\n * Gives the origin of the source image relatively to the top-left corner of the destination image.\n */\nexport function alignMinDifference(source, destination, options = {}) {\n    checkProcessable(source, {\n        bitDepth: [8, 16],\n    });\n    const xSpan = destination.width - source.width;\n    const ySpan = destination.height - source.height;\n    const { startStep = Math.max(Math.round(Math.min(source.width, source.height, Math.max(xSpan, ySpan)) / 4), 1), mask, } = options;\n    if (xSpan < 0 || ySpan < 0) {\n        throw new Error('Source image must fit entirely in destination image');\n    }\n    let bestDifference = Number.POSITIVE_INFINITY;\n    let bestShiftX = 0;\n    let bestShiftY = 0;\n    let step = startStep;\n    let startX = 0;\n    let startY = 0;\n    let endX = xSpan;\n    let endY = ySpan;\n    if (mask && mask.size !== source.size) {\n        throw new Error('Mask size must be equal to source size');\n    }\n    const nbPixelsToCheck = mask ? mask.getNbNonZeroPixels() : source.size;\n    while (step >= 1) {\n        step = Math.round(step);\n        for (let shiftX = startX; shiftX <= endX; shiftX += step) {\n            for (let shiftY = startY; shiftY <= endY; shiftY += step) {\n                let currentDifference = 0;\n                next: for (let column = 0; column < source.width; column++) {\n                    for (let row = 0; row < source.height; row++) {\n                        if (mask && !mask.getBit(column, row)) {\n                            continue;\n                        }\n                        for (let channel = 0; channel < source.channels; channel++) {\n                            const sourceValue = source.getValue(column, row, channel);\n                            const destinationValue = destination.getValue(column + shiftX, row + shiftY, channel);\n                            const difference = sourceValue - destinationValue;\n                            if (difference < 0) {\n                                // Math.abs is super slow, this simple trick is 5x faster\n                                currentDifference -= difference;\n                            }\n                            else {\n                                currentDifference += difference;\n                            }\n                            if (currentDifference > bestDifference) {\n                                break next;\n                            }\n                        }\n                    }\n                }\n                if (currentDifference < bestDifference) {\n                    bestDifference = currentDifference;\n                    bestShiftX = shiftX;\n                    bestShiftY = shiftY;\n                }\n            }\n        }\n        step /= 2;\n        startX = Math.round(Math.max(0, bestShiftX - step));\n        startY = Math.round(Math.max(0, bestShiftY - step));\n        endX = Math.round(Math.min(xSpan, bestShiftX + step));\n        endY = Math.round(Math.min(ySpan, bestShiftY + step));\n    }\n    return {\n        row: bestShiftY,\n        column: bestShiftX,\n        similarity: 1 - bestDifference / (nbPixelsToCheck * source.maxValue),\n    };\n}\n//# sourceMappingURL=alignMinDifference.js.map","/**\n * Finds extreme values of an image which are not stacked together.\n * @param points - Array of points that should be combined to improve.\n * @param image - Image which extrema are calculated from.\n * @param options - FilterPointsOptions\n * @returns Array of Points.\n */\nexport function removeClosePoints(points, image, options) {\n    const distance = options?.distance || 0;\n    const kind = options?.kind || 'maximum';\n    if (options?.channel === undefined && image.channels > 1) {\n        throw new Error('image channel must be specified or image must have only one channel');\n    }\n    const channel = options?.channel || 0;\n    const isMax = kind === 'maximum';\n    const sortedPoints = points.slice();\n    sortedPoints.sort(getSort(image, channel, isMax));\n    if (distance > 0) {\n        for (let i = 0; i < sortedPoints.length; i++) {\n            for (let j = i + 1; j < sortedPoints.length; j++) {\n                if (Math.hypot(sortedPoints[i].column - sortedPoints[j].column, sortedPoints[i].row - sortedPoints[j].row) < distance) {\n                    sortedPoints.splice(j, 1);\n                    j--;\n                }\n            }\n        }\n    }\n    return sortedPoints;\n}\nfunction getSort(image, channel, isDescending) {\n    if (isDescending) {\n        return function sortDescending(a, b) {\n            return (image.getValue(b.column, b.row, channel) -\n                image.getValue(a.column, a.row, channel));\n        };\n    }\n    else {\n        return function sortAscending(a, b) {\n            return (image.getValue(a.column, a.row, channel) -\n                image.getValue(b.column, b.row, channel));\n        };\n    }\n}\n//# sourceMappingURL=removeClosePoints.js.map","'use strict';\nconst toBytes = s => [...s].map(c => c.charCodeAt(0));\nconst xpiZipFilename = toBytes('META-INF/mozilla.rsa');\nconst oxmlContentTypes = toBytes('[Content_Types].xml');\nconst oxmlRels = toBytes('_rels/.rels');\n\nfunction readUInt64LE(buf, offset = 0) {\n\tlet n = buf[offset];\n\tlet mul = 1;\n\tlet i = 0;\n\twhile (++i < 8) {\n\t\tmul *= 0x100;\n\t\tn += buf[offset + i] * mul;\n\t}\n\n\treturn n;\n}\n\nconst fileType = input => {\n\tif (!(input instanceof Uint8Array || input instanceof ArrayBuffer || Buffer.isBuffer(input))) {\n\t\tthrow new TypeError(`Expected the \\`input\\` argument to be of type \\`Uint8Array\\` or \\`Buffer\\` or \\`ArrayBuffer\\`, got \\`${typeof input}\\``);\n\t}\n\n\tconst buf = input instanceof Uint8Array ? input : new Uint8Array(input);\n\n\tif (!(buf && buf.length > 1)) {\n\t\treturn null;\n\t}\n\n\tconst check = (header, options) => {\n\t\toptions = Object.assign({\n\t\t\toffset: 0\n\t\t}, options);\n\n\t\tfor (let i = 0; i < header.length; i++) {\n\t\t\t// If a bitmask is set\n\t\t\tif (options.mask) {\n\t\t\t\t// If header doesn't equal `buf` with bits masked off\n\t\t\t\tif (header[i] !== (options.mask[i] & buf[i + options.offset])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if (header[i] !== buf[i + options.offset]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tconst checkString = (header, options) => check(toBytes(header), options);\n\n\tif (check([0xFF, 0xD8, 0xFF])) {\n\t\treturn {\n\t\t\text: 'jpg',\n\t\t\tmime: 'image/jpeg'\n\t\t};\n\t}\n\n\tif (check([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A])) {\n\t\treturn {\n\t\t\text: 'png',\n\t\t\tmime: 'image/png'\n\t\t};\n\t}\n\n\tif (check([0x47, 0x49, 0x46])) {\n\t\treturn {\n\t\t\text: 'gif',\n\t\t\tmime: 'image/gif'\n\t\t};\n\t}\n\n\tif (check([0x57, 0x45, 0x42, 0x50], {offset: 8})) {\n\t\treturn {\n\t\t\text: 'webp',\n\t\t\tmime: 'image/webp'\n\t\t};\n\t}\n\n\tif (check([0x46, 0x4C, 0x49, 0x46])) {\n\t\treturn {\n\t\t\text: 'flif',\n\t\t\tmime: 'image/flif'\n\t\t};\n\t}\n\n\t// Needs to be before `tif` check\n\tif (\n\t\t(check([0x49, 0x49, 0x2A, 0x0]) || check([0x4D, 0x4D, 0x0, 0x2A])) &&\n\t\tcheck([0x43, 0x52], {offset: 8})\n\t) {\n\t\treturn {\n\t\t\text: 'cr2',\n\t\t\tmime: 'image/x-canon-cr2'\n\t\t};\n\t}\n\n\tif (\n\t\tcheck([0x49, 0x49, 0x2A, 0x0]) ||\n\t\tcheck([0x4D, 0x4D, 0x0, 0x2A])\n\t) {\n\t\treturn {\n\t\t\text: 'tif',\n\t\t\tmime: 'image/tiff'\n\t\t};\n\t}\n\n\tif (check([0x42, 0x4D])) {\n\t\treturn {\n\t\t\text: 'bmp',\n\t\t\tmime: 'image/bmp'\n\t\t};\n\t}\n\n\tif (check([0x49, 0x49, 0xBC])) {\n\t\treturn {\n\t\t\text: 'jxr',\n\t\t\tmime: 'image/vnd.ms-photo'\n\t\t};\n\t}\n\n\tif (check([0x38, 0x42, 0x50, 0x53])) {\n\t\treturn {\n\t\t\text: 'psd',\n\t\t\tmime: 'image/vnd.adobe.photoshop'\n\t\t};\n\t}\n\n\t// Zip-based file formats\n\t// Need to be before the `zip` check\n\tif (check([0x50, 0x4B, 0x3, 0x4])) {\n\t\tif (\n\t\t\tcheck([0x6D, 0x69, 0x6D, 0x65, 0x74, 0x79, 0x70, 0x65, 0x61, 0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x65, 0x70, 0x75, 0x62, 0x2B, 0x7A, 0x69, 0x70], {offset: 30})\n\t\t) {\n\t\t\treturn {\n\t\t\t\text: 'epub',\n\t\t\t\tmime: 'application/epub+zip'\n\t\t\t};\n\t\t}\n\n\t\t// Assumes signed `.xpi` from addons.mozilla.org\n\t\tif (check(xpiZipFilename, {offset: 30})) {\n\t\t\treturn {\n\t\t\t\text: 'xpi',\n\t\t\t\tmime: 'application/x-xpinstall'\n\t\t\t};\n\t\t}\n\n\t\tif (checkString('mimetypeapplication/vnd.oasis.opendocument.text', {offset: 30})) {\n\t\t\treturn {\n\t\t\t\text: 'odt',\n\t\t\t\tmime: 'application/vnd.oasis.opendocument.text'\n\t\t\t};\n\t\t}\n\n\t\tif (checkString('mimetypeapplication/vnd.oasis.opendocument.spreadsheet', {offset: 30})) {\n\t\t\treturn {\n\t\t\t\text: 'ods',\n\t\t\t\tmime: 'application/vnd.oasis.opendocument.spreadsheet'\n\t\t\t};\n\t\t}\n\n\t\tif (checkString('mimetypeapplication/vnd.oasis.opendocument.presentation', {offset: 30})) {\n\t\t\treturn {\n\t\t\t\text: 'odp',\n\t\t\t\tmime: 'application/vnd.oasis.opendocument.presentation'\n\t\t\t};\n\t\t}\n\n\t\t// The docx, xlsx and pptx file types extend the Office Open XML file format:\n\t\t// https://en.wikipedia.org/wiki/Office_Open_XML_file_formats\n\t\t// We look for:\n\t\t// - one entry named '[Content_Types].xml' or '_rels/.rels',\n\t\t// - one entry indicating specific type of file.\n\t\t// MS Office, OpenOffice and LibreOffice may put the parts in different order, so the check should not rely on it.\n\t\tconst findNextZipHeaderIndex = (arr, startAt = 0) => arr.findIndex((el, i, arr) => i >= startAt && arr[i] === 0x50 && arr[i + 1] === 0x4B && arr[i + 2] === 0x3 && arr[i + 3] === 0x4);\n\n\t\tlet zipHeaderIndex = 0; // The first zip header was already found at index 0\n\t\tlet oxmlFound = false;\n\t\tlet type = null;\n\n\t\tdo {\n\t\t\tconst offset = zipHeaderIndex + 30;\n\n\t\t\tif (!oxmlFound) {\n\t\t\t\toxmlFound = (check(oxmlContentTypes, {offset}) || check(oxmlRels, {offset}));\n\t\t\t}\n\n\t\t\tif (!type) {\n\t\t\t\tif (checkString('word/', {offset})) {\n\t\t\t\t\ttype = {\n\t\t\t\t\t\text: 'docx',\n\t\t\t\t\t\tmime: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'\n\t\t\t\t\t};\n\t\t\t\t} else if (checkString('ppt/', {offset})) {\n\t\t\t\t\ttype = {\n\t\t\t\t\t\text: 'pptx',\n\t\t\t\t\t\tmime: 'application/vnd.openxmlformats-officedocument.presentationml.presentation'\n\t\t\t\t\t};\n\t\t\t\t} else if (checkString('xl/', {offset})) {\n\t\t\t\t\ttype = {\n\t\t\t\t\t\text: 'xlsx',\n\t\t\t\t\t\tmime: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (oxmlFound && type) {\n\t\t\t\treturn type;\n\t\t\t}\n\n\t\t\tzipHeaderIndex = findNextZipHeaderIndex(buf, offset);\n\t\t} while (zipHeaderIndex >= 0);\n\n\t\t// No more zip parts available in the buffer, but maybe we are almost certain about the type?\n\t\tif (type) {\n\t\t\treturn type;\n\t\t}\n\t}\n\n\tif (\n\t\tcheck([0x50, 0x4B]) &&\n\t\t(buf[2] === 0x3 || buf[2] === 0x5 || buf[2] === 0x7) &&\n\t\t(buf[3] === 0x4 || buf[3] === 0x6 || buf[3] === 0x8)\n\t) {\n\t\treturn {\n\t\t\text: 'zip',\n\t\t\tmime: 'application/zip'\n\t\t};\n\t}\n\n\tif (check([0x75, 0x73, 0x74, 0x61, 0x72], {offset: 257})) {\n\t\treturn {\n\t\t\text: 'tar',\n\t\t\tmime: 'application/x-tar'\n\t\t};\n\t}\n\n\tif (\n\t\tcheck([0x52, 0x61, 0x72, 0x21, 0x1A, 0x7]) &&\n\t\t(buf[6] === 0x0 || buf[6] === 0x1)\n\t) {\n\t\treturn {\n\t\t\text: 'rar',\n\t\t\tmime: 'application/x-rar-compressed'\n\t\t};\n\t}\n\n\tif (check([0x1F, 0x8B, 0x8])) {\n\t\treturn {\n\t\t\text: 'gz',\n\t\t\tmime: 'application/gzip'\n\t\t};\n\t}\n\n\tif (check([0x42, 0x5A, 0x68])) {\n\t\treturn {\n\t\t\text: 'bz2',\n\t\t\tmime: 'application/x-bzip2'\n\t\t};\n\t}\n\n\tif (check([0x37, 0x7A, 0xBC, 0xAF, 0x27, 0x1C])) {\n\t\treturn {\n\t\t\text: '7z',\n\t\t\tmime: 'application/x-7z-compressed'\n\t\t};\n\t}\n\n\tif (check([0x78, 0x01])) {\n\t\treturn {\n\t\t\text: 'dmg',\n\t\t\tmime: 'application/x-apple-diskimage'\n\t\t};\n\t}\n\n\tif (check([0x33, 0x67, 0x70, 0x35]) || // 3gp5\n\t\t(\n\t\t\tcheck([0x0, 0x0, 0x0]) && check([0x66, 0x74, 0x79, 0x70], {offset: 4}) &&\n\t\t\t\t(\n\t\t\t\t\tcheck([0x6D, 0x70, 0x34, 0x31], {offset: 8}) || // MP41\n\t\t\t\t\tcheck([0x6D, 0x70, 0x34, 0x32], {offset: 8}) || // MP42\n\t\t\t\t\tcheck([0x69, 0x73, 0x6F, 0x6D], {offset: 8}) || // ISOM\n\t\t\t\t\tcheck([0x69, 0x73, 0x6F, 0x32], {offset: 8}) || // ISO2\n\t\t\t\t\tcheck([0x6D, 0x6D, 0x70, 0x34], {offset: 8}) || // MMP4\n\t\t\t\t\tcheck([0x4D, 0x34, 0x56], {offset: 8}) || // M4V\n\t\t\t\t\tcheck([0x64, 0x61, 0x73, 0x68], {offset: 8}) // DASH\n\t\t\t\t)\n\t\t)) {\n\t\treturn {\n\t\t\text: 'mp4',\n\t\t\tmime: 'video/mp4'\n\t\t};\n\t}\n\n\tif (check([0x4D, 0x54, 0x68, 0x64])) {\n\t\treturn {\n\t\t\text: 'mid',\n\t\t\tmime: 'audio/midi'\n\t\t};\n\t}\n\n\t// https://github.com/threatstack/libmagic/blob/master/magic/Magdir/matroska\n\tif (check([0x1A, 0x45, 0xDF, 0xA3])) {\n\t\tconst sliced = buf.subarray(4, 4 + 4096);\n\t\tconst idPos = sliced.findIndex((el, i, arr) => arr[i] === 0x42 && arr[i + 1] === 0x82);\n\n\t\tif (idPos !== -1) {\n\t\t\tconst docTypePos = idPos + 3;\n\t\t\tconst findDocType = type => [...type].every((c, i) => sliced[docTypePos + i] === c.charCodeAt(0));\n\n\t\t\tif (findDocType('matroska')) {\n\t\t\t\treturn {\n\t\t\t\t\text: 'mkv',\n\t\t\t\t\tmime: 'video/x-matroska'\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (findDocType('webm')) {\n\t\t\t\treturn {\n\t\t\t\t\text: 'webm',\n\t\t\t\t\tmime: 'video/webm'\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\tif (check([0x0, 0x0, 0x0, 0x14, 0x66, 0x74, 0x79, 0x70, 0x71, 0x74, 0x20, 0x20]) ||\n\t\tcheck([0x66, 0x72, 0x65, 0x65], {offset: 4}) || // Type: `free`\n\t\tcheck([0x66, 0x74, 0x79, 0x70, 0x71, 0x74, 0x20, 0x20], {offset: 4}) ||\n\t\tcheck([0x6D, 0x64, 0x61, 0x74], {offset: 4}) || // MJPEG\n\t\tcheck([0x6D, 0x6F, 0x6F, 0x76], {offset: 4}) || // Type: `moov`\n\t\tcheck([0x77, 0x69, 0x64, 0x65], {offset: 4})) {\n\t\treturn {\n\t\t\text: 'mov',\n\t\t\tmime: 'video/quicktime'\n\t\t};\n\t}\n\n\t// RIFF file format which might be AVI, WAV, QCP, etc\n\tif (check([0x52, 0x49, 0x46, 0x46])) {\n\t\tif (check([0x41, 0x56, 0x49], {offset: 8})) {\n\t\t\treturn {\n\t\t\t\text: 'avi',\n\t\t\t\tmime: 'video/vnd.avi'\n\t\t\t};\n\t\t}\n\n\t\tif (check([0x57, 0x41, 0x56, 0x45], {offset: 8})) {\n\t\t\treturn {\n\t\t\t\text: 'wav',\n\t\t\t\tmime: 'audio/vnd.wave'\n\t\t\t};\n\t\t}\n\n\t\t// QLCM, QCP file\n\t\tif (check([0x51, 0x4C, 0x43, 0x4D], {offset: 8})) {\n\t\t\treturn {\n\t\t\t\text: 'qcp',\n\t\t\t\tmime: 'audio/qcelp'\n\t\t\t};\n\t\t}\n\t}\n\n\t// ASF_Header_Object first 80 bytes\n\tif (check([0x30, 0x26, 0xB2, 0x75, 0x8E, 0x66, 0xCF, 0x11, 0xA6, 0xD9])) {\n\t\t// Search for header should be in first 1KB of file.\n\n\t\tlet offset = 30;\n\t\tdo {\n\t\t\tconst objectSize = readUInt64LE(buf, offset + 16);\n\t\t\tif (check([0x91, 0x07, 0xDC, 0xB7, 0xB7, 0xA9, 0xCF, 0x11, 0x8E, 0xE6, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65], {offset})) {\n\t\t\t\t// Sync on Stream-Properties-Object (B7DC0791-A9B7-11CF-8EE6-00C00C205365)\n\t\t\t\tif (check([0x40, 0x9E, 0x69, 0xF8, 0x4D, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B], {offset: offset + 24})) {\n\t\t\t\t\t// Found audio:\n\t\t\t\t\treturn {\n\t\t\t\t\t\text: 'wma',\n\t\t\t\t\t\tmime: 'audio/x-ms-wma'\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tif (check([0xC0, 0xEF, 0x19, 0xBC, 0x4D, 0x5B, 0xCF, 0x11, 0xA8, 0xFD, 0x00, 0x80, 0x5F, 0x5C, 0x44, 0x2B], {offset: offset + 24})) {\n\t\t\t\t\t// Found video:\n\t\t\t\t\treturn {\n\t\t\t\t\t\text: 'wmv',\n\t\t\t\t\t\tmime: 'video/x-ms-asf'\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\toffset += objectSize;\n\t\t} while (offset + 24 <= buf.length);\n\n\t\t// Default to ASF generic extension\n\t\treturn {\n\t\t\text: 'asf',\n\t\t\tmime: 'application/vnd.ms-asf'\n\t\t};\n\t}\n\n\tif (\n\t\tcheck([0x0, 0x0, 0x1, 0xBA]) ||\n\t\tcheck([0x0, 0x0, 0x1, 0xB3])\n\t) {\n\t\treturn {\n\t\t\text: 'mpg',\n\t\t\tmime: 'video/mpeg'\n\t\t};\n\t}\n\n\tif (check([0x66, 0x74, 0x79, 0x70, 0x33, 0x67], {offset: 4})) {\n\t\treturn {\n\t\t\text: '3gp',\n\t\t\tmime: 'video/3gpp'\n\t\t};\n\t}\n\n\t// Check for MPEG header at different starting offsets\n\tfor (let start = 0; start < 2 && start < (buf.length - 16); start++) {\n\t\tif (\n\t\t\tcheck([0x49, 0x44, 0x33], {offset: start}) || // ID3 header\n\t\t\tcheck([0xFF, 0xE2], {offset: start, mask: [0xFF, 0xE2]}) // MPEG 1 or 2 Layer 3 header\n\t\t) {\n\t\t\treturn {\n\t\t\t\text: 'mp3',\n\t\t\t\tmime: 'audio/mpeg'\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tcheck([0xFF, 0xE4], {offset: start, mask: [0xFF, 0xE4]}) // MPEG 1 or 2 Layer 2 header\n\t\t) {\n\t\t\treturn {\n\t\t\t\text: 'mp2',\n\t\t\t\tmime: 'audio/mpeg'\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tcheck([0xFF, 0xF8], {offset: start, mask: [0xFF, 0xFC]}) // MPEG 2 layer 0 using ADTS\n\t\t) {\n\t\t\treturn {\n\t\t\t\text: 'mp2',\n\t\t\t\tmime: 'audio/mpeg'\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tcheck([0xFF, 0xF0], {offset: start, mask: [0xFF, 0xFC]}) // MPEG 4 layer 0 using ADTS\n\t\t) {\n\t\t\treturn {\n\t\t\t\text: 'mp4',\n\t\t\t\tmime: 'audio/mpeg'\n\t\t\t};\n\t\t}\n\t}\n\n\tif (\n\t\tcheck([0x66, 0x74, 0x79, 0x70, 0x4D, 0x34, 0x41], {offset: 4})\n\t) {\n\t\treturn { // MPEG-4 layer 3 (audio)\n\t\t\text: 'm4a',\n\t\t\tmime: 'audio/mp4' // RFC 4337\n\t\t};\n\t}\n\n\t// Needs to be before `ogg` check\n\tif (check([0x4F, 0x70, 0x75, 0x73, 0x48, 0x65, 0x61, 0x64], {offset: 28})) {\n\t\treturn {\n\t\t\text: 'opus',\n\t\t\tmime: 'audio/opus'\n\t\t};\n\t}\n\n\t// If 'OggS' in first  bytes, then OGG container\n\tif (check([0x4F, 0x67, 0x67, 0x53])) {\n\t\t// This is a OGG container\n\n\t\t// If ' theora' in header.\n\t\tif (check([0x80, 0x74, 0x68, 0x65, 0x6F, 0x72, 0x61], {offset: 28})) {\n\t\t\treturn {\n\t\t\t\text: 'ogv',\n\t\t\t\tmime: 'video/ogg'\n\t\t\t};\n\t\t}\n\n\t\t// If '\\x01video' in header.\n\t\tif (check([0x01, 0x76, 0x69, 0x64, 0x65, 0x6F, 0x00], {offset: 28})) {\n\t\t\treturn {\n\t\t\t\text: 'ogm',\n\t\t\t\tmime: 'video/ogg'\n\t\t\t};\n\t\t}\n\n\t\t// If ' FLAC' in header  https://xiph.org/flac/faq.html\n\t\tif (check([0x7F, 0x46, 0x4C, 0x41, 0x43], {offset: 28})) {\n\t\t\treturn {\n\t\t\t\text: 'oga',\n\t\t\t\tmime: 'audio/ogg'\n\t\t\t};\n\t\t}\n\n\t\t// 'Speex  ' in header https://en.wikipedia.org/wiki/Speex\n\t\tif (check([0x53, 0x70, 0x65, 0x65, 0x78, 0x20, 0x20], {offset: 28})) {\n\t\t\treturn {\n\t\t\t\text: 'spx',\n\t\t\t\tmime: 'audio/ogg'\n\t\t\t};\n\t\t}\n\n\t\t// If '\\x01vorbis' in header\n\t\tif (check([0x01, 0x76, 0x6F, 0x72, 0x62, 0x69, 0x73], {offset: 28})) {\n\t\t\treturn {\n\t\t\t\text: 'ogg',\n\t\t\t\tmime: 'audio/ogg'\n\t\t\t};\n\t\t}\n\n\t\t// Default OGG container https://www.iana.org/assignments/media-types/application/ogg\n\t\treturn {\n\t\t\text: 'ogx',\n\t\t\tmime: 'application/ogg'\n\t\t};\n\t}\n\n\tif (check([0x66, 0x4C, 0x61, 0x43])) {\n\t\treturn {\n\t\t\text: 'flac',\n\t\t\tmime: 'audio/x-flac'\n\t\t};\n\t}\n\n\tif (check([0x4D, 0x41, 0x43, 0x20])) { // 'MAC '\n\t\treturn {\n\t\t\text: 'ape',\n\t\t\tmime: 'audio/ape'\n\t\t};\n\t}\n\n\tif (check([0x77, 0x76, 0x70, 0x6B])) { // 'wvpk'\n\t\treturn {\n\t\t\text: 'wv',\n\t\t\tmime: 'audio/wavpack'\n\t\t};\n\t}\n\n\tif (check([0x23, 0x21, 0x41, 0x4D, 0x52, 0x0A])) {\n\t\treturn {\n\t\t\text: 'amr',\n\t\t\tmime: 'audio/amr'\n\t\t};\n\t}\n\n\tif (check([0x25, 0x50, 0x44, 0x46])) {\n\t\treturn {\n\t\t\text: 'pdf',\n\t\t\tmime: 'application/pdf'\n\t\t};\n\t}\n\n\tif (check([0x4D, 0x5A])) {\n\t\treturn {\n\t\t\text: 'exe',\n\t\t\tmime: 'application/x-msdownload'\n\t\t};\n\t}\n\n\tif (\n\t\t(buf[0] === 0x43 || buf[0] === 0x46) &&\n\t\tcheck([0x57, 0x53], {offset: 1})\n\t) {\n\t\treturn {\n\t\t\text: 'swf',\n\t\t\tmime: 'application/x-shockwave-flash'\n\t\t};\n\t}\n\n\tif (check([0x7B, 0x5C, 0x72, 0x74, 0x66])) {\n\t\treturn {\n\t\t\text: 'rtf',\n\t\t\tmime: 'application/rtf'\n\t\t};\n\t}\n\n\tif (check([0x00, 0x61, 0x73, 0x6D])) {\n\t\treturn {\n\t\t\text: 'wasm',\n\t\t\tmime: 'application/wasm'\n\t\t};\n\t}\n\n\tif (\n\t\tcheck([0x77, 0x4F, 0x46, 0x46]) &&\n\t\t(\n\t\t\tcheck([0x00, 0x01, 0x00, 0x00], {offset: 4}) ||\n\t\t\tcheck([0x4F, 0x54, 0x54, 0x4F], {offset: 4})\n\t\t)\n\t) {\n\t\treturn {\n\t\t\text: 'woff',\n\t\t\tmime: 'font/woff'\n\t\t};\n\t}\n\n\tif (\n\t\tcheck([0x77, 0x4F, 0x46, 0x32]) &&\n\t\t(\n\t\t\tcheck([0x00, 0x01, 0x00, 0x00], {offset: 4}) ||\n\t\t\tcheck([0x4F, 0x54, 0x54, 0x4F], {offset: 4})\n\t\t)\n\t) {\n\t\treturn {\n\t\t\text: 'woff2',\n\t\t\tmime: 'font/woff2'\n\t\t};\n\t}\n\n\tif (\n\t\tcheck([0x4C, 0x50], {offset: 34}) &&\n\t\t(\n\t\t\tcheck([0x00, 0x00, 0x01], {offset: 8}) ||\n\t\t\tcheck([0x01, 0x00, 0x02], {offset: 8}) ||\n\t\t\tcheck([0x02, 0x00, 0x02], {offset: 8})\n\t\t)\n\t) {\n\t\treturn {\n\t\t\text: 'eot',\n\t\t\tmime: 'application/vnd.ms-fontobject'\n\t\t};\n\t}\n\n\tif (check([0x00, 0x01, 0x00, 0x00, 0x00])) {\n\t\treturn {\n\t\t\text: 'ttf',\n\t\t\tmime: 'font/ttf'\n\t\t};\n\t}\n\n\tif (check([0x4F, 0x54, 0x54, 0x4F, 0x00])) {\n\t\treturn {\n\t\t\text: 'otf',\n\t\t\tmime: 'font/otf'\n\t\t};\n\t}\n\n\tif (check([0x00, 0x00, 0x01, 0x00])) {\n\t\treturn {\n\t\t\text: 'ico',\n\t\t\tmime: 'image/x-icon'\n\t\t};\n\t}\n\n\tif (check([0x00, 0x00, 0x02, 0x00])) {\n\t\treturn {\n\t\t\text: 'cur',\n\t\t\tmime: 'image/x-icon'\n\t\t};\n\t}\n\n\tif (check([0x46, 0x4C, 0x56, 0x01])) {\n\t\treturn {\n\t\t\text: 'flv',\n\t\t\tmime: 'video/x-flv'\n\t\t};\n\t}\n\n\tif (check([0x25, 0x21])) {\n\t\treturn {\n\t\t\text: 'ps',\n\t\t\tmime: 'application/postscript'\n\t\t};\n\t}\n\n\tif (check([0xFD, 0x37, 0x7A, 0x58, 0x5A, 0x00])) {\n\t\treturn {\n\t\t\text: 'xz',\n\t\t\tmime: 'application/x-xz'\n\t\t};\n\t}\n\n\tif (check([0x53, 0x51, 0x4C, 0x69])) {\n\t\treturn {\n\t\t\text: 'sqlite',\n\t\t\tmime: 'application/x-sqlite3'\n\t\t};\n\t}\n\n\tif (check([0x4E, 0x45, 0x53, 0x1A])) {\n\t\treturn {\n\t\t\text: 'nes',\n\t\t\tmime: 'application/x-nintendo-nes-rom'\n\t\t};\n\t}\n\n\tif (check([0x43, 0x72, 0x32, 0x34])) {\n\t\treturn {\n\t\t\text: 'crx',\n\t\t\tmime: 'application/x-google-chrome-extension'\n\t\t};\n\t}\n\n\tif (\n\t\tcheck([0x4D, 0x53, 0x43, 0x46]) ||\n\t\tcheck([0x49, 0x53, 0x63, 0x28])\n\t) {\n\t\treturn {\n\t\t\text: 'cab',\n\t\t\tmime: 'application/vnd.ms-cab-compressed'\n\t\t};\n\t}\n\n\t// Needs to be before `ar` check\n\tif (check([0x21, 0x3C, 0x61, 0x72, 0x63, 0x68, 0x3E, 0x0A, 0x64, 0x65, 0x62, 0x69, 0x61, 0x6E, 0x2D, 0x62, 0x69, 0x6E, 0x61, 0x72, 0x79])) {\n\t\treturn {\n\t\t\text: 'deb',\n\t\t\tmime: 'application/x-deb'\n\t\t};\n\t}\n\n\tif (check([0x21, 0x3C, 0x61, 0x72, 0x63, 0x68, 0x3E])) {\n\t\treturn {\n\t\t\text: 'ar',\n\t\t\tmime: 'application/x-unix-archive'\n\t\t};\n\t}\n\n\tif (check([0xED, 0xAB, 0xEE, 0xDB])) {\n\t\treturn {\n\t\t\text: 'rpm',\n\t\t\tmime: 'application/x-rpm'\n\t\t};\n\t}\n\n\tif (\n\t\tcheck([0x1F, 0xA0]) ||\n\t\tcheck([0x1F, 0x9D])\n\t) {\n\t\treturn {\n\t\t\text: 'Z',\n\t\t\tmime: 'application/x-compress'\n\t\t};\n\t}\n\n\tif (check([0x4C, 0x5A, 0x49, 0x50])) {\n\t\treturn {\n\t\t\text: 'lz',\n\t\t\tmime: 'application/x-lzip'\n\t\t};\n\t}\n\n\tif (check([0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1])) {\n\t\treturn {\n\t\t\text: 'msi',\n\t\t\tmime: 'application/x-msi'\n\t\t};\n\t}\n\n\tif (check([0x06, 0x0E, 0x2B, 0x34, 0x02, 0x05, 0x01, 0x01, 0x0D, 0x01, 0x02, 0x01, 0x01, 0x02])) {\n\t\treturn {\n\t\t\text: 'mxf',\n\t\t\tmime: 'application/mxf'\n\t\t};\n\t}\n\n\tif (check([0x47], {offset: 4}) && (check([0x47], {offset: 192}) || check([0x47], {offset: 196}))) {\n\t\treturn {\n\t\t\text: 'mts',\n\t\t\tmime: 'video/mp2t'\n\t\t};\n\t}\n\n\tif (check([0x42, 0x4C, 0x45, 0x4E, 0x44, 0x45, 0x52])) {\n\t\treturn {\n\t\t\text: 'blend',\n\t\t\tmime: 'application/x-blender'\n\t\t};\n\t}\n\n\tif (check([0x42, 0x50, 0x47, 0xFB])) {\n\t\treturn {\n\t\t\text: 'bpg',\n\t\t\tmime: 'image/bpg'\n\t\t};\n\t}\n\n\tif (check([0x00, 0x00, 0x00, 0x0C, 0x6A, 0x50, 0x20, 0x20, 0x0D, 0x0A, 0x87, 0x0A])) {\n\t\t// JPEG-2000 family\n\n\t\tif (check([0x6A, 0x70, 0x32, 0x20], {offset: 20})) {\n\t\t\treturn {\n\t\t\t\text: 'jp2',\n\t\t\t\tmime: 'image/jp2'\n\t\t\t};\n\t\t}\n\n\t\tif (check([0x6A, 0x70, 0x78, 0x20], {offset: 20})) {\n\t\t\treturn {\n\t\t\t\text: 'jpx',\n\t\t\t\tmime: 'image/jpx'\n\t\t\t};\n\t\t}\n\n\t\tif (check([0x6A, 0x70, 0x6D, 0x20], {offset: 20})) {\n\t\t\treturn {\n\t\t\t\text: 'jpm',\n\t\t\t\tmime: 'image/jpm'\n\t\t\t};\n\t\t}\n\n\t\tif (check([0x6D, 0x6A, 0x70, 0x32], {offset: 20})) {\n\t\t\treturn {\n\t\t\t\text: 'mj2',\n\t\t\t\tmime: 'image/mj2'\n\t\t\t};\n\t\t}\n\t}\n\n\tif (check([0x46, 0x4F, 0x52, 0x4D])) {\n\t\treturn {\n\t\t\text: 'aif',\n\t\t\tmime: 'audio/aiff'\n\t\t};\n\t}\n\n\tif (checkString('<?xml ')) {\n\t\treturn {\n\t\t\text: 'xml',\n\t\t\tmime: 'application/xml'\n\t\t};\n\t}\n\n\tif (check([0x42, 0x4F, 0x4F, 0x4B, 0x4D, 0x4F, 0x42, 0x49], {offset: 60})) {\n\t\treturn {\n\t\t\text: 'mobi',\n\t\t\tmime: 'application/x-mobipocket-ebook'\n\t\t};\n\t}\n\n\t// File Type Box (https://en.wikipedia.org/wiki/ISO_base_media_file_format)\n\tif (check([0x66, 0x74, 0x79, 0x70], {offset: 4})) {\n\t\tif (check([0x6D, 0x69, 0x66, 0x31], {offset: 8})) {\n\t\t\treturn {\n\t\t\t\text: 'heic',\n\t\t\t\tmime: 'image/heif'\n\t\t\t};\n\t\t}\n\n\t\tif (check([0x6D, 0x73, 0x66, 0x31], {offset: 8})) {\n\t\t\treturn {\n\t\t\t\text: 'heic',\n\t\t\t\tmime: 'image/heif-sequence'\n\t\t\t};\n\t\t}\n\n\t\tif (check([0x68, 0x65, 0x69, 0x63], {offset: 8}) || check([0x68, 0x65, 0x69, 0x78], {offset: 8})) {\n\t\t\treturn {\n\t\t\t\text: 'heic',\n\t\t\t\tmime: 'image/heic'\n\t\t\t};\n\t\t}\n\n\t\tif (check([0x68, 0x65, 0x76, 0x63], {offset: 8}) || check([0x68, 0x65, 0x76, 0x78], {offset: 8})) {\n\t\t\treturn {\n\t\t\t\text: 'heic',\n\t\t\t\tmime: 'image/heic-sequence'\n\t\t\t};\n\t\t}\n\t}\n\n\tif (check([0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A])) {\n\t\treturn {\n\t\t\text: 'ktx',\n\t\t\tmime: 'image/ktx'\n\t\t};\n\t}\n\n\tif (check([0x44, 0x49, 0x43, 0x4D], {offset: 128})) {\n\t\treturn {\n\t\t\text: 'dcm',\n\t\t\tmime: 'application/dicom'\n\t\t};\n\t}\n\n\t// Musepack, SV7\n\tif (check([0x4D, 0x50, 0x2B])) {\n\t\treturn {\n\t\t\text: 'mpc',\n\t\t\tmime: 'audio/x-musepack'\n\t\t};\n\t}\n\n\t// Musepack, SV8\n\tif (check([0x4D, 0x50, 0x43, 0x4B])) {\n\t\treturn {\n\t\t\text: 'mpc',\n\t\t\tmime: 'audio/x-musepack'\n\t\t};\n\t}\n\n\tif (check([0x42, 0x45, 0x47, 0x49, 0x4E, 0x3A])) {\n\t\treturn {\n\t\t\text: 'ics',\n\t\t\tmime: 'text/calendar'\n\t\t};\n\t}\n\n\tif (check([0x67, 0x6C, 0x54, 0x46, 0x02, 0x00, 0x00, 0x00])) {\n\t\treturn {\n\t\t\text: 'glb',\n\t\t\tmime: 'model/gltf-binary'\n\t\t};\n\t}\n\n\tif (check([0xD4, 0xC3, 0xB2, 0xA1]) || check([0xA1, 0xB2, 0xC3, 0xD4])) {\n\t\treturn {\n\t\t\text: 'pcap',\n\t\t\tmime: 'application/vnd.tcpdump.pcap'\n\t\t};\n\t}\n\n\treturn null;\n};\n\nmodule.exports = fileType;\n// TODO: Remove this for the next major release\nmodule.exports.default = fileType;\n\nObject.defineProperty(fileType, 'minimumBytes', {value: 4100});\n\nmodule.exports.stream = readableStream => new Promise((resolve, reject) => {\n\t// Using `eval` to work around issues when bundling with Webpack\n\tconst stream = eval('require')('stream'); // eslint-disable-line no-eval\n\n\treadableStream.once('readable', () => {\n\t\tconst pass = new stream.PassThrough();\n\t\tconst chunk = readableStream.read(module.exports.minimumBytes) || readableStream.read();\n\t\ttry {\n\t\t\tpass.fileType = fileType(chunk);\n\t\t} catch (error) {\n\t\t\treject(error);\n\t\t}\n\n\t\treadableStream.unshift(chunk);\n\n\t\tif (stream.pipeline) {\n\t\t\tresolve(stream.pipeline(readableStream, pass, () => {}));\n\t\t} else {\n\t\t\tresolve(readableStream.pipe(pass));\n\t\t}\n\t});\n});\n","'use strict';\nconst fileType = require('file-type');\n\nconst imageExts = new Set([\n\t'jpg',\n\t'png',\n\t'gif',\n\t'webp',\n\t'flif',\n\t'cr2',\n\t'tif',\n\t'bmp',\n\t'jxr',\n\t'psd',\n\t'ico',\n\t'bpg',\n\t'jp2',\n\t'jpm',\n\t'jpx',\n\t'heic',\n\t'cur',\n\t'dcm'\n]);\n\nconst imageType = input => {\n\tconst ret = fileType(input);\n\treturn imageExts.has(ret && ret.ext) ? ret : null;\n};\n\nmodule.exports = imageType;\n// TODO: Remove this for the next major release\nmodule.exports.default = imageType;\n\nObject.defineProperty(imageType, 'minimumBytes', {value: fileType.minimumBytes});\n","import { decode } from 'fast-bmp';\nimport { Image } from \"../Image.js\";\nimport { Mask } from \"../Mask.js\";\n/**\n * Decode a BMP. See the fast-bmp npm module.\n * @param data - The data to decode.\n * @returns The decoded image or mask.\n */\nexport function decodeBmp(data) {\n    const decodedData = decode(data);\n    if (decodedData.bitsPerPixel === 1) {\n        const mask = new Mask(decodedData.width, decodedData.height, {\n            data: decodedData.data,\n        });\n        return mask.convertColor('GREY');\n    }\n    else {\n        let colorModel;\n        switch (decodedData.channels) {\n            case 1:\n                colorModel = 'GREY';\n                break;\n            case 3:\n                colorModel = 'RGB';\n                break;\n            default:\n                colorModel = 'RGBA';\n                break;\n        }\n        return new Image(decodedData.width, decodedData.height, {\n            colorModel,\n            data: decodedData.data,\n        });\n    }\n}\n//# sourceMappingURL=decodeBmp.js.map","const tagsById = {\n    0x829a: 'ExposureTime',\n    0x829d: 'FNumber',\n    0x8822: 'ExposureProgram',\n    0x8824: 'SpectralSensitivity',\n    0x8827: 'ISOSpeedRatings',\n    0x8828: 'OECF',\n    0x8830: 'SensitivityType',\n    0x8831: 'StandardOutputSensitivity',\n    0x8832: 'RecommendedExposureIndex',\n    0x8833: 'ISOSpeed',\n    0x8834: 'ISOSpeedLatitudeyyy',\n    0x8835: 'ISOSpeedLatitudezzz',\n    0x9000: 'ExifVersion',\n    0x9003: 'DateTimeOriginal',\n    0x9004: 'DateTimeDigitized',\n    0x9101: 'ComponentsConfiguration',\n    0x9102: 'CompressedBitsPerPixel',\n    0x9201: 'ShutterSpeedValue',\n    0x9202: 'ApertureValue',\n    0x9203: 'BrightnessValue',\n    0x9204: 'ExposureBiasValue',\n    0x9205: 'MaxApertureValue',\n    0x9206: 'SubjectDistance',\n    0x9207: 'MeteringMode',\n    0x9208: 'LightSource',\n    0x9209: 'Flash',\n    0x920a: 'FocalLength',\n    0x9214: 'SubjectArea',\n    0x927c: 'MakerNote',\n    0x9286: 'UserComment',\n    0x9290: 'SubsecTime',\n    0x9291: 'SubsecTimeOriginal',\n    0x9292: 'SubsecTimeDigitized',\n    0xa000: 'FlashpixVersion',\n    0xa001: 'ColorSpace',\n    0xa002: 'PixelXDimension',\n    0xa003: 'PixelYDimension',\n    0xa004: 'RelatedSoundFile',\n    0xa20b: 'FlashEnergy',\n    0xa20c: 'SpatialFrequencyResponse',\n    0xa20e: 'FocalPlaneXResolution',\n    0xa20f: 'FocalPlaneYResolution',\n    0xa210: 'FocalPlaneResolutionUnit',\n    0xa214: 'SubjectLocation',\n    0xa215: 'ExposureIndex',\n    0xa217: 'SensingMethod',\n    0xa300: 'FileSource',\n    0xa301: 'SceneType',\n    0xa302: 'CFAPattern',\n    0xa401: 'CustomRendered',\n    0xa402: 'ExposureMode',\n    0xa403: 'WhiteBalance',\n    0xa404: 'DigitalZoomRatio',\n    0xa405: 'FocalLengthIn35mmFilm',\n    0xa406: 'SceneCaptureType',\n    0xa407: 'GainControl',\n    0xa408: 'Contrast',\n    0xa409: 'Saturation',\n    0xa40a: 'Sharpness',\n    0xa40b: 'DeviceSettingDescription',\n    0xa40c: 'SubjectDistanceRange',\n    0xa420: 'ImageUniqueID',\n    0xa430: 'CameraOwnerName',\n    0xa431: 'BodySerialNumber',\n    0xa432: 'LensSpecification',\n    0xa433: 'LensMake',\n    0xa434: 'LensModel',\n    0xa435: 'LensSerialNumber',\n    0xa500: 'Gamma',\n};\nconst tagsByName = {};\nfor (const i in tagsById) {\n    tagsByName[tagsById[i]] = Number(i);\n}\nexport { tagsById, tagsByName };\n//# sourceMappingURL=exif.js.map","const tagsById = {\n    0x0000: 'GPSVersionID',\n    0x0001: 'GPSLatitudeRef',\n    0x0002: 'GPSLatitude',\n    0x0003: 'GPSLongitudeRef',\n    0x0004: 'GPSLongitude',\n    0x0005: 'GPSAltitudeRef',\n    0x0006: 'GPSAltitude',\n    0x0007: 'GPSTimeStamp',\n    0x0008: 'GPSSatellites',\n    0x0009: 'GPSStatus',\n    0x000a: 'GPSMeasureMode',\n    0x000b: 'GPSDOP',\n    0x000c: 'GPSSpeedRef',\n    0x000d: 'GPSSpeed',\n    0x000e: 'GPSTrackRef',\n    0x000f: 'GPSTrack',\n    0x0010: 'GPSImgDirectionRef',\n    0x0011: 'GPSImgDirection',\n    0x0012: 'GPSMapDatum',\n    0x0013: 'GPSDestLatitudeRef',\n    0x0014: 'GPSDestLatitude',\n    0x0015: 'GPSDestLongitudeRef',\n    0x0016: 'GPSDestLongitude',\n    0x0017: 'GPSDestBearingRef',\n    0x0018: 'GPSDestBearing',\n    0x0019: 'GPSDestDistanceRef',\n    0x001a: 'GPSDestDistance',\n    0x001b: 'GPSProcessingMethod',\n    0x001c: 'GPSAreaInformation',\n    0x001d: 'GPSDateStamp',\n    0x001e: 'GPSDifferential',\n    0x001f: 'GPSHPositioningError',\n};\nconst tagsByName = {};\nfor (const i in tagsById) {\n    tagsByName[tagsById[i]] = Number(i);\n}\nexport { tagsById, tagsByName };\n//# sourceMappingURL=gps.js.map","const tagsById = {\n    // Baseline tags\n    0x00fe: 'NewSubfileType',\n    0x00ff: 'SubfileType',\n    0x0100: 'ImageWidth',\n    0x0101: 'ImageLength',\n    0x0102: 'BitsPerSample',\n    0x0103: 'Compression',\n    0x0106: 'PhotometricInterpretation',\n    0x0107: 'Threshholding',\n    0x0108: 'CellWidth',\n    0x0109: 'CellLength',\n    0x010a: 'FillOrder',\n    0x010e: 'ImageDescription',\n    0x010f: 'Make',\n    0x0110: 'Model',\n    0x0111: 'StripOffsets',\n    0x0112: 'Orientation',\n    0x0115: 'SamplesPerPixel',\n    0x0116: 'RowsPerStrip',\n    0x0117: 'StripByteCounts',\n    0x0118: 'MinSampleValue',\n    0x0119: 'MaxSampleValue',\n    0x011a: 'XResolution',\n    0x011b: 'YResolution',\n    0x011c: 'PlanarConfiguration',\n    0x0120: 'FreeOffsets',\n    0x0121: 'FreeByteCounts',\n    0x0122: 'GrayResponseUnit',\n    0x0123: 'GrayResponseCurve',\n    0x0128: 'ResolutionUnit',\n    0x0131: 'Software',\n    0x0132: 'DateTime',\n    0x013b: 'Artist',\n    0x013c: 'HostComputer',\n    0x0140: 'ColorMap',\n    0x0152: 'ExtraSamples',\n    0x8298: 'Copyright',\n    // Extension tags\n    0x010d: 'DocumentName',\n    0x011d: 'PageName',\n    0x011e: 'XPosition',\n    0x011f: 'YPosition',\n    0x0124: 'T4Options',\n    0x0125: 'T6Options',\n    0x0129: 'PageNumber',\n    0x012d: 'TransferFunction',\n    0x013d: 'Predictor',\n    0x013e: 'WhitePoint',\n    0x013f: 'PrimaryChromaticities',\n    0x0141: 'HalftoneHints',\n    0x0142: 'TileWidth',\n    0x0143: 'TileLength',\n    0x0144: 'TileOffsets',\n    0x0145: 'TileByteCounts',\n    0x0146: 'BadFaxLines',\n    0x0147: 'CleanFaxData',\n    0x0148: 'ConsecutiveBadFaxLines',\n    0x014a: 'SubIFDs',\n    0x014c: 'InkSet',\n    0x014d: 'InkNames',\n    0x014e: 'NumberOfInks',\n    0x0150: 'DotRange',\n    0x0151: 'TargetPrinter',\n    0x0153: 'SampleFormat',\n    0x0154: 'SMinSampleValue',\n    0x0155: 'SMaxSampleValue',\n    0x0156: 'TransferRange',\n    0x0157: 'ClipPath',\n    0x0158: 'XClipPathUnits',\n    0x0159: 'YClipPathUnits',\n    0x015a: 'Indexed',\n    0x015b: 'JPEGTables',\n    0x015f: 'OPIProxy',\n    0x0190: 'GlobalParametersIFD',\n    0x0191: 'ProfileType',\n    0x0192: 'FaxProfile',\n    0x0193: 'CodingMethods',\n    0x0194: 'VersionYear',\n    0x0195: 'ModeNumber',\n    0x01b1: 'Decode',\n    0x01b2: 'DefaultImageColor',\n    0x0200: 'JPEGProc',\n    0x0201: 'JPEGInterchangeFormat',\n    0x0202: 'JPEGInterchangeFormatLength',\n    0x0203: 'JPEGRestartInterval',\n    0x0205: 'JPEGLosslessPredictors',\n    0x0206: 'JPEGPointTransforms',\n    0x0207: 'JPEGQTables',\n    0x0208: 'JPEGDCTables',\n    0x0209: 'JPEGACTables',\n    0x0211: 'YCbCrCoefficients',\n    0x0212: 'YCbCrSubSampling',\n    0x0213: 'YCbCrPositioning',\n    0x0214: 'ReferenceBlackWhite',\n    0x022f: 'StripRowCounts',\n    0x02bc: 'XMP',\n    0x800d: 'ImageID',\n    0x87ac: 'ImageLayer',\n    // Private tags\n    0x80a4: 'WangAnnotatio',\n    0x82a5: 'MDFileTag',\n    0x82a6: 'MDScalePixel',\n    0x82a7: 'MDColorTable',\n    0x82a8: 'MDLabName',\n    0x82a9: 'MDSampleInfo',\n    0x82aa: 'MDPrepDate',\n    0x82ab: 'MDPrepTime',\n    0x82ac: 'MDFileUnits',\n    0x830e: 'ModelPixelScaleTag',\n    0x83bb: 'IPTC',\n    0x847e: 'INGRPacketDataTag',\n    0x847f: 'INGRFlagRegisters',\n    0x8480: 'IrasBTransformationMatrix',\n    0x8482: 'ModelTiepointTag',\n    0x85d8: 'ModelTransformationTag',\n    0x8649: 'Photoshop',\n    0x8769: 'ExifIFD',\n    0x8773: 'ICCProfile',\n    0x87af: 'GeoKeyDirectoryTag',\n    0x87b0: 'GeoDoubleParamsTag',\n    0x87b1: 'GeoAsciiParamsTag',\n    0x8825: 'GPSIFD',\n    0x885c: 'HylaFAXFaxRecvParams',\n    0x885d: 'HylaFAXFaxSubAddress',\n    0x885e: 'HylaFAXFaxRecvTime',\n    0x935c: 'ImageSourceData',\n    0xa005: 'InteroperabilityIFD',\n    0xa480: 'GDAL_METADATA',\n    0xa481: 'GDAL_NODATA',\n    0xc427: 'OceScanjobDescription',\n    0xc428: 'OceApplicationSelector',\n    0xc429: 'OceIdentificationNumber',\n    0xc42a: 'OceImageLogicCharacteristics',\n    0xc612: 'DNGVersion',\n    0xc613: 'DNGBackwardVersion',\n    0xc614: 'UniqueCameraModel',\n    0xc615: 'LocalizedCameraModel',\n    0xc616: 'CFAPlaneColor',\n    0xc617: 'CFALayout',\n    0xc618: 'LinearizationTable',\n    0xc619: 'BlackLevelRepeatDim',\n    0xc61a: 'BlackLevel',\n    0xc61b: 'BlackLevelDeltaH',\n    0xc61c: 'BlackLevelDeltaV',\n    0xc61d: 'WhiteLevel',\n    0xc61e: 'DefaultScale',\n    0xc61f: 'DefaultCropOrigin',\n    0xc620: 'DefaultCropSize',\n    0xc621: 'ColorMatrix1',\n    0xc622: 'ColorMatrix2',\n    0xc623: 'CameraCalibration1',\n    0xc624: 'CameraCalibration2',\n    0xc625: 'ReductionMatrix1',\n    0xc626: 'ReductionMatrix2',\n    0xc627: 'AnalogBalance',\n    0xc628: 'AsShotNeutral',\n    0xc629: 'AsShotWhiteXY',\n    0xc62a: 'BaselineExposure',\n    0xc62b: 'BaselineNoise',\n    0xc62c: 'BaselineSharpness',\n    0xc62d: 'BayerGreenSplit',\n    0xc62e: 'LinearResponseLimit',\n    0xc62f: 'CameraSerialNumber',\n    0xc630: 'LensInfo',\n    0xc631: 'ChromaBlurRadius',\n    0xc632: 'AntiAliasStrength',\n    0xc634: 'DNGPrivateData',\n    0xc635: 'MakerNoteSafety',\n    0xc65a: 'CalibrationIlluminant1',\n    0xc65b: 'CalibrationIlluminant2',\n    0xc65c: 'BestQualityScale',\n    0xc660: 'AliasLayerMetadata',\n};\nconst tagsByName = {};\nfor (const i in tagsById) {\n    tagsByName[tagsById[i]] = Number(i);\n}\nexport { tagsById, tagsByName };\n//# sourceMappingURL=standard.js.map","export function guessStripByteCounts(ifd) {\n    if (ifd.compression !== 1) {\n        throw new Error('missing mandatory StripByteCounts field in compressed image');\n    }\n    const bytesPerStrip = ifd.rowsPerStrip *\n        ifd.width *\n        ifd.samplesPerPixel *\n        (ifd.bitsPerSample / 8);\n    return new Array(ifd.stripOffsets.length).fill(bytesPerStrip);\n}\n//# sourceMappingURL=hacks.js.map","// Section 14: Differencing Predictor (p. 64)\nexport function applyHorizontalDifferencing8Bit(data, width, components) {\n    let i = 0;\n    while (i < data.length) {\n        for (let j = components; j < width * components; j += components) {\n            for (let k = 0; k < components; k++) {\n                data[i + j + k] =\n                    (data[i + j + k] + data[i + j - (components - k)]) & 255;\n            }\n        }\n        i += width * components;\n    }\n}\nexport function applyHorizontalDifferencing16Bit(data, width, components) {\n    let i = 0;\n    while (i < data.length) {\n        for (let j = components; j < width * components; j += components) {\n            for (let k = 0; k < components; k++) {\n                data[i + j + k] =\n                    (data[i + j + k] + data[i + j - (components - k)]) & 65535;\n            }\n        }\n        i += width * components;\n    }\n}\n//# sourceMappingURL=horizontal_differencing.js.map","import * as exif from \"./tags/exif.js\";\nimport * as gps from \"./tags/gps.js\";\nimport * as standard from \"./tags/standard.js\";\nconst tags = {\n    standard,\n    exif,\n    gps,\n};\nexport default class IFD {\n    kind;\n    data;\n    fields;\n    exif;\n    gps;\n    _hasMap;\n    _map;\n    constructor(kind) {\n        if (!kind) {\n            throw new Error('missing kind');\n        }\n        this.data = new Uint8Array();\n        this.fields = new Map();\n        this.kind = kind;\n        this._hasMap = false;\n        this._map = {};\n    }\n    get(tag) {\n        if (typeof tag === 'number') {\n            return this.fields.get(tag);\n        }\n        else if (typeof tag === 'string') {\n            return this.fields.get(tags[this.kind].tagsByName[tag]);\n        }\n        else {\n            throw new Error('expected a number or string');\n        }\n    }\n    get map() {\n        if (!this._hasMap) {\n            const taglist = tags[this.kind].tagsById;\n            for (const key of this.fields.keys()) {\n                if (taglist[key]) {\n                    this._map[taglist[key]] = this.fields.get(key);\n                }\n            }\n            this._hasMap = true;\n        }\n        return this._map;\n    }\n}\n//# sourceMappingURL=ifd.js.map","const types = new Map([\n    [1, [1, readByte]], // BYTE\n    [2, [1, readASCII]], // ASCII\n    [3, [2, readShort]], // SHORT\n    [4, [4, readLong]], // LONG\n    [5, [8, readRational]], // RATIONAL\n    [6, [1, readSByte]], // SBYTE\n    [7, [1, readByte]], // UNDEFINED\n    [8, [2, readSShort]], // SSHORT\n    [9, [4, readSLong]], // SLONG\n    [10, [8, readSRational]], // SRATIONAL\n    [11, [4, readFloat]], // FLOAT\n    [12, [8, readDouble]], // DOUBLE\n]);\nexport function getByteLength(type, count) {\n    const val = types.get(type);\n    if (!val)\n        throw new Error(`type not found: ${type}`);\n    return val[0] * count;\n}\nexport function readData(decoder, type, count) {\n    const val = types.get(type);\n    if (!val)\n        throw new Error(`type not found: ${type}`);\n    return val[1](decoder, count);\n}\nfunction readByte(decoder, count) {\n    if (count === 1)\n        return decoder.readUint8();\n    const array = new Uint8Array(count);\n    for (let i = 0; i < count; i++) {\n        array[i] = decoder.readUint8();\n    }\n    return array;\n}\nfunction readASCII(decoder, count) {\n    const strings = [];\n    let currentString = '';\n    for (let i = 0; i < count; i++) {\n        // eslint-disable-next-line unicorn/prefer-code-point\n        const char = String.fromCharCode(decoder.readUint8());\n        if (char === '\\0') {\n            strings.push(currentString);\n            currentString = '';\n        }\n        else {\n            currentString += char;\n        }\n    }\n    if (strings.length === 1) {\n        return strings[0];\n    }\n    else {\n        return strings;\n    }\n}\nfunction readShort(decoder, count) {\n    if (count === 1)\n        return decoder.readUint16();\n    const array = new Uint16Array(count);\n    for (let i = 0; i < count; i++) {\n        array[i] = decoder.readUint16();\n    }\n    return array;\n}\nfunction readLong(decoder, count) {\n    if (count === 1)\n        return decoder.readUint32();\n    const array = new Uint32Array(count);\n    for (let i = 0; i < count; i++) {\n        array[i] = decoder.readUint32();\n    }\n    return array;\n}\nfunction readRational(decoder, count) {\n    if (count === 1) {\n        return decoder.readUint32() / decoder.readUint32();\n    }\n    const rationals = new Array(count);\n    for (let i = 0; i < count; i++) {\n        rationals[i] = decoder.readUint32() / decoder.readUint32();\n    }\n    return rationals;\n}\nfunction readSByte(decoder, count) {\n    if (count === 1)\n        return decoder.readInt8();\n    const array = new Int8Array(count);\n    for (let i = 0; i < count; i++) {\n        array[i] = decoder.readInt8();\n    }\n    return array;\n}\nfunction readSShort(decoder, count) {\n    if (count === 1)\n        return decoder.readInt16();\n    const array = new Int16Array(count);\n    for (let i = 0; i < count; i++) {\n        array[i] = decoder.readInt16();\n    }\n    return array;\n}\nfunction readSLong(decoder, count) {\n    if (count === 1)\n        return decoder.readInt32();\n    const array = new Int32Array(count);\n    for (let i = 0; i < count; i++) {\n        array[i] = decoder.readInt32();\n    }\n    return array;\n}\nfunction readSRational(decoder, count) {\n    if (count === 1) {\n        return decoder.readInt32() / decoder.readInt32();\n    }\n    const rationals = new Array(count);\n    for (let i = 0; i < count; i++) {\n        rationals[i] = decoder.readInt32() / decoder.readInt32();\n    }\n    return rationals;\n}\nfunction readFloat(decoder, count) {\n    if (count === 1)\n        return decoder.readFloat32();\n    const array = new Float32Array(count);\n    for (let i = 0; i < count; i++) {\n        array[i] = decoder.readFloat32();\n    }\n    return array;\n}\nfunction readDouble(decoder, count) {\n    if (count === 1)\n        return decoder.readFloat64();\n    const array = new Float64Array(count);\n    for (let i = 0; i < count; i++) {\n        array[i] = decoder.readFloat64();\n    }\n    return array;\n}\n//# sourceMappingURL=ifd_value.js.map","import { IOBuffer } from 'iobuffer';\nconst CLEAR_CODE = 256;\nconst EOI_CODE = 257;\n// 0-255 from the table + 256 for clear code + 257 for end of information code.\nconst TABLE_START = 258;\nconst MIN_BIT_LENGTH = 9;\nlet stringTable = [];\nfunction initializeStringTable() {\n    if (stringTable.length === 0) {\n        for (let i = 0; i < 256; i++) {\n            stringTable.push([i]);\n        }\n        // Fill the table with dummy data.\n        // Elements at indices > 257 will be replaced during decompression.\n        const dummyString = [];\n        for (let i = 256; i < 4096; i++) {\n            stringTable.push(dummyString);\n        }\n    }\n}\nconst andTable = [511, 1023, 2047, 4095];\nconst bitJumps = [0, 0, 0, 0, 0, 0, 0, 0, 0, 511, 1023, 2047, 4095];\nclass LzwDecoder {\n    stripArray;\n    nextData = 0;\n    nextBits = 0;\n    bytePointer = 0;\n    tableLength = TABLE_START;\n    currentBitLength = MIN_BIT_LENGTH;\n    outData;\n    constructor(data) {\n        this.stripArray = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n        this.outData = new IOBuffer(data.byteLength);\n        this.initializeTable();\n    }\n    decode() {\n        let code = 0;\n        let oldCode = 0;\n        while ((code = this.getNextCode()) !== EOI_CODE) {\n            if (code === CLEAR_CODE) {\n                this.initializeTable();\n                code = this.getNextCode();\n                if (code === EOI_CODE) {\n                    break;\n                }\n                this.writeString(this.stringFromCode(code));\n                oldCode = code;\n            }\n            else if (this.isInTable(code)) {\n                this.writeString(this.stringFromCode(code));\n                this.addStringToTable(this.stringFromCode(oldCode).concat(this.stringFromCode(code)[0]));\n                oldCode = code;\n            }\n            else {\n                const outString = this.stringFromCode(oldCode).concat(this.stringFromCode(oldCode)[0]);\n                this.writeString(outString);\n                this.addStringToTable(outString);\n                oldCode = code;\n            }\n        }\n        const outArray = this.outData.toArray();\n        return new DataView(outArray.buffer, outArray.byteOffset, outArray.byteLength);\n    }\n    initializeTable() {\n        initializeStringTable();\n        this.tableLength = TABLE_START;\n        this.currentBitLength = MIN_BIT_LENGTH;\n    }\n    writeString(string) {\n        this.outData.writeBytes(string);\n    }\n    stringFromCode(code) {\n        // At this point, `code` must be defined in the table.\n        return stringTable[code];\n    }\n    isInTable(code) {\n        return code < this.tableLength;\n    }\n    addStringToTable(string) {\n        stringTable[this.tableLength++] = string;\n        if (stringTable.length > 4096) {\n            stringTable = [];\n            throw new Error('LZW decoding error. Please open an issue at https://github.com/image-js/tiff/issues/new/choose (include a test image).');\n        }\n        if (this.tableLength === bitJumps[this.currentBitLength]) {\n            this.currentBitLength++;\n        }\n    }\n    getNextCode() {\n        this.nextData =\n            (this.nextData << 8) | (this.stripArray[this.bytePointer++] & 0xff);\n        this.nextBits += 8;\n        if (this.nextBits < this.currentBitLength) {\n            this.nextData =\n                (this.nextData << 8) | (this.stripArray[this.bytePointer++] & 0xff);\n            this.nextBits += 8;\n        }\n        const code = (this.nextData >> (this.nextBits - this.currentBitLength)) &\n            andTable[this.currentBitLength - 9];\n        this.nextBits -= this.currentBitLength;\n        // This should not really happen but is present in other codes as well.\n        // See: https://github.com/sugark/Tiffus/blob/15a60123813d1612f4ae9e4fab964f9f7d71cf63/src/org/eclipse/swt/internal/image/TIFFLZWDecoder.java\n        if (this.bytePointer > this.stripArray.length) {\n            return 257;\n        }\n        return code;\n    }\n}\nexport function decompressLzw(stripData) {\n    return new LzwDecoder(stripData).decode();\n}\n//# sourceMappingURL=lzw.js.map","import Ifd from \"./ifd.js\";\n// eslint-disable-next-line prefer-named-capture-group\nconst dateTimeRegex = /^(\\d{4}):(\\d{2}):(\\d{2}) (\\d{2}):(\\d{2}):(\\d{2})$/;\nexport default class TiffIfd extends Ifd {\n    constructor() {\n        super('standard');\n    }\n    // Custom fields\n    get size() {\n        return this.width * this.height;\n    }\n    get width() {\n        return this.imageWidth;\n    }\n    get height() {\n        return this.imageLength;\n    }\n    get components() {\n        return this.samplesPerPixel;\n    }\n    get date() {\n        const date = new Date();\n        const result = dateTimeRegex.exec(this.dateTime);\n        if (result === null) {\n            throw new Error(`invalid dateTime: ${this.dateTime}`);\n        }\n        date.setFullYear(Number(result[1]), Number(result[2]) - 1, Number(result[3]));\n        date.setHours(Number(result[4]), Number(result[5]), Number(result[6]));\n        return date;\n    }\n    // IFD fields\n    get newSubfileType() {\n        return this.get('NewSubfileType');\n    }\n    get imageWidth() {\n        return this.get('ImageWidth');\n    }\n    get imageLength() {\n        return this.get('ImageLength');\n    }\n    get bitsPerSample() {\n        const data = this.get('BitsPerSample');\n        if (data && typeof data !== 'number') {\n            return data[0];\n        }\n        return data;\n    }\n    get alpha() {\n        const extraSamples = this.extraSamples;\n        if (!extraSamples)\n            return false;\n        return extraSamples[0] !== 0;\n    }\n    get associatedAlpha() {\n        const extraSamples = this.extraSamples;\n        if (!extraSamples)\n            return false;\n        return extraSamples[0] === 1;\n    }\n    get extraSamples() {\n        return alwaysArray(this.get('ExtraSamples'));\n    }\n    get compression() {\n        return this.get('Compression') || 1;\n    }\n    get type() {\n        return this.get('PhotometricInterpretation');\n    }\n    get fillOrder() {\n        return this.get('FillOrder') || 1;\n    }\n    get documentName() {\n        return this.get('DocumentName');\n    }\n    get imageDescription() {\n        return this.get('ImageDescription');\n    }\n    get stripOffsets() {\n        return alwaysArray(this.get('StripOffsets'));\n    }\n    get orientation() {\n        return this.get('Orientation');\n    }\n    get samplesPerPixel() {\n        return this.get('SamplesPerPixel') || 1;\n    }\n    get rowsPerStrip() {\n        return this.get('RowsPerStrip') || 2 ** 32 - 1;\n    }\n    get stripByteCounts() {\n        return alwaysArray(this.get('StripByteCounts'));\n    }\n    get minSampleValue() {\n        return this.get('MinSampleValue') || 0;\n    }\n    get maxSampleValue() {\n        return this.get('MaxSampleValue') || 2 ** this.bitsPerSample - 1;\n    }\n    get xResolution() {\n        return this.get('XResolution');\n    }\n    get yResolution() {\n        return this.get('YResolution');\n    }\n    get planarConfiguration() {\n        return this.get('PlanarConfiguration') || 1;\n    }\n    get resolutionUnit() {\n        return this.get('ResolutionUnit') || 2;\n    }\n    get dateTime() {\n        return this.get('DateTime');\n    }\n    get predictor() {\n        return this.get('Predictor') || 1;\n    }\n    get sampleFormat() {\n        const data = alwaysArray(this.get('SampleFormat') || 1);\n        return data[0];\n    }\n    get sMinSampleValue() {\n        return this.get('SMinSampleValue') || this.minSampleValue;\n    }\n    get sMaxSampleValue() {\n        return this.get('SMaxSampleValue') || this.maxSampleValue;\n    }\n    get palette() {\n        const totalColors = 2 ** this.bitsPerSample;\n        const colorMap = this.get('ColorMap');\n        if (!colorMap)\n            return undefined;\n        if (colorMap.length !== 3 * totalColors) {\n            throw new Error(`ColorMap size must be ${totalColors}`);\n        }\n        const palette = [];\n        for (let i = 0; i < totalColors; i++) {\n            palette.push([\n                colorMap[i],\n                colorMap[i + totalColors],\n                colorMap[i + 2 * totalColors],\n            ]);\n        }\n        return palette;\n    }\n    get tileWidth() {\n        return this.get('TileWidth');\n    }\n    get tileHeight() {\n        return this.get('TileLength');\n    }\n    get tileOffsets() {\n        return alwaysArray(this.get('TileOffsets'));\n    }\n    get tileByteCounts() {\n        return alwaysArray(this.get('TileByteCounts'));\n    }\n    get tiled() {\n        return (this.tileWidth !== undefined &&\n            this.tileHeight !== undefined &&\n            this.tileOffsets !== undefined &&\n            this.tileByteCounts !== undefined);\n    }\n}\nfunction alwaysArray(value) {\n    if (typeof value === 'number')\n        return [value];\n    return value;\n}\n//# sourceMappingURL=tiff_ifd.js.map","import { inflate } from 'pako';\nexport function decompressZlib(stripData) {\n    const stripUint8 = new Uint8Array(stripData.buffer, stripData.byteOffset, stripData.byteLength);\n    const inflated = inflate(stripUint8);\n    return new DataView(inflated.buffer, inflated.byteOffset, inflated.byteLength);\n}\n//# sourceMappingURL=zlib.js.map","import { IOBuffer } from 'iobuffer';\nimport { guessStripByteCounts } from \"./hacks.js\";\nimport { applyHorizontalDifferencing16Bit, applyHorizontalDifferencing8Bit, } from \"./horizontal_differencing.js\";\nimport IFD from \"./ifd.js\";\nimport { getByteLength, readData } from \"./ifd_value.js\";\nimport { decompressLzw } from \"./lzw.js\";\nimport TiffIfd from \"./tiff_ifd.js\";\nimport { decompressZlib } from \"./zlib.js\";\nconst defaultOptions = {\n    ignoreImageData: false,\n};\nexport default class TIFFDecoder extends IOBuffer {\n    _nextIFD;\n    constructor(data) {\n        super(data);\n        this._nextIFD = 0;\n    }\n    get isMultiPage() {\n        let c = 0;\n        this.decodeHeader();\n        while (this._nextIFD) {\n            c++;\n            this.decodeIFD({ ignoreImageData: true }, true);\n            if (c === 2) {\n                return true;\n            }\n        }\n        if (c === 1) {\n            return false;\n        }\n        throw unsupported('ifdCount', c);\n    }\n    get pageCount() {\n        let c = 0;\n        this.decodeHeader();\n        while (this._nextIFD) {\n            c++;\n            this.decodeIFD({ ignoreImageData: true }, true);\n        }\n        if (c > 0) {\n            return c;\n        }\n        throw unsupported('ifdCount', c);\n    }\n    decode(options = {}) {\n        const { pages } = options;\n        checkPages(pages);\n        const maxIndex = pages ? Math.max(...pages) : Infinity;\n        options = { ...defaultOptions, ...options };\n        const result = [];\n        this.decodeHeader();\n        let index = 0;\n        while (this._nextIFD) {\n            if (pages) {\n                if (pages.includes(index)) {\n                    result.push(this.decodeIFD(options, true));\n                }\n                else {\n                    this.decodeIFD({ ignoreImageData: true }, true);\n                }\n                if (index === maxIndex) {\n                    break;\n                }\n            }\n            else {\n                result.push(this.decodeIFD(options, true));\n            }\n            index++;\n        }\n        if (index < maxIndex && maxIndex !== Infinity) {\n            throw new RangeError(`Index ${maxIndex} is out of bounds. The stack only contains ${index} images.`);\n        }\n        return result;\n    }\n    decodeHeader() {\n        // Byte offset\n        const value = this.readUint16();\n        if (value === 0x4949) {\n            this.setLittleEndian();\n        }\n        else if (value === 0x4d4d) {\n            this.setBigEndian();\n        }\n        else {\n            throw new Error(`invalid byte order: 0x${value.toString(16)}`);\n        }\n        // Magic number\n        if (this.readUint16() !== 42) {\n            throw new Error('not a TIFF file');\n        }\n        // Offset of the first IFD\n        this._nextIFD = this.readUint32();\n    }\n    decodeIFD(options, tiff) {\n        this.seek(this._nextIFD);\n        let ifd;\n        if (tiff) {\n            ifd = new TiffIfd();\n        }\n        else {\n            if (!options.kind) {\n                throw new Error(`kind is missing`);\n            }\n            ifd = new IFD(options.kind);\n        }\n        const numEntries = this.readUint16();\n        for (let i = 0; i < numEntries; i++) {\n            this.decodeIFDEntry(ifd);\n        }\n        if (!options.ignoreImageData) {\n            if (!(ifd instanceof TiffIfd)) {\n                throw new Error('must be a tiff ifd');\n            }\n            this.decodeImageData(ifd);\n        }\n        this._nextIFD = this.readUint32();\n        return ifd;\n    }\n    decodeIFDEntry(ifd) {\n        const offset = this.offset;\n        const tag = this.readUint16();\n        const type = this.readUint16();\n        const numValues = this.readUint32();\n        if (type < 1 || type > 12) {\n            this.skip(4); // unknown type, skip this value\n            return;\n        }\n        const valueByteLength = getByteLength(type, numValues);\n        if (valueByteLength > 4) {\n            this.seek(this.readUint32());\n        }\n        const value = readData(this, type, numValues);\n        ifd.fields.set(tag, value);\n        // Read sub-IFDs\n        if (tag === 0x8769 || tag === 0x8825) {\n            const currentOffset = this.offset;\n            let kind = 'exif';\n            if (tag === 0x8769) {\n                kind = 'exif';\n            }\n            else if (tag === 0x8825) {\n                kind = 'gps';\n            }\n            this._nextIFD = value;\n            ifd[kind] = this.decodeIFD({\n                kind,\n                ignoreImageData: true,\n            }, false);\n            this.offset = currentOffset;\n        }\n        // go to the next entry\n        this.seek(offset);\n        this.skip(12);\n    }\n    decodeImageData(ifd) {\n        const orientation = ifd.orientation;\n        if (orientation && orientation !== 1) {\n            throw unsupported('orientation', orientation);\n        }\n        switch (ifd.type) {\n            case 0: // WhiteIsZero\n            case 1: // BlackIsZero\n            case 2: // RGB\n            case 3: // Palette color\n                if (ifd.tiled) {\n                    this.readTileData(ifd);\n                }\n                else {\n                    this.readStripData(ifd);\n                }\n                break;\n            default:\n                throw unsupported('image type', ifd.type);\n        }\n        this.applyPredictor(ifd);\n        this.convertAlpha(ifd);\n        if (ifd.bitsPerSample === 1) {\n            this.split1BitData(ifd);\n        }\n        if (ifd.type === 0) {\n            // WhiteIsZero: we invert the values\n            const bitDepth = ifd.bitsPerSample;\n            const maxValue = 2 ** bitDepth - 1;\n            for (let i = 0; i < ifd.data.length; i++) {\n                ifd.data[i] = maxValue - ifd.data[i];\n            }\n        }\n    }\n    split1BitData(ifd) {\n        const { imageWidth, imageLength, samplesPerPixel } = ifd;\n        const data = new Uint8Array(imageLength * imageWidth * samplesPerPixel);\n        const bytesPerRow = Math.ceil((imageWidth * samplesPerPixel) / 8);\n        let dataIndex = 0;\n        for (let row = 0; row < imageLength; row++) {\n            const rowStartByte = row * bytesPerRow;\n            for (let col = 0; col < imageWidth * samplesPerPixel; col++) {\n                const byteIndex = rowStartByte + Math.floor(col / 8);\n                const bitIndex = 7 - (col % 8);\n                const bit = (ifd.data[byteIndex] >> bitIndex) & 1;\n                data[dataIndex++] = bit;\n            }\n        }\n        ifd.data = data;\n    }\n    static uncompress(data, compression = 1) {\n        switch (compression) {\n            // No compression, nothing to do\n            case 1: {\n                return data;\n            }\n            // LZW compression\n            case 5: {\n                return decompressLzw(data);\n            }\n            // Zlib and Deflate compressions. They are identical.\n            case 8:\n            case 32946: {\n                return decompressZlib(data);\n            }\n            case 2: // CCITT Group 3 1-Dimensional Modified Huffman run length encoding\n                throw unsupported('Compression', 'CCITT Group 3');\n            case 32773: // PackBits compression\n                throw unsupported('Compression', 'PackBits');\n            default:\n                throw unsupported('Compression', compression);\n        }\n    }\n    createSampleReader(sampleFormat, bitDepth, littleEndian) {\n        if (bitDepth === 8 || bitDepth === 1) {\n            return (data, index) => data.getUint8(index);\n        }\n        else if (bitDepth === 16) {\n            return (data, index) => data.getUint16(2 * index, littleEndian);\n        }\n        else if (bitDepth === 32 && sampleFormat === 3) {\n            return (data, index) => data.getFloat32(4 * index, littleEndian);\n        }\n        else if (bitDepth === 64 && sampleFormat === 3) {\n            return (data, index) => data.getFloat64(8 * index, littleEndian);\n        }\n        else {\n            throw unsupported('bitDepth', bitDepth);\n        }\n    }\n    readStripData(ifd) {\n        // General Image Dimensions\n        const width = ifd.width;\n        const height = ifd.height;\n        const size = ifd.bitsPerSample !== 1\n            ? width * ifd.samplesPerPixel * height\n            : Math.ceil((width * ifd.samplesPerPixel) / 8) * height;\n        // Compressed Strip Layout\n        const stripOffsets = ifd.stripOffsets;\n        const stripByteCounts = ifd.stripByteCounts || guessStripByteCounts(ifd);\n        const littleEndian = this.isLittleEndian();\n        // For 1-bit images, calculate pixels per strip correctly\n        const stripLength = ifd.bitsPerSample !== 1\n            ? width * ifd.samplesPerPixel * ifd.rowsPerStrip\n            : Math.ceil((width * ifd.samplesPerPixel) / 8) * ifd.rowsPerStrip;\n        const readSamples = this.createSampleReader(ifd.sampleFormat, ifd.bitsPerSample, littleEndian);\n        // Output Data Buffer\n        const output = getDataArray(size, ifd.bitsPerSample, ifd.sampleFormat);\n        // Iterate over Number of Strips\n        let start = 0;\n        for (let i = 0; i < stripOffsets.length; i++) {\n            // Extract Strip Data, Uncompress\n            const stripData = new DataView(this.buffer, this.byteOffset + stripOffsets[i], stripByteCounts[i]);\n            const uncompressed = TIFFDecoder.uncompress(stripData, ifd.compression);\n            // Last strip can be smaller\n            const length = Math.min(stripLength, size - start);\n            // Write Uncompressed Strip Data to Output (Linear Layout)\n            for (let index = 0; index < length; ++index) {\n                const value = readSamples(uncompressed, index);\n                output[start + index] = value;\n            }\n            start += length;\n        }\n        ifd.data = output;\n        // For 1-bit images, we need to convert the data to bits\n    }\n    readTileData(ifd) {\n        if (!ifd.tileWidth || !ifd.tileHeight) {\n            return;\n        }\n        const width = ifd.width;\n        const height = ifd.height;\n        const size = ifd.bitsPerSample !== 1\n            ? width * height * ifd.samplesPerPixel\n            : Math.ceil((width * ifd.samplesPerPixel) / 8) * height;\n        const twidth = ifd.tileWidth;\n        const theight = ifd.tileHeight;\n        const nwidth = Math.ceil(width / twidth);\n        const nheight = Math.ceil(height / theight);\n        const tileOffsets = ifd.tileOffsets;\n        const tileByteCounts = ifd.tileByteCounts;\n        const littleEndian = this.isLittleEndian();\n        const readSamples = this.createSampleReader(ifd.sampleFormat, ifd.bitsPerSample, littleEndian);\n        const output = getDataArray(size, ifd.bitsPerSample, ifd.sampleFormat);\n        for (let nx = 0; nx < nwidth; ++nx) {\n            for (let ny = 0; ny < nheight; ++ny) {\n                const nind = ny * nwidth + nx;\n                const tileData = new DataView(this.buffer, this.byteOffset + tileOffsets[nind], tileByteCounts[nind]);\n                const uncompressed = TIFFDecoder.uncompress(tileData, ifd.compression);\n                if (ifd.bitsPerSample === 1) {\n                    // For 1-bit: read sequentially by bytes\n                    const bytesPerRow = Math.ceil(width / 8);\n                    const tileBytesPerRow = Math.ceil(twidth / 8);\n                    for (let ty = 0; ty < theight && ny * theight + ty < height; ty++) {\n                        const iy = ny * theight + ty;\n                        const srcStart = ty * tileBytesPerRow;\n                        const dstStart = iy * bytesPerRow + Math.floor((nx * twidth) / 8);\n                        // Copy the row of bytes from tile to output\n                        const bytesToCopy = Math.min(tileBytesPerRow, bytesPerRow - Math.floor((nx * twidth) / 8));\n                        for (let b = 0; b < bytesToCopy; b++) {\n                            output[dstStart + b] = readSamples(uncompressed, srcStart + b);\n                        }\n                    }\n                }\n                else {\n                    // For 8/16/32-bit: read by pixels\n                    for (let ty = 0; ty < theight; ty++) {\n                        for (let tx = 0; tx < twidth; tx++) {\n                            const ix = nx * twidth + tx;\n                            const iy = ny * theight + ty;\n                            if (ix >= width || iy >= height)\n                                continue;\n                            const tilePixelIndex = ty * twidth + tx;\n                            const value = readSamples(uncompressed, tilePixelIndex);\n                            const outputPixelIndex = (iy * width + ix) * ifd.samplesPerPixel;\n                            output[outputPixelIndex] = value;\n                        }\n                    }\n                }\n            }\n        }\n        ifd.data = output;\n    }\n    applyPredictor(ifd) {\n        const bitDepth = ifd.bitsPerSample;\n        switch (ifd.predictor) {\n            case 1: {\n                // No prediction scheme, nothing to do\n                break;\n            }\n            case 2: {\n                if (bitDepth === 8) {\n                    applyHorizontalDifferencing8Bit(ifd.data, ifd.width, ifd.components);\n                }\n                else if (bitDepth === 16) {\n                    applyHorizontalDifferencing16Bit(ifd.data, ifd.width, ifd.components);\n                }\n                else {\n                    throw new Error(`Horizontal differencing is only supported for images with a bit depth of ${bitDepth}`);\n                }\n                break;\n            }\n            default:\n                throw new Error(`invalid predictor: ${ifd.predictor}`);\n        }\n    }\n    convertAlpha(ifd) {\n        if (ifd.alpha && ifd.associatedAlpha) {\n            const { data, components, maxSampleValue } = ifd;\n            for (let i = 0; i < data.length; i += components) {\n                const alphaValue = data[i + components - 1];\n                for (let j = 0; j < components - 1; j++) {\n                    data[i + j] = Math.round((data[i + j] * maxSampleValue) / alphaValue);\n                }\n            }\n        }\n    }\n}\nfunction getDataArray(size, bitDepth, sampleFormat) {\n    if (bitDepth === 8 || bitDepth === 1) {\n        return new Uint8Array(size);\n    }\n    else if (bitDepth === 16) {\n        return new Uint16Array(size);\n    }\n    else if (bitDepth === 32 && sampleFormat === 3) {\n        return new Float32Array(size);\n    }\n    else if (bitDepth === 64 && sampleFormat === 3) {\n        return new Float64Array(size);\n    }\n    else {\n        throw unsupported('bit depth / sample format', `${bitDepth} / ${sampleFormat}`);\n    }\n}\nfunction unsupported(type, value) {\n    return new Error(`Unsupported ${type}: ${value}`);\n}\nfunction checkPages(pages) {\n    if (pages) {\n        for (const page of pages) {\n            if (page < 0 || !Number.isInteger(page)) {\n                throw new RangeError(`Index ${page} is invalid. Must be a positive integer.`);\n            }\n        }\n    }\n}\n//# sourceMappingURL=tiff_decoder.js.map","import { tagsById as exif } from \"./tags/exif.js\";\nimport { tagsById as gps } from \"./tags/gps.js\";\nimport { tagsById as standard } from \"./tags/standard.js\";\nimport TIFFDecoder from \"./tiff_decoder.js\";\nfunction decodeTIFF(data, options) {\n    const decoder = new TIFFDecoder(data);\n    return decoder.decode(options);\n}\nfunction isMultiPage(data) {\n    const decoder = new TIFFDecoder(data);\n    return decoder.isMultiPage;\n}\nfunction pageCount(data) {\n    const decoder = new TIFFDecoder(data);\n    return decoder.pageCount;\n}\nconst tagNames = {\n    exif,\n    gps,\n    standard,\n};\nexport { decodeTIFF as decode, isMultiPage, pageCount, tagNames };\nexport {} from \"./types.js\";\nexport { default as TiffIfd } from \"./tiff_ifd.js\";\n//# sourceMappingURL=index.js.map","import { IOBuffer } from 'iobuffer';\nimport { decode as decodeTIFF } from 'tiff';\nexport function decode(data) {\n    const buffer = new IOBuffer(data);\n    const result = {};\n    buffer.setBigEndian();\n    const val = buffer.readUint16();\n    if (val !== 0xffd8) {\n        throw new Error('SOI marker not found. Not a valid JPEG file');\n    }\n    const next = buffer.readUint16();\n    if (next === 0xffe1) {\n        buffer.skip(2);\n        const header = buffer.readBytes(6);\n        if (header[0] === 69 && // E\n            header[1] === 120 && // x\n            header[2] === 105 && // i\n            header[3] === 102 && // f\n            header[4] === 0 &&\n            header[5] === 0) {\n            result.exif = decodeTIFF(new Uint8Array(buffer.buffer, buffer.byteOffset + 12, buffer.byteLength - 12), {\n                pages: [0],\n                ignoreImageData: true,\n            });\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=decode.js.map","/**\n * Get metadata from an IFD.\n * @param ifd - The IFD.\n * @returns The metadata.\n */\nexport function getMetadata(ifd) {\n    return {\n        tiff: {\n            fields: ifd.fields,\n            tags: ifd.map,\n        },\n        exif: ifd.exif,\n    };\n}\n//# sourceMappingURL=getMetadata.js.map","import { decode as decodeExif } from 'fast-jpeg';\nimport { decode } from 'jpeg-js';\nimport { Image } from '../Image.js';\nimport { getMetadata } from './getMetadata.js';\n/**\n * Decode a jpeg. See the jpeg-js npm module.\n * @param buffer - The data to decode.\n * @returns The decoded image.\n */\nexport function decodeJpeg(buffer) {\n    const jpeg = decode(buffer, {\n        useTArray: true,\n        maxMemoryUsageInMB: Number.POSITIVE_INFINITY,\n        maxResolutionInMP: Number.POSITIVE_INFINITY,\n    });\n    const decodedExif = decodeExif(buffer);\n    // TODO : handle stacks (many IFDs?)\n    const meta = decodedExif.exif?.[0]\n        ? getMetadata(decodedExif.exif[0])\n        : undefined;\n    return new Image(jpeg.width, jpeg.height, {\n        data: jpeg.data,\n        colorModel: 'RGBA',\n        meta,\n    });\n}\n//# sourceMappingURL=decodeJpeg.js.map","import { decode } from 'fast-png';\nimport { Image } from '../Image.js';\nimport { assert } from '../utils/validators/assert.js';\n/**\n * Decode a PNG. See the fast-png npm module.\n * @param buffer - The data to decode.\n * @returns The decoded image.\n */\nexport function decodePng(buffer) {\n    const png = decode(buffer);\n    let colorModel;\n    const bitDepth = png.depth;\n    if (png.palette) {\n        return loadPalettePng(png);\n    }\n    if (bitDepth === 1) {\n        return new Image(png.width, png.height, {\n            data: decodeBinary(png),\n            colorModel: 'GREY',\n        });\n    }\n    switch (png.channels) {\n        case 1:\n            colorModel = 'GREY';\n            break;\n        case 2:\n            colorModel = 'GREYA';\n            break;\n        case 3:\n            colorModel = 'RGB';\n            break;\n        case 4:\n            colorModel = 'RGBA';\n            break;\n        default:\n            throw new RangeError(`invalid number of channels: ${png.channels}`);\n    }\n    let resolution;\n    if (png.resolution) {\n        resolution =\n            png.resolution.unit === 1\n                ? /*If the resolution unit is meters*/ {\n                    x: png.resolution.x,\n                    y: png.resolution.y,\n                    unit: 'meter',\n                }\n                : /*If resolution unit is unknown */ {\n                    x: png.resolution.x,\n                    y: png.resolution.y,\n                    unit: 'unknown',\n                };\n    }\n    return new Image(png.width, png.height, {\n        colorModel,\n        bitDepth,\n        data: png.data,\n        resolution,\n    });\n}\n/**\n * Compute PNG data from palette information and return a new image.\n * @param png - Decoded PNG.\n * @returns The new image.\n */\nfunction loadPalettePng(png) {\n    assert(png.palette);\n    const pixels = png.width * png.height;\n    const data = new Uint8Array(pixels * png.palette[0].length);\n    const pixelsPerByte = 8 / png.depth;\n    const factor = png.depth < 8 ? pixelsPerByte : 1;\n    const mask = Number.parseInt('1'.repeat(png.depth), 2);\n    let dataIndex = 0;\n    for (let i = 0; i < pixels; i++) {\n        const index = Math.floor(i / factor);\n        let value = png.data[index];\n        if (png.depth < 8) {\n            value =\n                (value >>> (png.depth * (pixelsPerByte - 1 - (i % pixelsPerByte)))) &\n                    mask;\n        }\n        const paletteValue = png.palette[value];\n        for (const paletteChannel of paletteValue) {\n            data[dataIndex++] = paletteChannel;\n        }\n    }\n    return new Image(png.width, png.height, {\n        data,\n        colorModel: png.palette[0].length === 4 ? 'RGBA' : 'RGB',\n    });\n}\nfunction decodeBinary(png) {\n    const totalPixels = png.width * png.height;\n    const result = new Uint8Array(totalPixels);\n    const pngData = png.data;\n    const padding = png.width % 8;\n    const bytesPerLine = Math.ceil(png.width / 8);\n    let pixelIndex = 0;\n    for (let byteIndex = 0; byteIndex < pngData.length && pixelIndex < totalPixels; byteIndex++) {\n        const byte = pngData[byteIndex];\n        const limit = byteIndex % bytesPerLine === 0 ? 8 - padding : 0;\n        for (let bitIndex = 7; bitIndex >= limit && pixelIndex < totalPixels; bitIndex--) {\n            const bit = (byte >> bitIndex) & 1;\n            result[pixelIndex++] = bit * 255;\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=decodePng.js.map","import { decode } from 'tiff';\nimport { Image } from '../Image.js';\nimport { getMetadata } from './getMetadata.js';\n/**\n * Decode a TIFF. See the tiff module.\n * @param buffer - The data to decode.\n * @returns The decoded image.\n */\nexport function decodeTiff(buffer) {\n    const result = decode(buffer, { pages: [0] });\n    return getImageFromIFD(result[0]);\n}\n/**\n * Create image from a single IFD.\n * @param ifd - The IFD.\n * @returns The decoded image.\n */\nexport function getImageFromIFD(ifd) {\n    if (ifd.data instanceof Float32Array || ifd.data instanceof Float64Array) {\n        throw new Error('Float TIFF data is not supported.');\n    }\n    const resolution = getTiffResolution(ifd);\n    if (ifd.type === 3) {\n        const hasAlpha = ifd.samplesPerPixel === 2;\n        const pixelLength = hasAlpha ? 4 : 3;\n        const data = new Uint16Array(pixelLength * ifd.width * ifd.height);\n        const palette = ifd.palette;\n        let ptr = 0;\n        if (hasAlpha) {\n            for (let index = 0; index < ifd.data.length; index += ifd.samplesPerPixel) {\n                const color = palette[ifd.data[index]];\n                data[ptr++] = color[0];\n                data[ptr++] = color[1];\n                data[ptr++] = color[2];\n                // To ensure that the value is 16 bits.\n                data[ptr++] = Math.round((ifd.data[index + 1] / 2 ** ifd.bitsPerSample) * 65535);\n            }\n        }\n        else {\n            for (let index = 0; index < ifd.data.length; index += ifd.samplesPerPixel) {\n                const color = palette[ifd.data[index]];\n                data[ptr++] = color[0];\n                data[ptr++] = color[1];\n                data[ptr++] = color[2];\n            }\n        }\n        return new Image(ifd.width, ifd.height, {\n            data,\n            colorModel: hasAlpha ? 'RGBA' : 'RGB',\n            bitDepth: 16,\n            meta: getMetadata(ifd),\n            resolution,\n        });\n    }\n    else if (ifd.type === 1 || ifd.type === 0) {\n        if (ifd.bitsPerSample !== 1) {\n            return new Image(ifd.width, ifd.height, {\n                data: ifd.data,\n                bitDepth: ifd.bitsPerSample,\n                colorModel: ifd.alpha ? 'GREYA' : 'GREY',\n                meta: getMetadata(ifd),\n                resolution,\n            });\n        }\n        else {\n            return new Image(ifd.width, ifd.height, {\n                data: ifd.data.map((pixel) => pixel * 255),\n                bitDepth: 8,\n                colorModel: 'GREY',\n                meta: getMetadata(ifd),\n                resolution,\n            });\n        }\n    }\n    else {\n        return new Image(ifd.width, ifd.height, {\n            data: ifd.data,\n            bitDepth: ifd.bitsPerSample,\n            colorModel: ifd.alpha ? 'RGBA' : 'RGB',\n            meta: getMetadata(ifd),\n            resolution,\n        });\n    }\n}\n/**\n * Gets image resolution from its metadata and converts it into Pixels per meter, when it's possible. Also keeps original resolution values and units.\n * @param ifd - Tiff metadata.\n * @returns Resolution object.\n */\nfunction getTiffResolution(ifd) {\n    if (!ifd.xResolution || !ifd.yResolution) {\n        return undefined;\n    }\n    switch (ifd.resolutionUnit) {\n        case 1:\n            return {\n                x: ifd.xResolution,\n                y: ifd.yResolution,\n                unit: 'unknown',\n            };\n        case 3:\n            return {\n                x: ifd.xResolution,\n                y: ifd.yResolution,\n                unit: 'centimeter',\n            };\n        default:\n            return {\n                x: ifd.xResolution,\n                y: ifd.yResolution,\n                unit: 'inch',\n            };\n    }\n}\n//# sourceMappingURL=decodeTiff.js.map","import imageType from 'image-type';\nimport { match } from 'ts-pattern';\nimport { decodeBmp } from \"./decodeBmp.js\";\nimport { decodeJpeg } from './decodeJpeg.js';\nimport { decodePng } from './decodePng.js';\nimport { decodeTiff } from './decodeTiff.js';\n/**\n * Decode input data. Data format is automatically detected.\n * Possible formats: png, jpeg and tiff.\n * @param data - Data to decode.\n * @returns The decoded image.\n */\nexport function decode(data) {\n    const typedArray = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n    const type = imageType(typedArray);\n    return match(type)\n        .with({ mime: 'image/png' }, () => decodePng(typedArray))\n        .with({ mime: 'image/jpeg' }, () => decodeJpeg(typedArray))\n        .with({ mime: 'image/tiff' }, () => decodeTiff(typedArray))\n        .with({ mime: 'image/bmp' }, () => decodeBmp(typedArray))\n        .otherwise(() => {\n        throw new RangeError(`invalid data format: ${type?.mime}`);\n    });\n}\n//# sourceMappingURL=decode.js.map","import { getNodeApiOrThrow } from '../utils/cross_platform.js';\nimport { decode } from './decode.js';\n/**\n * Read an image from the disk.\n * The file format is automatically selected based on the first few bytes.\n * This method is only implemented for Node.js.\n * @param path - The path to the image.\n * @returns Image instance.\n */\nexport async function read(path) {\n    const nodeApi = getNodeApiOrThrow('read');\n    const data = await nodeApi.fs.promises.readFile(path);\n    return decode(data);\n}\n/**\n * Synchronous version of {@link read}.\n * This method is only implemented for Node.js.\n * @param path - The path to the image.\n * @returns Image instance.\n */\nexport function readSync(path) {\n    const nodeApi = getNodeApiOrThrow('readSync');\n    return decode(nodeApi.fs.readFileSync(path));\n}\n//# sourceMappingURL=read.js.map","import { Image } from '../Image.js';\nimport { assert } from '../utils/validators/assert.js';\n/**\n * Read an image from an HTML canvas element.\n * @param canvas - Canvas element.\n * @returns The read image.\n */\nexport function readCanvas(canvas) {\n    const ctx = canvas.getContext('2d');\n    assert(ctx);\n    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    return new Image(imageData.width, imageData.height, {\n        data: new Uint8Array(imageData.data.buffer, imageData.data.byteOffset, imageData.data.byteLength),\n        colorModel: 'RGBA',\n    });\n}\n//# sourceMappingURL=readCanvas.js.map","import { assert } from '../utils/validators/assert.js';\nimport { readCanvas } from './readCanvas.js';\n// TODO: Create nodejs version that throws an error\n/**\n * Read an image from an HTML image source.\n * @param img - Image source such as an <img> or <svg> element.\n * @returns The read image.\n */\nexport function readImg(img) {\n    const canvas = document.createElement('canvas');\n    canvas.width = img.width;\n    canvas.height = img.height;\n    const ctx = canvas.getContext('2d');\n    assert(ctx);\n    ctx.drawImage(img, 0, 0);\n    return readCanvas(canvas);\n}\n//# sourceMappingURL=readImg.js.map","import { decode } from './decode.js';\n/**\n * Fetches image URL and decodes it.\n * @param dataUrl - Image URL.\n * @returns decoded image data.\n */\nexport async function fetchURL(dataUrl) {\n    const response = await fetch(dataUrl);\n    const arrayBuffer = await response.arrayBuffer();\n    const image = decode(new DataView(arrayBuffer));\n    return image;\n}\n//# sourceMappingURL=fetchURL.js.map","/**\n * Convert HSV (hue, saturation, value) color code to RGB.\n * - Hue: angle in the color wheel (from red to purple), in range 0-359.\n * - Saturation: how strong the color is (from white to bright color), in range 0-255.\n * - Value: basically the brightness (from black to intense color), in range 0-255.\n * @param hsv - The HSV color.\n * @returns The RGB color.\n */\nexport function hsvToRgb(hsv) {\n    const h = hsv[0];\n    const s = hsv[1] / 255;\n    const v = hsv[2] / 255;\n    const C = s * v;\n    const X = C * (1 - Math.abs(((h / 60) % 2) - 1));\n    const m = v - C;\n    let r, g, b;\n    if (h >= 0 && h < 60) {\n        r = C;\n        g = X;\n        b = 0;\n    }\n    else if (h >= 60 && h < 120) {\n        r = X;\n        g = C;\n        b = 0;\n    }\n    else if (h >= 120 && h < 180) {\n        r = 0;\n        g = C;\n        b = X;\n    }\n    else if (h >= 180 && h < 240) {\n        r = 0;\n        g = X;\n        b = C;\n    }\n    else if (h >= 240 && h < 300) {\n        r = X;\n        g = 0;\n        b = C;\n    }\n    else {\n        r = C;\n        g = 0;\n        b = X;\n    }\n    const rgb = new Uint8Array(3);\n    rgb[0] = (r + m) * 255;\n    rgb[1] = (g + m) * 255;\n    rgb[2] = (b + m) * 255;\n    return rgb;\n}\n//# sourceMappingURL=hsvToRgb.js.map","/**\n * Convert RGB array to 32 bits number where alpha is set to 255.\n * @param rgb - The RGB color array.\n * @returns 32 bits number encoding RGBA color.\n */\nexport function rgbToNumber(rgb) {\n    return 0xff000000 + (rgb[2] << 16) + (rgb[1] << 8) + rgb[0];\n}\n//# sourceMappingURL=rgbToNumber.js.map","import { hsvToRgb } from '../hsvToRgb.js';\nimport { rgbToNumber } from '../rgbToNumber.js';\n/**\n * Return a map where ROIs are red (negative) or green (positive) depending on the ROI index.\n * @param options - Color maps options.\n * @returns The colored map.\n */\nexport function getBinaryMap(options) {\n    const { nbNegative, nbPositive, whiteHue = 120, blackHue = 0, roiKind = 'bw', } = options;\n    const colorMap = new Uint32Array(nbNegative + nbPositive + 1);\n    // negative values\n    if (roiKind === 'bw' || roiKind === 'black') {\n        for (let i = -nbNegative; i < 0; i++) {\n            const hsv = [blackHue, 255, 255];\n            colorMap[i + nbNegative] = rgbToNumber(hsvToRgb(hsv));\n        }\n    }\n    if (roiKind === 'bw' || roiKind === 'white') {\n        // positive values\n        for (let i = 1; i <= nbPositive; i++) {\n            const hsv = [whiteHue, 255, 255];\n            colorMap[i + nbNegative] = rgbToNumber(hsvToRgb(hsv));\n        }\n    }\n    return colorMap;\n}\n//# sourceMappingURL=getBinaryMap.js.map","import { match } from 'ts-pattern';\nimport { hsvToRgb } from '../hsvToRgb.js';\nimport { rgbToNumber } from '../rgbToNumber.js';\n/**\n * Return a map where ROIs are all different hues.\n * @param options - Get temperature map options.\n * @returns The colored map.\n */\nexport function getRainbowMap(options) {\n    const { nbNegative, nbPositive, roiKind = 'bw' } = options;\n    const colorMap = new Uint32Array(nbNegative + nbPositive + 1);\n    const hueRange = 360;\n    const step = match(roiKind)\n        .with('bw', () => hueRange / (nbNegative + nbPositive))\n        .with('black', () => hueRange / nbNegative)\n        .with('white', () => hueRange / nbPositive)\n        .exhaustive();\n    // negative values\n    let hue = 0;\n    if (roiKind === 'bw' || roiKind === 'black') {\n        for (let i = -nbNegative; i < 0; i++) {\n            const hsv = [hue, 255, 255];\n            colorMap[i + nbNegative] = rgbToNumber(hsvToRgb(hsv));\n            hue += step;\n        }\n    }\n    // positive values\n    if (roiKind === 'bw' || roiKind === 'white') {\n        for (let i = 1; i <= nbPositive; i++) {\n            const hsv = [hue, 255, 255];\n            colorMap[i + nbNegative] = rgbToNumber(hsvToRgb(hsv));\n            hue += step;\n        }\n    }\n    return colorMap;\n}\n//# sourceMappingURL=getRainbowMap.js.map","import { hsvToRgb } from '../hsvToRgb.js';\nimport { rgbToNumber } from '../rgbToNumber.js';\n/**\n * Return a map where ROIs are different shades of red (positive) or blue (negative) depending on the ROI index. It it the saturation of the HSV color model that is varied.\n * @param options - Get temperature map options.\n * @returns The colored map.\n */\nexport function getSaturationMap(options) {\n    const { nbNegative, nbPositive, roiKind = 'bw', whiteHue = 0, blackHue = 240, } = options;\n    const colorMap = new Uint32Array(nbNegative + nbPositive + 1);\n    const range = 255 - 63; // saturation range for good contrast\n    const negativeStep = range / nbNegative;\n    const positiveStep = range / nbPositive;\n    // negative values\n    let counter = 0;\n    if (roiKind === 'bw' || roiKind === 'black') {\n        for (let i = -nbNegative; i < 0; i++) {\n            const hsv = [blackHue, 255 - counter++ * negativeStep, 255];\n            colorMap[i + nbNegative] = rgbToNumber(hsvToRgb(hsv));\n        }\n    }\n    // positive values\n    counter = 0;\n    if (roiKind === 'bw' || roiKind === 'white') {\n        for (let i = 1; i <= nbPositive; i++) {\n            const hsv = [whiteHue, 255 - counter++ * positiveStep, 255];\n            colorMap[i + nbNegative] = rgbToNumber(hsvToRgb(hsv));\n        }\n    }\n    return colorMap;\n}\n//# sourceMappingURL=getSaturationMap.js.map","import { match } from 'ts-pattern';\nimport { getBinaryMap } from './colorMaps/getBinaryMap.js';\nimport { getRainbowMap } from './colorMaps/getRainbowMap.js';\nimport { getSaturationMap } from './colorMaps/getSaturationMap.js';\n/**\n * Return a map of 32 bits integers corresponding to the colors of each ROI.\n * @param options - Get color map options.\n * @returns The color map.\n */\nexport function getColorMap(options) {\n    const { mode = 'binary' } = options;\n    options = { roiKind: 'bw', ...options };\n    return match(mode)\n        .with('binary', () => getBinaryMap(options))\n        .with('saturation', () => getSaturationMap(options))\n        .with('rainbow', () => getRainbowMap(options))\n        .exhaustive();\n}\n//# sourceMappingURL=getColorMap.js.map","import { Image } from '../Image.js';\nimport { getColorMap } from './utils/getColorMap.js';\nexport const RoisColorMode = {\n    /**\n     * Only two acceptable values: red or green.\n     */\n    BINARY: 'binary',\n    /**\n     * Palette of reds and blues.\n     */\n    SATURATION: 'saturation',\n    /**\n     * All possible hues (gradient of colors).\n     */\n    RAINBOW: 'rainbow',\n};\n/**\n * Generate an image with all the ROIs of various colors.\n * @param roiMapManager - The ROI map manager.\n * @param options - Color ROIs options.\n * @returns The colored image.\n */\nexport function colorRois(roiMapManager, options = {}) {\n    const { roiKind = 'bw', mode = 'binary' } = options;\n    const map = roiMapManager.getMap();\n    const image = new Image(map.width, map.height, {\n        colorModel: 'RGBA',\n    });\n    const colorMap = getColorMap({\n        roiKind,\n        mode,\n        nbNegative: map.nbNegative,\n        nbPositive: map.nbPositive,\n    });\n    const data32 = new Uint32Array(image.getRawImage().data.buffer);\n    for (let index = 0; index < image.size; index++) {\n        data32[index] = colorMap[map.data[index] + map.nbNegative];\n    }\n    return image;\n}\n//# sourceMappingURL=colorRois.js.map","/**\n * Return an array with the coordinates of the pixels that are on the border of the ROI.\n * The reference is the top-left corner of the ROI.\n * @param roi - ROI to process.\n * @param options - Get border points options.\n * @returns The array of border pixels.\n */\nexport function getBorderPoints(roi, options = {}) {\n    const mask = roi.getMask();\n    return mask.getBorderPoints(options);\n}\n//# sourceMappingURL=getBorderPoints.js.map","import { Mask } from '../Mask.js';\n/**\n * Generate a mask of an ROI.\n * @param roi - The ROI to generate a mask for.\n * @param options - Get mask options.\n * @returns The ROI mask.\n */\nexport function getMask(roi, options = {}) {\n    const { solidFill = false } = options;\n    const mask = new Mask(roi.width, roi.height, { origin: roi.origin });\n    for (let row = 0; row < roi.height; row++) {\n        for (let column = 0; column < roi.width; column++) {\n            if (roi.getMapValue(roi.origin.column + column, roi.origin.row + row) ===\n                roi.id) {\n                mask.setBit(column, row, 1);\n            }\n            else {\n                mask.setBit(column, row, 0);\n            }\n        }\n    }\n    if (solidFill) {\n        mask.solidFill({ out: mask });\n    }\n    return mask;\n}\n//# sourceMappingURL=getMask.js.map","import { EigenvalueDecomposition } from 'ml-matrix';\nimport { xVariance, xyCovariance } from 'ml-spectra-processing';\nimport { getAngle } from '../../maskAnalysis/utils/getAngle.js';\nimport { toDegrees } from '../../utils/geometry/angles.js';\nimport { assert } from '../../utils/validators/assert.js';\n/**\n * Calculates ellipse on around ROI.\n * @param roi - Region of interest.\n * @returns Ellipse.\n */\nexport function getEllipse(roi) {\n    const xCenter = roi.centroid.column;\n    const yCenter = roi.centroid.row;\n    const xCentered = roi.relativePoints.map((point) => point.column - xCenter);\n    const yCentered = roi.relativePoints.map((point) => point.row - yCenter);\n    const centeredXVariance = xVariance(xCentered, { unbiased: false });\n    const centeredYVariance = xVariance(yCentered, { unbiased: false });\n    const centeredCovariance = xyCovariance({\n        x: xCentered,\n        y: yCentered,\n    }, { unbiased: false });\n    //spectral decomposition of the sample covariance matrix\n    const sampleCovarianceMatrix = [\n        [centeredXVariance, centeredCovariance],\n        [centeredCovariance, centeredYVariance],\n    ];\n    const e = new EigenvalueDecomposition(sampleCovarianceMatrix);\n    const eigenvalues = e.realEigenvalues;\n    const vectors = e.eigenvectorMatrix;\n    assert(eigenvalues[0] <= eigenvalues[1]);\n    let radiusMajor = Math.sqrt(eigenvalues[1]);\n    let radiusMinor = Math.sqrt(eigenvalues[0]);\n    const vectorMajor = vectors.getColumn(1);\n    const vectorMinor = vectors.getColumn(0);\n    let majorAxisPoint1 = {\n        column: xCenter + radiusMajor * vectorMajor[0],\n        row: yCenter + radiusMajor * vectorMajor[1],\n    };\n    let majorAxisPoint2 = {\n        column: xCenter - radiusMajor * vectorMajor[0],\n        row: yCenter - radiusMajor * vectorMajor[1],\n    };\n    let minorAxisPoint1 = {\n        column: xCenter + radiusMinor * vectorMinor[0],\n        row: yCenter + radiusMinor * vectorMinor[1],\n    };\n    let minorAxisPoint2 = {\n        column: xCenter - radiusMinor * vectorMinor[0],\n        row: yCenter - radiusMinor * vectorMinor[1],\n    };\n    let majorLength = Math.hypot(majorAxisPoint1.column - majorAxisPoint2.column, majorAxisPoint1.row - majorAxisPoint2.row);\n    let minorLength = Math.hypot(minorAxisPoint1.column - majorAxisPoint2.column, minorAxisPoint1.row - minorAxisPoint2.row);\n    let ellipseSurface = (((minorLength / 2) * majorLength) / 2) * Math.PI;\n    if (ellipseSurface !== roi.surface) {\n        const scaleFactor = Math.sqrt(roi.surface / ellipseSurface);\n        radiusMajor *= scaleFactor;\n        radiusMinor *= scaleFactor;\n        majorAxisPoint1 = {\n            column: xCenter + radiusMajor * vectorMajor[0],\n            row: yCenter + radiusMajor * vectorMajor[1],\n        };\n        majorAxisPoint2 = {\n            column: xCenter - radiusMajor * vectorMajor[0],\n            row: yCenter - radiusMajor * vectorMajor[1],\n        };\n        minorAxisPoint1 = {\n            column: xCenter + radiusMinor * vectorMinor[0],\n            row: yCenter + radiusMinor * vectorMinor[1],\n        };\n        minorAxisPoint2 = {\n            column: xCenter - radiusMinor * vectorMinor[0],\n            row: yCenter - radiusMinor * vectorMinor[1],\n        };\n        majorLength *= scaleFactor;\n        minorLength *= scaleFactor;\n        ellipseSurface *= scaleFactor ** 2;\n    }\n    return {\n        center: {\n            column: xCenter,\n            row: yCenter,\n        },\n        majorAxis: {\n            points: [majorAxisPoint1, majorAxisPoint2],\n            length: majorLength,\n            angle: toDegrees(getAngle(majorAxisPoint1, majorAxisPoint2)),\n        },\n        minorAxis: {\n            points: [minorAxisPoint1, minorAxisPoint2],\n            length: minorLength,\n            angle: toDegrees(getAngle(minorAxisPoint1, minorAxisPoint2)),\n        },\n        surface: ellipseSurface,\n    };\n}\n//# sourceMappingURL=getEllipse.js.map","import { getConvexHull } from '../maskAnalysis/getConvexHull.js';\nimport { getFeret } from '../maskAnalysis/getFeret.js';\nimport { getMbr } from '../maskAnalysis/getMbr.js';\nimport { getBorderPoints } from './getBorderPoints.js';\nimport { getMask } from './getMask.js';\nimport { getEllipse } from './properties/getEllipse.js';\nexport class Roi {\n    /**\n     * Original map with all the ROI IDs.\n     */\n    map;\n    /**\n     * ID of the ROI. Positive for white ROIs and negative for black ones.\n     */\n    id;\n    /**\n     * Origin of the ROI. The top-left corner of the rectangle around\n     * the ROI relative to the original image.\n     */\n    origin;\n    /**\n     * Width of the ROI.\n     */\n    width;\n    /**\n     * Height of the ROI.\n     */\n    height;\n    /**\n     * Surface of the ROI.\n     */\n    surface;\n    /**\n     * Cached values of properties to improve performance.\n     */\n    #computed;\n    constructor(map, id, width, height, origin, surface) {\n        this.map = map;\n        this.id = id;\n        this.origin = origin;\n        this.width = width;\n        this.height = height;\n        this.surface = surface;\n        this.#computed = {};\n    }\n    /**\n     * Return the value at the given coordinates in an ROI map.\n     * @param column - Column of the value.\n     * @param row - Row of the value.\n     * @returns The value at the given coordinates.\n     */\n    getMapValue(column, row) {\n        return this.map.data[this.map.width * row + column];\n    }\n    /**\n     * Returns the ratio between the width and the height of the bounding rectangle of the ROI.\n     * @returns The width by height ratio.\n     */\n    getRatio() {\n        return this.width / this.height;\n    }\n    /**\n     * Generates a mask of an ROI. You can specify the kind of mask you want using the `kind` option.\n     * @param options - Get Mask options.\n     * @returns The ROI mask.\n     */\n    getMask(options) {\n        return getMask(this, options);\n    }\n    /**\n     * Computes the diameter of a circle that has the same perimeter as the particle image.\n     * @returns Ped value in pixels.\n     */\n    get ped() {\n        return this.perimeter / Math.PI;\n    }\n    /**\n     * Return an array with the coordinates of the pixels that are on the border of the ROI.\n     * The points are defined as [column, row].\n     * @param options - Get border points options.\n     * @returns The array of border pixels.\n     */\n    getBorderPoints(options) {\n        return getBorderPoints(this, options);\n    }\n    /**\n     * Returns an array of ROIs IDs that are included in the current ROI.\n     * This will be useful to know if there are some holes in the ROI.\n     * @returns InternalIDs.\n     */\n    get internalIDs() {\n        return this.#getComputed('internalIDs', () => {\n            const internal = [this.id];\n            const roiMap = this.map;\n            const data = roiMap.data;\n            if (this.height > 2) {\n                for (let column = 0; column < this.width; column++) {\n                    const target = this.#computeIndex(0, column);\n                    if (internal.includes(data[target])) {\n                        const id = data[target + roiMap.width];\n                        if (!internal.includes(id) && !this.boxIDs.includes(id)) {\n                            internal.push(id);\n                        }\n                    }\n                }\n            }\n            const array = new Array(4);\n            for (let column = 1; column < this.width - 1; column++) {\n                for (let row = 1; row < this.height - 1; row++) {\n                    const target = this.#computeIndex(row, column);\n                    if (internal.includes(data[target])) {\n                        // We check if one of the neighbor is not yet in.\n                        array[0] = data[target - 1];\n                        array[1] = data[target + 1];\n                        array[2] = data[target - roiMap.width];\n                        array[3] = data[target + roiMap.width];\n                        for (let i = 0; i < 4; i++) {\n                            const id = array[i];\n                            if (!internal.includes(id) && !this.boxIDs.includes(id)) {\n                                internal.push(id);\n                            }\n                        }\n                    }\n                }\n            }\n            return internal;\n        });\n    }\n    /**\n     * Returns an array of ROIs IDs that touch the current ROI.\n     * @returns The array of Borders.\n     */\n    get externalBorders() {\n        return this.#getComputed('externalBorders', () => {\n            // Takes all the borders and removes the internal one ...\n            const borders = this.borders;\n            const externalBorders = [];\n            const externalIDs = [];\n            const internals = this.internalIDs;\n            for (const border of borders) {\n                if (!internals.includes(border.connectedID)) {\n                    const element = {\n                        connectedID: border.connectedID,\n                        length: border.length,\n                    };\n                    externalIDs.push(element.connectedID);\n                    externalBorders.push(element);\n                }\n            }\n            return externalBorders;\n        });\n    }\n    /**\n     * Calculates and caches the number of sides by which each pixel is touched externally.\n     * @returns An object which tells how many pixels are exposed externally to how many sides.\n     */\n    get perimeterInfo() {\n        return this.#getComputed('perimeterInfo', () => {\n            const roiMap = this.map;\n            const data = roiMap.data;\n            let one = 0;\n            let two = 0;\n            let three = 0;\n            let four = 0;\n            const externalIDs = new Set(this.externalBorders.map((element) => element.connectedID));\n            for (let column = 0; column < this.width; column++) {\n                for (let row = 0; row < this.height; row++) {\n                    const target = this.#computeIndex(row, column);\n                    if (data[target] === this.id) {\n                        let nbAround = 0;\n                        if (column === 0) {\n                            nbAround++;\n                        }\n                        else if (externalIDs.has(data[target - 1])) {\n                            nbAround++;\n                        }\n                        if (column === roiMap.width - 1) {\n                            nbAround++;\n                        }\n                        else if (externalIDs.has(data[target + 1])) {\n                            nbAround++;\n                        }\n                        if (row === 0) {\n                            nbAround++;\n                        }\n                        else if (externalIDs.has(data[target - roiMap.width])) {\n                            nbAround++;\n                        }\n                        if (row === roiMap.height - 1) {\n                            nbAround++;\n                        }\n                        else if (externalIDs.has(data[target + roiMap.width])) {\n                            nbAround++;\n                        }\n                        switch (nbAround) {\n                            case 1:\n                                one++;\n                                break;\n                            case 2:\n                                two++;\n                                break;\n                            case 3:\n                                three++;\n                                break;\n                            case 4:\n                                four++;\n                                break;\n                            default:\n                        }\n                    }\n                }\n            }\n            return { one, two, three, four };\n        });\n    }\n    /**\n     * Perimeter of the ROI.\n     * The perimeter is calculated using the sum of all the external borders of the ROI to which we subtract:\n     * (2 - 2) * the number of pixels that have 2 external borders\n     * 2 * (2 - 2) * the number of pixels that have 3 external borders\n     * @returns Perimeter value in pixels.\n     */\n    get perimeter() {\n        const info = this.perimeterInfo;\n        const delta = 2 - Math.sqrt(2);\n        return (info.one +\n            info.two * 2 +\n            info.three * 3 +\n            info.four * 4 -\n            delta * (info.two + info.three * 2 + info.four));\n    }\n    /**\n     * Computes ROI points relative to ROIs point of `origin`.\n     * @returns Array of points with relative ROI coordinates.\n     */\n    get relativePoints() {\n        return this.#getComputed(`relativePoints`, () => {\n            const points = Array.from(this.points(false));\n            return points;\n        });\n    }\n    /**\n     * Computes ROI points relative to Image's/Mask's point of `origin`.\n     * @returns Array of points with absolute ROI coordinates.\n     */\n    get absolutePoints() {\n        return this.#getComputed(`absolutePoints`, () => {\n            const points = Array.from(this.points(true));\n            return points;\n        });\n    }\n    get boxIDs() {\n        return this.#getComputed('boxIDs', () => {\n            const surroundingIDs = new Set(); // Allows to get a unique list without indexOf.\n            const roiMap = this.map;\n            const data = roiMap.data;\n            // We check the first line and the last line.\n            for (const row of [0, this.height - 1]) {\n                for (let column = 0; column < this.width; column++) {\n                    const target = this.#computeIndex(row, column);\n                    if (column - this.origin.column > 0 &&\n                        data[target] === this.id &&\n                        data[target - 1] !== this.id) {\n                        const value = data[target - 1];\n                        surroundingIDs.add(value);\n                    }\n                    if (roiMap.width - column - this.origin.column > 1 &&\n                        data[target] === this.id &&\n                        data[target + 1] !== this.id) {\n                        const value = data[target + 1];\n                        surroundingIDs.add(value);\n                    }\n                }\n            }\n            // We check the first column and the last column.\n            for (const column of [0, this.width - 1]) {\n                for (let row = 0; row < this.height; row++) {\n                    const target = this.#computeIndex(row, column);\n                    if (row - this.origin.row > 0 &&\n                        data[target] === this.id &&\n                        data[target - roiMap.width] !== this.id) {\n                        const value = data[target - roiMap.width];\n                        surroundingIDs.add(value);\n                    }\n                    if (roiMap.height - row - this.origin.row > 1 &&\n                        data[target] === this.id &&\n                        data[target + roiMap.width] !== this.id) {\n                        const value = data[target + roiMap.width];\n                        surroundingIDs.add(value);\n                    }\n                }\n            }\n            return Array.from(surroundingIDs); // The selection takes the whole rectangle.\n        });\n    }\n    /**\n     * Computes the diameter of a circle of equal projection area (EQPC).\n     * It is a diameter of a circle that has the same surface as the ROI.\n     * @returns `eqpc` value in pixels.\n     */\n    get eqpc() {\n        return 2 * Math.sqrt(this.surface / Math.PI);\n    }\n    /**\n     * Computes ellipse of ROI. It is the smallest ellipse that fits the ROI.\n     * @returns Ellipse\n     */\n    get ellipse() {\n        return this.#getComputed('ellipse', () => {\n            return getEllipse(this);\n        });\n    }\n    /**\n     * Number of holes in the ROI and their total surface.\n     * Used to calculate fillRatio.\n     * @returns The surface of holes in ROI in pixels.\n     */\n    get holesInfo() {\n        return this.#getComputed('holesInfo', () => {\n            let surface = 0;\n            const data = this.map.data;\n            for (let column = 1; column < this.width - 1; column++) {\n                for (let row = 1; row < this.height - 1; row++) {\n                    const target = this.#computeIndex(row, column);\n                    if (this.internalIDs.includes(data[target]) &&\n                        data[target] !== this.id) {\n                        surface++;\n                    }\n                }\n            }\n            return {\n                number: this.internalIDs.length - 1,\n                surface,\n            };\n        });\n    }\n    /**\n     * Calculates and caches border's length and their IDs.\n     * @returns Borders' length and their IDs.\n     */\n    get borders() {\n        return this.#getComputed('borders', () => {\n            const roiMap = this.map;\n            const data = roiMap.data;\n            const surroudingIDs = new Set();\n            const surroundingBorders = new Map();\n            const visitedData = new Set();\n            const dx = [1, 0, -1, 0];\n            const dy = [0, 1, 0, -1];\n            for (let column = this.origin.column; column <= this.origin.column + this.width; column++) {\n                for (let row = this.origin.row; row <= this.origin.row + this.height; row++) {\n                    const target = column + row * roiMap.width;\n                    if (data[target] === this.id) {\n                        for (let dir = 0; dir < 4; dir++) {\n                            const newX = column + dx[dir];\n                            const newY = row + dy[dir];\n                            if (newX >= 0 &&\n                                newY >= 0 &&\n                                newX < roiMap.width &&\n                                newY < roiMap.height) {\n                                const neighbour = newX + newY * roiMap.width;\n                                if (data[neighbour] !== this.id &&\n                                    !visitedData.has(neighbour)) {\n                                    visitedData.add(neighbour);\n                                    surroudingIDs.add(data[neighbour]);\n                                    let surroundingBorder = surroundingBorders.get(data[neighbour]);\n                                    if (!surroundingBorder) {\n                                        surroundingBorders.set(data[neighbour], 1);\n                                    }\n                                    else {\n                                        surroundingBorders.set(data[neighbour], ++surroundingBorder);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            const id = Array.from(surroudingIDs);\n            return id.map((id) => {\n                return {\n                    connectedID: id,\n                    length: surroundingBorders.get(id),\n                };\n            });\n        });\n    }\n    /**\n     * Computes fill ratio of the ROI. It is calculated by dividing ROI's actual surface over the surface combined with holes, to see how holes affect its surface.\n     * @returns Fill ratio value.\n     */\n    get fillRatio() {\n        return this.surface / (this.surface + this.holesInfo.surface);\n    }\n    /**\n     * Computes sphericity of the ROI.\n     * Sphericity is a measure of the degree to which a particle approximates the shape of a sphere, and is independent of its size. The value is always between 0 and 1. The less spheric the ROI is the smaller is the number.\n     * @returns Sphericity value.\n     */\n    get sphericity() {\n        return (2 * Math.sqrt(this.surface * Math.PI)) / this.perimeter;\n    }\n    /**\n     * Computes the surface of the ROI, including the surface of the holes.\n     * @returns Surface including holes measured in pixels.\n     */\n    get filledSurface() {\n        return this.surface + this.holesInfo.surface;\n    }\n    /**\n     * The solidity describes the extent to which a shape is convex or concave.\n     * The solidity of a completely convex shape is 1, the farther the it deviates from 1, the greater the extent of concavity in the shape of the ROI.\n     * @returns Solidity value.\n     */\n    get solidity() {\n        return this.surface / this.convexHull.surface;\n    }\n    //TODO Should be refactored to not need creating a new Mask.\n    /**\n     *Computes convex hull. It is the smallest convex set that contains it.\n     * @see https://en.wikipedia.org/wiki/Convex_hull\n     * @returns Convex hull.\n     */\n    get convexHull() {\n        return this.#getComputed('convexHull', () => {\n            return getConvexHull(this.getMask());\n        });\n    }\n    /**\n     * Computes the minimum bounding rectangle.\n     * In digital image processing, the bounding box is merely the coordinates of the rectangular border that fully encloses a digital image when it is placed over a page, a canvas, a screen or other similar bidimensional background.\n     * @returns The minimum bounding rectangle.\n     */\n    get mbr() {\n        return this.#getComputed('mbr', () => {\n            return getMbr(this.getMask());\n        });\n    }\n    /*\n    * Computes roundness of ROI.\n    * Roundness is the measure of how closely the shape of an object approaches that of a mathematically perfect circle.\n   (See slide 24 https://static.horiba.com/fileadmin/Horiba/Products/Scientific/Particle_Characterization/Webinars/Slides/TE011.pdf) */\n    get roundness() {\n        return (4 * this.surface) / (Math.PI * this.feret.maxDiameter.length ** 2);\n    }\n    /**\n     * This is not a diameter in its actual sense but the common basis of a group of diameters derived from the distance of two tangents to the contour of the particle in a well-defined orientation.\n     * In simpler words, the method corresponds to the measurement by a slide gauge (slide gauge principle).\n     * In general it is defined as the distance between two parallel tangents of the particle at an arbitrary angle. The minimum Feret diameter is often used as the diameter equivalent to a sieve analysis.\n     * @returns The maximum and minimum Feret Diameters.\n     */\n    get feret() {\n        return this.#getComputed('feret', () => {\n            return getFeret(this.getMask());\n        });\n    }\n    /**\n     * A JSON object with all the data about ROI.\n     * @returns All current ROI properties as one object.\n     */\n    toJSON() {\n        return {\n            id: this.id,\n            origin: this.origin,\n            height: this.height,\n            width: this.width,\n            surface: this.surface,\n            eqpc: this.eqpc,\n            ped: this.ped,\n            feret: this.feret,\n            fillRatio: this.fillRatio,\n            sphericity: this.sphericity,\n            roundness: this.roundness,\n            solidity: this.solidity,\n            perimeter: this.perimeter,\n            convexHull: this.convexHull,\n            mbr: this.mbr,\n            filledSurface: this.filledSurface,\n            centroid: this.centroid,\n        };\n    }\n    /**\n     * Computes a center of mass of the current ROI.\n     * @returns point\n     */\n    get centroid() {\n        return this.#getComputed('centroid', () => {\n            const roiMap = this.map;\n            const data = roiMap.data;\n            let sumColumn = 0;\n            let sumRow = 0;\n            for (let column = 0; column < this.width; column++) {\n                for (let row = 0; row < this.height; row++) {\n                    const target = this.#computeIndex(row, column);\n                    if (data[target] === this.id) {\n                        sumColumn += column;\n                        sumRow += row;\n                    }\n                }\n            }\n            return {\n                column: sumColumn / this.surface + this.origin.column,\n                row: sumRow / this.surface + this.origin.row,\n            };\n        });\n    }\n    //  A helper function to cache already calculated properties.\n    #getComputed(property, callback) {\n        if (this.#computed[property] === undefined) {\n            const result = callback();\n            this.#computed[property] = result;\n            return result;\n        }\n        return this.#computed[property];\n    }\n    //TODO Make this private.\n    /**\n     * Calculates the correct index on the map of ROI.\n     * @param y - Map row\n     * @param x - Map column\n     * @returns Index within the ROI map.\n     */\n    #computeIndex(y, x) {\n        const roiMap = this.map;\n        return (y + this.origin.row) * roiMap.width + x + this.origin.column;\n    }\n    /**\n     * Generator function to calculate point's coordinates.\n     * @param absolute - controls whether coordinates should be relative to ROI's point of `origin` (relative), or relative to ROI's position on the Image/Mask (absolute).\n     * @yields Coordinates of each point of ROI.\n     */\n    *points(absolute) {\n        for (let row = 0; row < this.height; row++) {\n            for (let column = 0; column < this.width; column++) {\n                const target = (row + this.origin.row) * this.map.width +\n                    column +\n                    this.origin.column;\n                if (this.map.data[target] === this.id) {\n                    if (absolute) {\n                        yield {\n                            column: this.origin.column + column,\n                            row: this.origin.row + row,\n                        };\n                    }\n                    else {\n                        yield { column, row };\n                    }\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=Roi.js.map","import { Roi } from './Roi.js';\n/**\n * Generate an array of ROIs based on an ROI map manager.\n * @param roiMapManager - Roi map manager to use.\n */\nexport function computeRois(roiMapManager) {\n    const map = roiMapManager.getMap();\n    const whites = new Array(map.nbPositive);\n    const blacks = new Array(map.nbNegative);\n    for (let i = 0; i < map.nbPositive; i++) {\n        whites[i] = {\n            minRow: map.height,\n            minColumn: map.width,\n            maxRow: -1,\n            maxColumn: -1,\n            surface: 0,\n            id: i + 1,\n        };\n    }\n    for (let i = 0; i < map.nbNegative; i++) {\n        blacks[i] = {\n            borderLengths: [],\n            borderIDs: [],\n            minRow: map.height,\n            minColumn: map.width,\n            maxRow: -1,\n            maxColumn: -1,\n            surface: 0,\n            id: -i - 1,\n        };\n    }\n    for (let row = 0; row < map.height; row++) {\n        for (let column = 0; column < map.width; column++) {\n            const currentIndex = roiMapManager.getMapValue(column, row);\n            if (currentIndex === 0) {\n                continue;\n            }\n            let currentRoi;\n            if (currentIndex < 0) {\n                currentRoi = blacks[-currentIndex - 1];\n            }\n            else {\n                currentRoi = whites[currentIndex - 1];\n            }\n            currentRoi.surface++;\n            if (row < currentRoi.minRow) {\n                currentRoi.minRow = row;\n            }\n            if (row > currentRoi.maxRow) {\n                currentRoi.maxRow = row;\n            }\n            if (column < currentRoi.minColumn) {\n                currentRoi.minColumn = column;\n            }\n            if (column > currentRoi.maxColumn) {\n                currentRoi.maxColumn = column;\n            }\n        }\n    }\n    roiMapManager.whiteRois = new Array(map.nbPositive);\n    roiMapManager.blackRois = new Array(map.nbNegative);\n    for (let i = 0; i < map.nbNegative; i++) {\n        const width = blacks[i].maxColumn - blacks[i].minColumn + 1;\n        const height = blacks[i].maxRow - blacks[i].minRow + 1;\n        const origin = { row: blacks[i].minRow, column: blacks[i].minColumn };\n        const id = blacks[i].id;\n        const surface = blacks[i].surface;\n        const blackRoi = new Roi(map, id, width, height, origin, surface);\n        roiMapManager.blackRois[i] = blackRoi;\n    }\n    for (let i = 0; i < map.nbPositive; i++) {\n        const width = whites[i].maxColumn - whites[i].minColumn + 1;\n        const height = whites[i].maxRow - whites[i].minRow + 1;\n        const origin = { row: whites[i].minRow, column: whites[i].minColumn };\n        const id = whites[i].id;\n        const surface = whites[i].surface;\n        const whiteRoi = new Roi(map, id, width, height, origin, surface);\n        roiMapManager.whiteRois[i] = whiteRoi;\n    }\n}\n//# sourceMappingURL=computeRois.js.map","import { match } from 'ts-pattern';\nimport { computeRois } from './computeRois.js';\nexport const RoiKind = {\n    BLACK: 'black',\n    WHITE: 'white',\n    BW: 'bw',\n};\n/**\n * Return an array of ROIs matching the options.\n * @param roiMapManager - The ROI map manager containing the ROIs.\n * @param options - Get ROIs options.\n * @returns The array of ROIs.\n */\nexport function getRois(roiMapManager, options = {}) {\n    const { minSurface = 0, maxSurface = Number.MAX_SAFE_INTEGER, kind = 'white', } = options;\n    if (roiMapManager.blackRois.length === 0 &&\n        roiMapManager.whiteRois.length === 0) {\n        computeRois(roiMapManager);\n    }\n    const rois = match(kind)\n        .with('black', () => roiMapManager.blackRois)\n        .with('white', () => roiMapManager.whiteRois)\n        .with('bw', () => [...roiMapManager.whiteRois, ...roiMapManager.blackRois])\n        .exhaustive();\n    return rois.filter((roi) => roi.surface >= minSurface && roi.surface <= maxSurface);\n}\n//# sourceMappingURL=getRois.js.map","import { Matrix } from 'ml-matrix';\nimport { fromMask } from './fromMask.js';\nimport { getRois } from './getRois.js';\nexport class RoiMapManager {\n    map;\n    whiteRois;\n    blackRois;\n    constructor(map) {\n        this.map = map;\n        this.whiteRois = [];\n        this.blackRois = [];\n    }\n    /**\n     * Return the ROI map of the RoiMapManager.\n     * @returns - The ROI map.\n     */\n    getMap() {\n        return this.map;\n    }\n    /**\n     * Return the value at the given coordinates in an ROI map.\n     * @param column - Column of the value.\n     * @param row - Row of the value.\n     * @returns The value at the given coordinates.\n     */\n    getMapValue(column, row) {\n        return this.map.data[this.map.width * row + column];\n    }\n    /**\n     * Returns the ROI map as a correct width and height matrix.\n     * @returns The ROI map matrix.\n     */\n    getMapMatrix() {\n        return Matrix.from1DArray(this.map.height, this.map.width, this.map.data).to2DArray();\n    }\n    getRois(options = {}) {\n        return getRois(this, options);\n    }\n    getRoiById(roiID) {\n        const rois = this.getRois({ kind: 'bw' });\n        const foundRoi = rois.find((roi) => roi.id === roiID);\n        if (!foundRoi) {\n            throw new Error(`invalid ID: ${roiID}`);\n        }\n        return foundRoi;\n    }\n    static fromMask(mask, options = {}) {\n        return fromMask(mask, options);\n    }\n}\n//# sourceMappingURL=RoiMapManager.js.map","import { assert } from '../utils/validators/assert.js';\nimport { RoiMapManager } from './RoiMapManager.js';\n/**\n * Extract the ROIs of an image.\n * @param mask - Mask to extract the ROIs from.\n * @param options - From mask options.\n * @returns The corresponding ROI manager.\n */\nexport function fromMask(mask, options = {}) {\n    const { allowCorners = false } = options;\n    const MAX_TODO_ARRAY_FILTER = 65535; // 65535 should be enough for most of the cases\n    const MAX_POSITIVE_ID = 2 ** 31 - 1;\n    const MAX_NEGATIVE_ID = -(2 ** 31 - 1);\n    // based on a binary image we will create plenty of small images\n    const data = new Int32Array(mask.size); // maxValue: maxPositiveId, minValue: maxNegativeId\n    // split will always return an array of images\n    let positiveId = 0;\n    let negativeId = 0;\n    const columnToProcess = new Uint16Array(MAX_TODO_ARRAY_FILTER + 1);\n    const rowToProcess = new Uint16Array(MAX_TODO_ARRAY_FILTER + 1);\n    for (let column = 0; column < mask.width; column++) {\n        for (let row = 0; row < mask.height; row++) {\n            if (data[row * mask.width + column] === 0) {\n                // need to process the whole surface\n                analyseSurface(column, row);\n            }\n        }\n    }\n    // x column\n    // y row\n    function analyseSurface(column, row) {\n        let from = 0;\n        let to = 0;\n        const targetState = mask.getBit(column, row);\n        const id = targetState ? ++positiveId : --negativeId;\n        assert(positiveId <= MAX_POSITIVE_ID && negativeId >= MAX_NEGATIVE_ID, 'too many regions of interest');\n        columnToProcess[0] = column;\n        rowToProcess[0] = row;\n        while (from <= to) {\n            const currentColumn = columnToProcess[from & MAX_TODO_ARRAY_FILTER];\n            const currentRow = rowToProcess[from & MAX_TODO_ARRAY_FILTER];\n            data[currentRow * mask.width + currentColumn] = id;\n            // need to check all around mask pixel\n            if (currentColumn > 0 &&\n                data[currentRow * mask.width + currentColumn - 1] === 0 &&\n                mask.getBit(currentColumn - 1, currentRow) === targetState) {\n                // LEFT\n                to++;\n                columnToProcess[to & MAX_TODO_ARRAY_FILTER] = currentColumn - 1;\n                rowToProcess[to & MAX_TODO_ARRAY_FILTER] = currentRow;\n                data[currentRow * mask.width + currentColumn - 1] = MAX_NEGATIVE_ID;\n            }\n            if (currentRow > 0 &&\n                data[(currentRow - 1) * mask.width + currentColumn] === 0 &&\n                mask.getBit(currentColumn, currentRow - 1) === targetState) {\n                // TOP\n                to++;\n                columnToProcess[to & MAX_TODO_ARRAY_FILTER] = currentColumn;\n                rowToProcess[to & MAX_TODO_ARRAY_FILTER] = currentRow - 1;\n                data[(currentRow - 1) * mask.width + currentColumn] = MAX_NEGATIVE_ID;\n            }\n            if (currentColumn < mask.width - 1 &&\n                data[currentRow * mask.width + currentColumn + 1] === 0 &&\n                mask.getBit(currentColumn + 1, currentRow) === targetState) {\n                // RIGHT\n                to++;\n                columnToProcess[to & MAX_TODO_ARRAY_FILTER] = currentColumn + 1;\n                rowToProcess[to & MAX_TODO_ARRAY_FILTER] = currentRow;\n                data[currentRow * mask.width + currentColumn + 1] = MAX_NEGATIVE_ID;\n            }\n            if (currentRow < mask.height - 1 &&\n                data[(currentRow + 1) * mask.width + currentColumn] === 0 &&\n                mask.getBit(currentColumn, currentRow + 1) === targetState) {\n                // BOTTOM\n                to++;\n                columnToProcess[to & MAX_TODO_ARRAY_FILTER] = currentColumn;\n                rowToProcess[to & MAX_TODO_ARRAY_FILTER] = currentRow + 1;\n                data[(currentRow + 1) * mask.width + currentColumn] = MAX_NEGATIVE_ID;\n            }\n            if (allowCorners) {\n                if (currentColumn > 0 &&\n                    currentRow > 0 &&\n                    data[(currentRow - 1) * mask.width + currentColumn - 1] === 0 &&\n                    mask.getBit(currentColumn - 1, currentRow - 1) === targetState) {\n                    // TOP LEFT\n                    to++;\n                    columnToProcess[to & MAX_TODO_ARRAY_FILTER] = currentColumn - 1;\n                    rowToProcess[to & MAX_TODO_ARRAY_FILTER] = currentRow - 1;\n                    data[(currentRow - 1) * mask.width + currentColumn - 1] =\n                        MAX_NEGATIVE_ID;\n                }\n                if (currentColumn < mask.width - 1 &&\n                    currentRow > 0 &&\n                    data[(currentRow - 1) * mask.width + currentColumn + 1] === 0 &&\n                    mask.getBit(currentColumn + 1, currentRow - 1) === targetState) {\n                    // TOP RIGHT\n                    to++;\n                    columnToProcess[to & MAX_TODO_ARRAY_FILTER] = currentColumn + 1;\n                    rowToProcess[to & MAX_TODO_ARRAY_FILTER] = currentRow - 1;\n                    data[(currentRow - 1) * mask.width + currentColumn + 1] =\n                        MAX_NEGATIVE_ID;\n                }\n                if (currentColumn > 0 &&\n                    currentRow < mask.height - 1 &&\n                    data[(currentRow + 1) * mask.width + currentColumn - 1] === 0 &&\n                    mask.getBit(currentColumn - 1, currentRow + 1) === targetState) {\n                    // BOTTOM LEFT\n                    to++;\n                    columnToProcess[to & MAX_TODO_ARRAY_FILTER] = currentColumn - 1;\n                    rowToProcess[to & MAX_TODO_ARRAY_FILTER] = currentRow + 1;\n                    data[(currentRow + 1) * mask.width + currentColumn - 1] =\n                        MAX_NEGATIVE_ID;\n                }\n                if (currentColumn < mask.width - 1 &&\n                    currentRow < mask.height - 1 &&\n                    data[(currentRow + 1) * mask.width + currentColumn + 1] === 0 &&\n                    mask.getBit(currentColumn + 1, currentRow + 1) === targetState) {\n                    // BOTTOM RIGHT\n                    to++;\n                    columnToProcess[to & MAX_TODO_ARRAY_FILTER] = currentColumn + 1;\n                    rowToProcess[to & MAX_TODO_ARRAY_FILTER] = currentRow + 1;\n                    data[(currentRow + 1) * mask.width + currentColumn + 1] =\n                        MAX_NEGATIVE_ID;\n                }\n            }\n            from++;\n            assert(to - from <= MAX_TODO_ARRAY_FILTER, 'fromMask can not finish, the array to manage internal data is not big enough.' +\n                'You could improve mask by changing MAX_ARRAY');\n        }\n    }\n    return new RoiMapManager({\n        width: mask.width,\n        height: mask.height,\n        data,\n        nbNegative: Math.abs(negativeId),\n        nbPositive: positiveId,\n    });\n}\n//# sourceMappingURL=fromMask.js.map","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.PriorityQueue = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\nvar AbstractPriorityQueue, ArrayStrategy, BHeapStrategy, BinaryHeapStrategy, PriorityQueue,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nAbstractPriorityQueue = _dereq_('./PriorityQueue/AbstractPriorityQueue');\n\nArrayStrategy = _dereq_('./PriorityQueue/ArrayStrategy');\n\nBinaryHeapStrategy = _dereq_('./PriorityQueue/BinaryHeapStrategy');\n\nBHeapStrategy = _dereq_('./PriorityQueue/BHeapStrategy');\n\nPriorityQueue = (function(superClass) {\n  extend(PriorityQueue, superClass);\n\n  function PriorityQueue(options) {\n    options || (options = {});\n    options.strategy || (options.strategy = BinaryHeapStrategy);\n    options.comparator || (options.comparator = function(a, b) {\n      return (a || 0) - (b || 0);\n    });\n    PriorityQueue.__super__.constructor.call(this, options);\n  }\n\n  return PriorityQueue;\n\n})(AbstractPriorityQueue);\n\nPriorityQueue.ArrayStrategy = ArrayStrategy;\n\nPriorityQueue.BinaryHeapStrategy = BinaryHeapStrategy;\n\nPriorityQueue.BHeapStrategy = BHeapStrategy;\n\nmodule.exports = PriorityQueue;\n\n\n},{\"./PriorityQueue/AbstractPriorityQueue\":2,\"./PriorityQueue/ArrayStrategy\":3,\"./PriorityQueue/BHeapStrategy\":4,\"./PriorityQueue/BinaryHeapStrategy\":5}],2:[function(_dereq_,module,exports){\nvar AbstractPriorityQueue;\n\nmodule.exports = AbstractPriorityQueue = (function() {\n  function AbstractPriorityQueue(options) {\n    var ref;\n    if ((options != null ? options.strategy : void 0) == null) {\n      throw 'Must pass options.strategy, a strategy';\n    }\n    if ((options != null ? options.comparator : void 0) == null) {\n      throw 'Must pass options.comparator, a comparator';\n    }\n    this.priv = new options.strategy(options);\n    this.length = (options != null ? (ref = options.initialValues) != null ? ref.length : void 0 : void 0) || 0;\n  }\n\n  AbstractPriorityQueue.prototype.queue = function(value) {\n    this.length++;\n    this.priv.queue(value);\n    return void 0;\n  };\n\n  AbstractPriorityQueue.prototype.dequeue = function(value) {\n    if (!this.length) {\n      throw 'Empty queue';\n    }\n    this.length--;\n    return this.priv.dequeue();\n  };\n\n  AbstractPriorityQueue.prototype.peek = function(value) {\n    if (!this.length) {\n      throw 'Empty queue';\n    }\n    return this.priv.peek();\n  };\n\n  AbstractPriorityQueue.prototype.clear = function() {\n    this.length = 0;\n    return this.priv.clear();\n  };\n\n  return AbstractPriorityQueue;\n\n})();\n\n\n},{}],3:[function(_dereq_,module,exports){\nvar ArrayStrategy, binarySearchForIndexReversed;\n\nbinarySearchForIndexReversed = function(array, value, comparator) {\n  var high, low, mid;\n  low = 0;\n  high = array.length;\n  while (low < high) {\n    mid = (low + high) >>> 1;\n    if (comparator(array[mid], value) >= 0) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return low;\n};\n\nmodule.exports = ArrayStrategy = (function() {\n  function ArrayStrategy(options) {\n    var ref;\n    this.options = options;\n    this.comparator = this.options.comparator;\n    this.data = ((ref = this.options.initialValues) != null ? ref.slice(0) : void 0) || [];\n    this.data.sort(this.comparator).reverse();\n  }\n\n  ArrayStrategy.prototype.queue = function(value) {\n    var pos;\n    pos = binarySearchForIndexReversed(this.data, value, this.comparator);\n    this.data.splice(pos, 0, value);\n    return void 0;\n  };\n\n  ArrayStrategy.prototype.dequeue = function() {\n    return this.data.pop();\n  };\n\n  ArrayStrategy.prototype.peek = function() {\n    return this.data[this.data.length - 1];\n  };\n\n  ArrayStrategy.prototype.clear = function() {\n    this.data.length = 0;\n    return void 0;\n  };\n\n  return ArrayStrategy;\n\n})();\n\n\n},{}],4:[function(_dereq_,module,exports){\nvar BHeapStrategy;\n\nmodule.exports = BHeapStrategy = (function() {\n  function BHeapStrategy(options) {\n    var arr, i, j, k, len, ref, ref1, shift, value;\n    this.comparator = (options != null ? options.comparator : void 0) || function(a, b) {\n      return a - b;\n    };\n    this.pageSize = (options != null ? options.pageSize : void 0) || 512;\n    this.length = 0;\n    shift = 0;\n    while ((1 << shift) < this.pageSize) {\n      shift += 1;\n    }\n    if (1 << shift !== this.pageSize) {\n      throw 'pageSize must be a power of two';\n    }\n    this._shift = shift;\n    this._emptyMemoryPageTemplate = arr = [];\n    for (i = j = 0, ref = this.pageSize; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n      arr.push(null);\n    }\n    this._memory = [];\n    this._mask = this.pageSize - 1;\n    if (options.initialValues) {\n      ref1 = options.initialValues;\n      for (k = 0, len = ref1.length; k < len; k++) {\n        value = ref1[k];\n        this.queue(value);\n      }\n    }\n  }\n\n  BHeapStrategy.prototype.queue = function(value) {\n    this.length += 1;\n    this._write(this.length, value);\n    this._bubbleUp(this.length, value);\n    return void 0;\n  };\n\n  BHeapStrategy.prototype.dequeue = function() {\n    var ret, val;\n    ret = this._read(1);\n    val = this._read(this.length);\n    this.length -= 1;\n    if (this.length > 0) {\n      this._write(1, val);\n      this._bubbleDown(1, val);\n    }\n    return ret;\n  };\n\n  BHeapStrategy.prototype.peek = function() {\n    return this._read(1);\n  };\n\n  BHeapStrategy.prototype.clear = function() {\n    this.length = 0;\n    this._memory.length = 0;\n    return void 0;\n  };\n\n  BHeapStrategy.prototype._write = function(index, value) {\n    var page;\n    page = index >> this._shift;\n    while (page >= this._memory.length) {\n      this._memory.push(this._emptyMemoryPageTemplate.slice(0));\n    }\n    return this._memory[page][index & this._mask] = value;\n  };\n\n  BHeapStrategy.prototype._read = function(index) {\n    return this._memory[index >> this._shift][index & this._mask];\n  };\n\n  BHeapStrategy.prototype._bubbleUp = function(index, value) {\n    var compare, indexInPage, parentIndex, parentValue;\n    compare = this.comparator;\n    while (index > 1) {\n      indexInPage = index & this._mask;\n      if (index < this.pageSize || indexInPage > 3) {\n        parentIndex = (index & ~this._mask) | (indexInPage >> 1);\n      } else if (indexInPage < 2) {\n        parentIndex = (index - this.pageSize) >> this._shift;\n        parentIndex += parentIndex & ~(this._mask >> 1);\n        parentIndex |= this.pageSize >> 1;\n      } else {\n        parentIndex = index - 2;\n      }\n      parentValue = this._read(parentIndex);\n      if (compare(parentValue, value) < 0) {\n        break;\n      }\n      this._write(parentIndex, value);\n      this._write(index, parentValue);\n      index = parentIndex;\n    }\n    return void 0;\n  };\n\n  BHeapStrategy.prototype._bubbleDown = function(index, value) {\n    var childIndex1, childIndex2, childValue1, childValue2, compare;\n    compare = this.comparator;\n    while (index < this.length) {\n      if (index > this._mask && !(index & (this._mask - 1))) {\n        childIndex1 = childIndex2 = index + 2;\n      } else if (index & (this.pageSize >> 1)) {\n        childIndex1 = (index & ~this._mask) >> 1;\n        childIndex1 |= index & (this._mask >> 1);\n        childIndex1 = (childIndex1 + 1) << this._shift;\n        childIndex2 = childIndex1 + 1;\n      } else {\n        childIndex1 = index + (index & this._mask);\n        childIndex2 = childIndex1 + 1;\n      }\n      if (childIndex1 !== childIndex2 && childIndex2 <= this.length) {\n        childValue1 = this._read(childIndex1);\n        childValue2 = this._read(childIndex2);\n        if (compare(childValue1, value) < 0 && compare(childValue1, childValue2) <= 0) {\n          this._write(childIndex1, value);\n          this._write(index, childValue1);\n          index = childIndex1;\n        } else if (compare(childValue2, value) < 0) {\n          this._write(childIndex2, value);\n          this._write(index, childValue2);\n          index = childIndex2;\n        } else {\n          break;\n        }\n      } else if (childIndex1 <= this.length) {\n        childValue1 = this._read(childIndex1);\n        if (compare(childValue1, value) < 0) {\n          this._write(childIndex1, value);\n          this._write(index, childValue1);\n          index = childIndex1;\n        } else {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n    return void 0;\n  };\n\n  return BHeapStrategy;\n\n})();\n\n\n},{}],5:[function(_dereq_,module,exports){\nvar BinaryHeapStrategy;\n\nmodule.exports = BinaryHeapStrategy = (function() {\n  function BinaryHeapStrategy(options) {\n    var ref;\n    this.comparator = (options != null ? options.comparator : void 0) || function(a, b) {\n      return a - b;\n    };\n    this.length = 0;\n    this.data = ((ref = options.initialValues) != null ? ref.slice(0) : void 0) || [];\n    this._heapify();\n  }\n\n  BinaryHeapStrategy.prototype._heapify = function() {\n    var i, j, ref;\n    if (this.data.length > 0) {\n      for (i = j = 1, ref = this.data.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {\n        this._bubbleUp(i);\n      }\n    }\n    return void 0;\n  };\n\n  BinaryHeapStrategy.prototype.queue = function(value) {\n    this.data.push(value);\n    this._bubbleUp(this.data.length - 1);\n    return void 0;\n  };\n\n  BinaryHeapStrategy.prototype.dequeue = function() {\n    var last, ret;\n    ret = this.data[0];\n    last = this.data.pop();\n    if (this.data.length > 0) {\n      this.data[0] = last;\n      this._bubbleDown(0);\n    }\n    return ret;\n  };\n\n  BinaryHeapStrategy.prototype.peek = function() {\n    return this.data[0];\n  };\n\n  BinaryHeapStrategy.prototype.clear = function() {\n    this.length = 0;\n    this.data.length = 0;\n    return void 0;\n  };\n\n  BinaryHeapStrategy.prototype._bubbleUp = function(pos) {\n    var parent, x;\n    while (pos > 0) {\n      parent = (pos - 1) >>> 1;\n      if (this.comparator(this.data[pos], this.data[parent]) < 0) {\n        x = this.data[parent];\n        this.data[parent] = this.data[pos];\n        this.data[pos] = x;\n        pos = parent;\n      } else {\n        break;\n      }\n    }\n    return void 0;\n  };\n\n  BinaryHeapStrategy.prototype._bubbleDown = function(pos) {\n    var last, left, minIndex, right, x;\n    last = this.data.length - 1;\n    while (true) {\n      left = (pos << 1) + 1;\n      right = left + 1;\n      minIndex = pos;\n      if (left <= last && this.comparator(this.data[left], this.data[minIndex]) < 0) {\n        minIndex = left;\n      }\n      if (right <= last && this.comparator(this.data[right], this.data[minIndex]) < 0) {\n        minIndex = right;\n      }\n      if (minIndex !== pos) {\n        x = this.data[minIndex];\n        this.data[minIndex] = this.data[pos];\n        this.data[pos] = x;\n        pos = minIndex;\n      } else {\n        break;\n      }\n    }\n    return void 0;\n  };\n\n  return BinaryHeapStrategy;\n\n})();\n\n\n},{}]},{},[1])(1)\n});","import PriorityQueue from 'js-priority-queue';\nimport { getExtrema } from '../compute/index.js';\nimport checkProcessable from '../utils/validators/checkProcessable.js';\nimport { RoiMapManager } from './RoiMapManager.js';\n/**\n * This method allows to create a ROIMap using the water shed algorithm. By default this algorithm\n * will fill the holes and therefore the lowest value of the image (black zones).\n * If no points are given, the function will look for all the minimal points.\n * If no mask is given the algorithm will completely fill the image.\n * Please take care about the value that has be in the mask ! In order to be coherent with the expected mask,\n * meaning that if it is a dark zone, the mask will be dark the normal behavior to fill a zone\n * is that the mask pixel is clear (value of 0) !\n * If you are looking for 'maxima' the image must be inverted before applying the algorithm\n * @param image - Image that the filter will be applied to.\n * @param options - WaterShedOptions\n * @returns RoiMapManager\n */\nexport function waterShed(image, options) {\n    let { points } = options;\n    const { mask, threshold = 1 } = options;\n    const currentImage = image;\n    checkProcessable(image, {\n        bitDepth: [8, 16],\n        components: 1,\n    });\n    const fillMaxValue = threshold * image.maxValue;\n    // WaterShed is done from points in the image. We can either specify those points in options,\n    // or it is gonna take the minimum locals of the image by default.\n    if (!points) {\n        points = getExtrema(image, {\n            kind: 'minimum',\n            mask,\n        });\n    }\n    const maskExpectedValue = 0;\n    const data = new Int32Array(currentImage.size);\n    const width = currentImage.width;\n    const height = currentImage.height;\n    const toProcess = new PriorityQueue({\n        comparator: (a, b) => a.intensity - b.intensity,\n        strategy: PriorityQueue.BinaryHeapStrategy,\n    });\n    for (let i = 0; i < points.length; i++) {\n        const index = points[i].column + points[i].row * width;\n        data[index] = -i - 1;\n        const intensity = currentImage.getValueByIndex(index, 0);\n        if (intensity <= fillMaxValue) {\n            toProcess.queue({\n                column: points[i].column,\n                row: points[i].row,\n                intensity,\n            });\n        }\n    }\n    const dxs = [1, 0, -1, 0, 1, 1, -1, -1];\n    const dys = [0, 1, 0, -1, 1, -1, 1, -1];\n    // Then we iterate through each points\n    while (toProcess.length > 0) {\n        const currentPoint = toProcess.dequeue();\n        const currentValueIndex = currentPoint.column + currentPoint.row * width;\n        for (let dir = 0; dir < 4; dir++) {\n            const newX = currentPoint.column + dxs[dir];\n            const newY = currentPoint.row + dys[dir];\n            if (newX >= 0 && newY >= 0 && newX < width && newY < height) {\n                const currentNeighbourIndex = newX + newY * width;\n                if (!mask ||\n                    mask.getBitByIndex(currentNeighbourIndex) === maskExpectedValue) {\n                    const intensity = currentImage.getValueByIndex(currentNeighbourIndex, 0);\n                    if (intensity <= fillMaxValue && data[currentNeighbourIndex] === 0) {\n                        data[currentNeighbourIndex] = data[currentValueIndex];\n                        toProcess.queue({\n                            column: currentPoint.column + dxs[dir],\n                            row: currentPoint.row + dys[dir],\n                            intensity,\n                        });\n                    }\n                }\n            }\n        }\n    }\n    const nbNegative = points.length;\n    const nbPositive = 0;\n    return new RoiMapManager({\n        data,\n        nbPositive,\n        nbNegative,\n        width: image.width,\n        height: image.height,\n    });\n}\n//# sourceMappingURL=waterShed.js.map","import { format } from '../../utils/validators/checkProcessable.js';\n/**\n * This method checks if a process can be applied on the stack.\n * @param stack - Stack to verify.\n * @param options - Check processable options.\n */\nexport function checkProcessable(stack, options = {}) {\n    const { sameDimensions = false, alpha } = options;\n    let { bitDepth } = options;\n    if (sameDimensions) {\n        const width = stack.getImage(0).width;\n        const height = stack.getImage(0).height;\n        for (let i = 1; i < stack.size; i++) {\n            const currentImage = stack.getImage(i);\n            if (currentImage.width !== width || currentImage.height !== height) {\n                throw new RangeError(`images must all have same dimensions to apply this algorithm`);\n            }\n        }\n    }\n    if (alpha !== undefined && alpha !== stack.alpha) {\n        throw new RangeError(`stack images ${alpha ? 'should' : 'should not'} have an alpha channel to apply this algorithm`);\n    }\n    if (bitDepth) {\n        if (!Array.isArray(bitDepth)) {\n            bitDepth = [bitDepth];\n        }\n        if (!bitDepth.includes(stack.bitDepth)) {\n            throw new RangeError(`image bitDepth must be ${format(bitDepth)} to apply this algorithm`);\n        }\n    }\n}\n//# sourceMappingURL=checkProcessable.js.map","import { checkProcessable } from '../utils/checkProcessable.js';\n/**\n * Get the sum of all the histograms of the stack's images. If no channel is specified in the options, the images must be GREY.\n * @param stack - Stack to process.\n * @param options - Histogram options.\n * @returns The histogram of the stack.\n */\nexport function histogram(stack, options) {\n    checkProcessable(stack, { bitDepth: [8, 16] });\n    const { slots = 2 ** stack.bitDepth, channel = 0 } = options;\n    const result = new Uint32Array(slots);\n    for (let i = 0; i < stack.size; i++) {\n        const image = stack.getImage(i);\n        const histogram = image.histogram({ channel, slots });\n        for (const [index, value] of histogram.entries()) {\n            result[index] += value;\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=histogram.js.map","import { Image } from '../../Image.js';\nimport { checkProcessable } from '../utils/checkProcessable.js';\n/**\n *  Returns a new image with the maximum values of each pixel from the stack.\n * @param stack - Stack to process.\n * @returns The maximum image.\n */\nexport function maxImage(stack) {\n    checkProcessable(stack, { sameDimensions: true });\n    const newImage = Image.createFrom(stack.getImage(0));\n    const nbChannels = newImage.channels;\n    for (let i = 0; i < stack.size; i++) {\n        for (let j = 0; j < newImage.size; j++) {\n            for (let channel = 0; channel < nbChannels; channel++) {\n                newImage.setValueByIndex(j, channel, Math.max(newImage.getValueByIndex(j, channel), stack.getValueByIndex(i, j, channel)));\n            }\n        }\n    }\n    return newImage;\n}\n//# sourceMappingURL=maxImage.js.map","import { Image } from '../../Image.js';\nimport { checkProcessable } from '../utils/checkProcessable.js';\n/**\n *  Returns a new image with the average values of each pixel of the images of the stack.\n * @param stack - Stack to process.\n * @returns The mean image.\n */\nexport function meanImage(stack) {\n    checkProcessable(stack, { sameDimensions: true, bitDepth: [8, 16] });\n    const image = stack.getImage(0);\n    const dataSize = image.size * stack.channels;\n    const sum = new Uint32Array(dataSize).fill(0);\n    for (let i = 0; i < stack.size; i++) {\n        for (let j = 0; j < image.size; j++) {\n            for (let channel = 0; channel < stack.channels; channel++) {\n                sum[j * stack.channels + channel] += stack.getValueByIndex(i, j, channel);\n            }\n        }\n    }\n    const meanImage = Image.createFrom(image);\n    for (let i = 0; i < image.size; i++) {\n        for (let channel = 0; channel < stack.channels; channel++) {\n            const index = i * stack.channels + channel;\n            meanImage.setValueByIndex(i, channel, sum[index] / stack.size);\n        }\n    }\n    return meanImage;\n}\n//# sourceMappingURL=meanImage.js.map","// @ts-expect-error: median-quisckselect has no types\nimport quickMedian from 'median-quickselect';\nimport { Image } from '../../Image.js';\nimport { checkProcessable } from '../utils/checkProcessable.js';\n/**\n *  Returns a new image with the median values of each pixel of the images of the stack.\n * @param stack - Stack to process.\n * @returns The median image.\n */\nexport function medianImage(stack) {\n    checkProcessable(stack, { sameDimensions: true, bitDepth: [8, 16] });\n    const image = stack.getImage(0);\n    const result = Image.createFrom(image);\n    for (let j = 0; j < image.size; j++) {\n        for (let channel = 0; channel < stack.channels; channel++) {\n            const currentValues = new Array(stack.size);\n            for (let i = 0; i < stack.size; i++) {\n                currentValues[i] = stack.getValueByIndex(i, j, channel);\n            }\n            result.setValueByIndex(j, channel, quickMedian(currentValues));\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=medianImage.js.map","import { decodeApng } from 'fast-png';\nimport { Image } from \"../../Image.js\";\nimport { Stack } from \"../../Stack.js\";\n/**\n * Decodes APNG image into a Stack\n * @param data - APNG data.\n * @returns stack of frames.\n */\nexport function decodeStackFromApng(data) {\n    const decodedApng = decodeApng(data);\n    const images = [];\n    let colorModel;\n    switch (decodedApng.channels) {\n        case 1:\n            if (decodedApng.palette) {\n                colorModel = decodedApng.palette[0].length === 3 ? 'RGB' : 'RGBA';\n            }\n            else {\n                colorModel = 'GREY';\n            }\n            break;\n        case 2:\n            colorModel = 'GREYA';\n            break;\n        case 3:\n            colorModel = 'RGB';\n            break;\n        default:\n            colorModel = 'RGBA';\n            break;\n    }\n    if (decodedApng.palette) {\n        for (const image of decodedApng.frames) {\n            images.push(new Image(decodedApng.width, decodedApng.height, {\n                data: convertIndexedData(image.data, decodedApng.palette),\n                colorModel,\n            }));\n        }\n    }\n    else {\n        for (const image of decodedApng.frames) {\n            images.push(new Image(decodedApng.width, decodedApng.height, {\n                data: image.data,\n                colorModel,\n            }));\n        }\n    }\n    const stack = new Stack(images);\n    return stack;\n}\nfunction convertIndexedData(data, palette) {\n    const result = new Uint8Array(data.length * palette[0].length);\n    for (let i = 0; i < data.length; i++) {\n        for (let channel = 0; channel < palette[0].length; channel++) {\n            result[i * palette[0].length + channel] = palette[data[i]][channel];\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=decodeApng.js.map","import { decode } from 'tiff';\nimport { Stack } from '../../Stack.js';\nimport { getImageFromIFD } from '../../load/decodeTiff.js';\n/**\n * Decode a TIFF and create a stack of images.\n * @param buffer - The data to decode.\n * @returns The stack of images.\n */\nexport function decodeStackFromTiff(buffer) {\n    const decoded = decode(buffer);\n    const images = [];\n    for (const IFD of decoded) {\n        images.push(getImageFromIFD(IFD));\n    }\n    return new Stack(images);\n}\n//# sourceMappingURL=decodeTiff.js.map","import imageType from 'image-type';\nimport { match } from 'ts-pattern';\nimport { decodeStackFromApng } from \"./decodeApng.js\";\nimport { decodeStackFromTiff } from './decodeTiff.js';\n/**\n * Decode input data and create stack. Data format is automatically detected.\n * Possible formats: tiff.\n * @param data - Data to decode.\n * @returns The decoded image.\n */\nexport function decodeStack(data) {\n    const typedArray = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n    const type = imageType(typedArray);\n    return match(type)\n        .with({ mime: 'image/tiff' }, () => decodeStackFromTiff(typedArray))\n        .with({ mime: 'image/png' }, () => decodeStackFromApng(typedArray))\n        .otherwise(() => {\n        throw new RangeError(`invalid data format: ${type?.mime}`);\n    });\n}\n//# sourceMappingURL=decodeStack.js.map","import { Image } from '../../Image.js';\nimport { checkProcessable } from '../utils/checkProcessable.js';\n/**\n *  Returns a new image with the minimum values of each pixel from the stack.\n * @param stack - Stack to process.\n * @returns The minimum image.\n */\nexport function minImage(stack) {\n    checkProcessable(stack, { sameDimensions: true });\n    const newImage = Image.createFrom(stack.getImage(0));\n    newImage.fill(newImage.maxValue);\n    const nbChannels = newImage.channels;\n    for (let i = 0; i < stack.size; i++) {\n        for (let j = 0; j < newImage.size; j++) {\n            for (let channel = 0; channel < nbChannels; channel++) {\n                newImage.setValueByIndex(j, channel, Math.min(newImage.getValueByIndex(j, channel), stack.getValueByIndex(i, j, channel)));\n            }\n        }\n    }\n    return newImage;\n}\n//# sourceMappingURL=minImage.js.map","import { Image } from '../../Image.js';\nimport { checkProcessable } from '../utils/checkProcessable.js';\n/**\n *  Returns a new 16 bits depth image with the sum of each pixel of the images of the stack.\n * @param stack - Stack to process.\n * @returns The sum image.\n */\nexport function sum(stack) {\n    checkProcessable(stack, { sameDimensions: true, bitDepth: 8 });\n    // Because 255*257 = 2**16 - 1\n    if (stack.size > 257) {\n        throw new Error('Maximal valid stack size is 257');\n    }\n    const image = stack.getImage(0);\n    const dataSize = image.size * stack.channels;\n    const sum = new Uint16Array(dataSize).fill(0);\n    for (let i = 0; i < stack.size; i++) {\n        for (let j = 0; j < image.size; j++) {\n            for (let channel = 0; channel < stack.channels; channel++) {\n                sum[j * stack.channels + channel] += stack.getValueByIndex(i, j, channel);\n            }\n        }\n    }\n    return new Image(image.width, image.height, {\n        data: sum,\n        colorModel: stack.colorModel,\n        bitDepth: 16,\n    });\n}\n//# sourceMappingURL=sum.js.map","/**\n * Verify all images of array have the same bit depth and color model.\n * @param images - Images to process\n */\nexport function checkImagesValid(images) {\n    const colorModel = images[0].colorModel;\n    const bitDepth = images[0].bitDepth;\n    for (const image of images) {\n        if (image.colorModel !== colorModel || image.bitDepth !== bitDepth) {\n            throw new RangeError(`images must all have the same bit depth and color model`);\n        }\n    }\n}\n/**\n * Checks if all the images of an array are the same dimensions.\n * @param images - Images array.\n * @returns `true` if all images have the same dimensions.\n */\nexport function verifySameDimensions(images) {\n    const width = images[0].width;\n    const height = images[0].height;\n    for (const image of images) {\n        if (image.width !== width || image.height !== height) {\n            return false;\n        }\n    }\n    return true;\n}\n//# sourceMappingURL=checkImagesValid.js.map","import { histogram, maxImage, meanImage, medianImage, minImage, sum, } from './stack/index.js';\nimport { checkImagesValid, verifySameDimensions, } from './stack/utils/checkImagesValid.js';\nexport class Stack {\n    /**\n     * The array of images.\n     */\n    images;\n    /**\n     * The stack size.\n     */\n    size;\n    /**\n     * Do the images have an alpha channel?\n     */\n    alpha;\n    /**\n     * The color model of the images.\n     */\n    colorModel;\n    /**\n     * The bit depth of the images.\n     */\n    bitDepth;\n    /**\n     * Whether all the images of the stack have the same dimensions.\n     */\n    sameDimensions;\n    /**\n     * The number of channels of the images.\n     */\n    channels;\n    /**\n     * Create a new stack from an array of images.\n     * The images must have the same bit depth and color model.\n     * @param images - Array of images from which to create the stack.\n     */\n    constructor(images) {\n        checkImagesValid(images);\n        this.images = images;\n        this.size = images.length;\n        this.alpha = images[0].alpha;\n        this.colorModel = images[0].colorModel;\n        this.channels = images[0].channels;\n        this.bitDepth = images[0].bitDepth;\n        this.sameDimensions = verifySameDimensions(images);\n    }\n    *[Symbol.iterator]() {\n        for (const image of this.images) {\n            yield image;\n        }\n    }\n    /**\n     * Clone a stack. The images are a copy of the original images.\n     * @returns A new stack with the same images.\n     */\n    clone() {\n        return new Stack(this.images.map((image) => image.clone()));\n    }\n    /**\n     * Get the images of the stack. Mainly for debugging purposes.\n     * @returns The images.\n     */\n    getImages() {\n        return this.images;\n    }\n    /**\n     * Get the image at the given index.\n     * @param index - The index of the image.\n     * @returns The image.\n     */\n    getImage(index) {\n        return this.images[index];\n    }\n    /**\n     * Get a value from an image of the stack.\n     * @param stackIndex - Index of the image in the stack.\n     * @param row - Row index of the pixel.\n     * @param column - Column index of the pixel.\n     * @param channel - The channel to retrieve.\n     * @returns The value at the given position.\n     */\n    getValue(stackIndex, row, column, channel) {\n        return this.images[stackIndex].getValue(row, column, channel);\n    }\n    /**\n     * Get a value from an image of the stack. Specify the pixel position using its index.\n     * @param stackIndex - Index of the image in the stack.\n     * @param index - The index of the pixel.\n     * @param channel - The channel to retrieve.\n     * @returns The value at the given position.\n     */\n    getValueByIndex(stackIndex, index, channel) {\n        return this.images[stackIndex].getValueByIndex(index, channel);\n    }\n    /**\n     * Return the image containing the minimum values of all the images in the stack for\n     * each pixel. All the images must have the same dimensions.\n     * @returns The minimum image.\n     */\n    minImage() {\n        return minImage(this);\n    }\n    /**\n     * Return the image containing the maximum values of all the images in the stack for\n     * each pixel. All the images must have the same dimensions.\n     * @returns The maximum image.\n     */\n    maxImage() {\n        return maxImage(this);\n    }\n    /**\n     * Return the image containing the median values of all the images in the stack for\n     * each pixel. All the images must have the same dimensions.\n     * @returns The median image.\n     */\n    medianImage() {\n        return medianImage(this);\n    }\n    /**\n     * Return the image containing the average values of all the images in the stack for\n     * each pixel. All the images must have the same dimensions.\n     * @returns The mean image.\n     */\n    meanImage() {\n        return meanImage(this);\n    }\n    /**\n     * Return a 16 bits depth image containing the sum values of all the images in the stack for\n     * each pixel.\n     * @returns The sum image.\n     */\n    sum() {\n        return sum(this);\n    }\n    /**\n     * Get the sum of all the histograms of the stack's images. If no channel is specified in the options, the images must be GREY.\n     * @param options - Histogram options.\n     * @returns The histogram of the stack.\n     */\n    histogram(options = {}) {\n        return histogram(this, options);\n    }\n    /**\n     * Align all the images of the stack on the image at the given index.\n     * @param refIndex - The index of the reference image.\n     */\n    // public alignImages(refIndex: number): Stack {}\n    /**\n     * Map a function on all the images of the stack.\n     * @param callback - Function to apply on each image.\n     * @returns New stack with the modified images.\n     */\n    map(callback) {\n        return new Stack(this.images.map(callback));\n    }\n    /**\n     * Filter the images in the stack.\n     * @param callback - Function to decide which images to keep.\n     * @returns New filtered stack.\n     */\n    filter(callback) {\n        return new Stack(this.images.filter(callback));\n    }\n}\n//# sourceMappingURL=Stack.js.map","export const channelLabels = {\n    GREY: ['Grey'],\n    GREYA: ['Grey', 'Alpha'],\n    RGB: ['Red', 'Green', 'Blue'],\n    RGBA: ['Red', 'Green', 'Blue', 'Alpha'],\n    BINARY: ['Mask'],\n};\n//# sourceMappingURL=channelLabels.js.map","import { getCanvasContext } from \"../../utils/cross_platform.js\";\nimport { getOutputImage } from \"../../utils/getOutputImage.js\";\nimport { validateValues } from \"../../utils/validators/validators.js\";\n/**\n * Draws text on an image.\n * @param image - Image to write text on.\n * @param text - Text to write on the image.\n * @param options - Out Options\n * @returns Image with drawn text.\n */\nexport function drawText(image, text, options) {\n    if (Array.isArray(text) && text.length === 0) {\n        throw new Error('At least one text element must be provided');\n    }\n    const newImage = getOutputImage(image, options, { clone: true });\n    const defaultFont = options?.font ?? '12px Helvetica';\n    const defaultColor = options?.fontColor ?? [255, 255, 255, 255];\n    const ctx = getCanvasContext(image.width, image.height);\n    if (!Array.isArray(text)) {\n        drawTextElement(image, ctx, text, defaultFont, defaultColor);\n    }\n    else {\n        for (const label of text) {\n            drawTextElement(image, ctx, label, defaultFont, defaultColor);\n        }\n    }\n    layerCanvas(newImage.getRawImage().data, ctx.getImageData(0, 0, image.width, image.height).data, image.channels, image.bitDepth);\n    return newImage;\n}\nfunction drawTextElement(image, ctx, text, defaultFont, defaultColor) {\n    ctx.font = text.font ?? defaultFont;\n    const fontColor = text.fontColor ?? defaultColor;\n    validateValues(fontColor, image);\n    const alpha = fontColor[3] ? fontColor[3] / 255 : 1;\n    const normalizedColor = [\n        fontColor[0] ?? 0,\n        fontColor[1] ?? 0,\n        fontColor[2] ?? 0,\n        alpha,\n    ];\n    ctx.fillStyle = `rgba(${normalizedColor.join(',')})`;\n    ctx.fillText(String(text.content), text.position.column, text.position.row);\n}\n/**\n * Draws labels on the image data from canvas.\n * @param imageData - Image data to draw text on.\n * @param canvasData - Canvas data to draw on the image.\n * @param numberOfChannels - Number of channels of the initial image.\n * @param bitDepth - Bit depth of the initial image.\n */\nfunction layerCanvas(imageData, canvasData, numberOfChannels, bitDepth) {\n    const config = CHANNEL_CONFIGS[numberOfChannels] || CHANNEL_CONFIGS[1];\n    const pixelCount = canvasData.length >>> 2;\n    const bitShift = bitDepth - 8;\n    let imageIndex = 0;\n    let canvasIndex = 0;\n    for (let pixel = 0; pixel < pixelCount; pixel++) {\n        const canvasAlpha = canvasData[canvasIndex + 3] / 255;\n        // Skip transparent canvas pixels completely\n        if (canvasAlpha === 0) {\n            imageIndex += numberOfChannels;\n            canvasIndex += 4;\n            continue;\n        }\n        const invAlpha = 1 - canvasAlpha;\n        for (const channel of config.channelOffsets) {\n            const targetIndex = imageIndex + channel;\n            imageData[targetIndex] =\n                Math.round(canvasData[canvasIndex + channel] * canvasAlpha +\n                    imageData[targetIndex] * invAlpha) << bitShift;\n        }\n        if (config.hasAlpha) {\n            const alphaIndex = imageIndex + config.alphaOffset;\n            const imageAlpha = (imageData[alphaIndex] >>> bitShift) / 255;\n            const newAlpha = canvasAlpha + imageAlpha * (1 - canvasAlpha);\n            imageData[alphaIndex] = Math.round(newAlpha * 255) << bitShift;\n        }\n        imageIndex += numberOfChannels;\n        canvasIndex += 4;\n    }\n}\nconst CHANNEL_CONFIGS = {\n    // GREY\n    1: {\n        channelOffsets: [0],\n        hasAlpha: false,\n        alphaOffset: undefined,\n    },\n    // GREYA\n    2: {\n        channelOffsets: [0],\n        hasAlpha: true,\n        alphaOffset: 1,\n    },\n    3: {\n        // RGB\n        channelOffsets: [0, 1, 2],\n        hasAlpha: false,\n        alphaOffset: undefined,\n    },\n    4: {\n        // RGBA\n        channelOffsets: [0, 1, 2],\n        hasAlpha: true,\n        alphaOffset: 3,\n    },\n};\n//# sourceMappingURL=draw_text.js.map"],"names":["toString","Object","prototype","isAnyArray","value","tag","call","endsWith","includes","max","input","options","arguments","length","undefined","TypeError","_options$fromIndex","fromIndex","_options$toIndex","toIndex","Number","isInteger","Error","maxValue","i","min","minValue","rescale","output","Array","currentMin","currentMax","RangeError","_options$min","autoMinMax","_options$max","factor","defineProperty","matrix","require$$0","require$$1","indent","repeat","indentData","inspectMatrix","inspectMatrixWithOptions","this","maxRows","maxColumns","maxNumSize","padMinus","constructor","name","inspectData","rows","columns","maxI","Math","maxJ","result","loop","j","get","line","push","formatNumber","join","num","formatNumber2","padEnd","len","str","fix","toFixed","startsWith","exp","toExponential","slice","installMathOperations","AbstractMatrix","Matrix","add","addS","addM","set","checkMatrix","sub","subS","subM","subtract","subtractS","subtractM","mul","mulS","mulM","multiply","multiplyS","multiplyM","div","divS","divM","divide","divideS","divideM","mod","modS","modM","modulus","modulusS","modulusM","and","andS","andM","or","orS","orM","xor","xorS","xorM","leftShift","leftShiftS","leftShiftM","signPropagatingRightShift","signPropagatingRightShiftS","signPropagatingRightShiftM","rightShift","rightShiftS","rightShiftM","zeroFillRightShift","zeroFillRightShiftS","zeroFillRightShiftM","not","abs","acos","acosh","asin","asinh","atan","atanh","cbrt","ceil","clz32","cos","cosh","expm1","floor","fround","log","log1p","log10","log2","round","sign","sin","sinh","sqrt","tan","tanh","trunc","pow","arg0","powS","powM","checkRowIndex","index","outer","checkColumnIndex","checkRowVector","vector","to1DArray","checkColumnVector","checkRowIndices","rowIndices","checkColumnIndices","columnIndices","checkRange","startRow","endRow","startColumn","endColumn","checkNumber","newArray","array","checkNonEmpty","isEmpty","sumByRow","sum","sumByColumn","sumAll","v","productByRow","productByColumn","productAll","varianceByRow","unbiased","mean","cols","variance","sum1","sum2","x","varianceByColumn","varianceAll","size","centerByRow","centerByColumn","centerAll","getScaleByRow","scale","scaleByRow","getScaleByColumn","scaleByColumn","getScaleAll","divider","scaleAll","from1DArray","newRows","newColumns","newData","newMatrix","row","column","rowVector","columnVector","zeros","ones","fill","rand","random","randInt","interval","eye","diag","data","l","matrix1","matrix2","isMatrix","klass","apply","callback","to2DArray","copy","toJSON","isRowVector","isColumnVector","isVector","isSquare","isSymmetric","isDistance","isEchelonForm","previousColumn","checked","isReducedEchelonForm","k","echelonForm","clone","h","iMax","swapRows","tmp","reducedEchelonForm","m","n","maxRow","p","pivot","setSubMatrix","neg","getRow","getRowVector","setRow","row1","row2","temp","getColumn","getColumnVector","setColumn","swapColumns","column1","column2","addRowVector","subRowVector","mulRowVector","divRowVector","addColumnVector","subColumnVector","mulColumnVector","divColumnVector","mulRow","mulColumn","by","NaN","NEGATIVE_INFINITY","maxIndex","idx","POSITIVE_INFINITY","minIndex","maxRowIndex","minRow","minRowIndex","maxColumn","maxColumnIndex","minColumn","minColumnIndex","norm","type","dot","cumulativeSum","vector2","vector1","mmul","other","Bcolj","Float64Array","s","mpow","scalar","bb","e","strassen2x2","a11","b11","a12","b12","a21","b21","a22","b22","m1","m2","m3","m4","m5","c00","c01","c10","c11","strassen3x3","a00","a01","a02","a10","a20","b00","b01","b02","b10","b20","m6","m7","m8","m9","m12","m13","m14","m15","m16","m17","m18","c02","c12","c20","c21","c22","mmulStrassen","y","r1","c1","r2","c2","embed","mat","r","c","resultat","console","warn","blockMult","a","b","halfRows","parseInt","halfCols","subMatrix","scaleRows","isFinite","scaleColumns","flipRows","middle","first","last","flipColumns","kroneckerProduct","q","kroneckerSum","AxI","IxB","transpose","sortRows","compareFunction","compareNumbers","sort","sortColumns","subMatrixRow","indices","subMatrixColumn","selection","rowIndex","columnIndex","trace","from","to","entries","product","standardDeviation","center","Symbol","iterator","col","values","isArrayOfNumbers","every","element","for","randomInt","diagonal","identity","negate","tensorProduct","initData","nRows","nColumns","super","arrayData","removeRow","splice","addRow","removeColumn","newRow","addColumn","SymmetricMatrix","diagonalSize","isSymmetricMatrix","klassType","upperRightEntries","toMatrix","removeCross","addCross","applyMask","mask","sidesToRemove","passthroughs","reverse","sideIndex","toCompact","compact","fromCompact","compactSize","JSON","stringify","upperRightValues","DistanceMatrix","isDistanceMatrix","klassSubType","sideSize","toSymmetricMatrix","BaseView","MatrixColumnView","MatrixColumnSelectionView","MatrixFlipColumnView","MatrixFlipRowView","MatrixRowView","MatrixRowSelectionView","MatrixSelectionView","MatrixSubView","MatrixTransposeView","_calculateIndex","WrapperMatrix2D","wrap","WrapperMatrix1D","LuDecomposition","t","LUcolj","kmax","lu","pivotVector","pivotSign","LU","isSingular","solve","count","X","determinant","lowerTriangularMatrix","upperTriangularMatrix","pivotPermutationVector","hypotenuse","QrDecomposition","qr","rdiag","nrm","QR","Rdiag","isFullRank","orthogonalMatrix","SingularValueDecomposition$1","computeLeftSingularVectors","computeRightSingularVectors","autoTranspose","wantu","Boolean","wantv","swapped","aux","nu","ni","U","V","work","si","nct","nrt","mrc","pp","eps","EPSILON","kase","alpha","MIN_VALUE","isNaN","ks","f","cs","sn","sp","spm1","epm1","sk","ek","shift","g","Y","threshold","scols","Ls","rightSingularVectors","VL","vrows","urows","VLU","solveForDiagonal","inverse","vcols","ucols","condition","norm2","rank","tol","ii","leftSingularVectors","diagonalMatrix","useSVD","SingularValueDecomposition","leftHandSide","rightHandSide","d","subMatrix0","subMatrix1","subMatrix2","xrange","exception","range","dependenciesOneRow","error","thresholdValue","thresholdError","returnArray","linearDependencies","results","Abis","pseudoInverse","svdSolution","covariance","xMatrix","yMatrix","yIsSame","cov","correlation","sdx","sdy","corr","EigenvalueDecomposition$1","assumeSymmetric","tred2","tql2","H","ort","orthes","hqr2","realEigenvalues","imaginaryEigenvalues","eigenvectorMatrix","hh","dl1","c3","el1","s2","tst1","high","low","nn","w","ra","sa","vr","vi","notlast","cdivres","exshift","z","iter","cdiv","xr","xi","yr","yi","CholeskyDecomposition","dimension","positiveDefinite","L","isPositiveDefinite","B","nipals","scaleScores","maxIterations","terminationCriteria","u","tOld","diff","counter","xResidual","residual","yResidual","betas","CHO","EVD","EigenvalueDecomposition","EigenvalueDecomposition_1","Matrix_1","NIPALS","Nipals","SVD","SingularValueDecomposition_1","WrapperMatrix1D_1","_default","default","determinant_1","inverse_1","pseudoInverse_1","Matrix$1","getCentroid","points","nbPoints","xSum","ySum","getAffineTransform","source","destination","sourceCentroid","destinationCentroid","translatedSource","translatedDestination","ratioSum","sourcePoint","getDistanceToOrigin","covarianceMatrix","svd","rotation","angleDegrees","atan2","PI","translation","point","hypot","_ref","module","exports","window","median","quickSelectMedian","LOOP","FLOAT_MUL","sh1","sh2","sh3","multiply_uint32","nlo","XSadd$1","seed","Date","now","state","Uint32Array","init","getFloat","bind","getUint32","nextState","periodCertification","PROB_TOLERANCE","randomChoice","replace","probabilities","valuesArr","cumSum","getArray","randomIndex","arr","Random","seedOrRandom","xsadd","XSAdd","randomGenerator","choice","randomSample","getNbIterations","probability","outliersFraction","sampleSize","ransac","minNbInliers","getNbValues","fitFunction","distanceFunction","modelFunction","maxNbIterations","stopProbabilty","iteration","bestNbInliers","bestInliers","bestModelParameters","bestError","seeds","srcSubset","dstSubset","modelParameters","model","predictedDestination","nbInliers","inliers","distances","distance","arrayMedian","nbIterations","getDistanceMatrix","keypoints","point1","origin","point2","squaredDistance","getKeypointsInRadius","radius","squaredRadius","currentIndices","getBestKeypointsInRadius","keypointsInRadius","toIgnore","Uint8Array","keypoint","secondKeypointIndex","secondKeypoint","score","difference","p1","p2","normalize","rotate","radians","sortByColumnRow","sortedPoints","getAngle","angle","getClockwiseAngle","toDegrees","getRadius","checkBorderDistance","image","width","height","N","J","o","M","I","P","Z","aa","fa","ta","ia","Q","_","S","W","T","G","E","O","F","R","D","$","C","A","K","oa","circle","circleAA","cubicBezier","cubicBezierAA","cubicBezierSegment","cubicBezierSegmentAA","ellipse","ellipseRect","lineAA","lineWidth","quadBezier","quadBezierAA","quadBezierSegment","quadBezierSegmentAA","quadRationalBezier","quadRationalBezierSegment","quadRationalBezierSegmentAA","rotatedEllipse","rotatedEllipseRect","toStringTag","deleteDuplicates","finalPoints","getCirclePoints","circlePoints","firstQuarter","secondQuarter","thirdQuarter","fourthQuarter","concat","zeroPoint","getFilledCirclePoints","getLinePoints","linePoints","getCompassPoints","getIndex","channel","channels","surroundingPixels","formatter","Intl","ListFormat","checkProcessable","bitDepth","colorModel","components","isArray","format","errorMessage","map","String","getFastScore","currentIntensity","getValueByPoint","brighterSum","darkerSum","pointIntensity","getValue","SOBEL_X","SOBEL_Y","SCHARR_X","SCHARR_Y","PREWITT_X","PREWITT_Y","getHarrisScore","windowSize","harrisConstant","cropOrigin","crop","xDerivative","gradientFilter","kernelX","yDerivative","kernelY","getRawImage","xx","xy","yy","xxSum","xySum","yySum","structureTensor","eigenValues","isFastKeypoint","compassPoints","nbContiguousPixels","brighter","darker","comparisonArray","currentLength","counterArray","getFastKeypoints","fastRadius","scoreAlgorithm","harrisScoreOptions","maxNbFeatures","nonMaxSuppression","getScore","match","with","corner","exhaustive","allKeypoints","scoreArray","currentScore","neighbour","getPatchIntensityMoment","getCoordinates","moment","relativeCirclePoints","intensity","getPatchIntensityCentroid","moment10","moment01","moment00","centroid","getOrientedFastKeypoints","centroidPatchDiameter","fastKeypoints","orientedFastKeypoints","compareIntensity","absoluteP1","absoluteP2","xMedian","exact","middleIndex","calcMiddle","quickSelect","currentLow","currentHigh","swap","xCheck","minLength","xFindClosestIndex","target","sorted","currentDiff","xGetFromToIndex","xMean","sumValue","xVariance","sqrError","FFT","_csize","table","power","_width","_bitrev","revShift","_out","_data","_inv","fromComplexArray","complex","storage","res","createComplexArray","toComplexArray","completeSpectrum","spectrum","half","transform","out","_transform4","realTransform","_realTransform4","inverseTransform","outOff","step","bitrev","off","_singleTransform2","_singleTransform4","inv","quarterLen","limit","Ar","Ai","Br","Bi","Cr","Ci","Dr","Di","MAr","MAi","tableBr","tableBi","MBr","MBi","tableCr","tableCi","MCr","MCi","tableDr","tableDi","MDr","MDi","T0r","T0i","T1r","T1i","T2r","T2i","T3r","T3i","FAr","FAi","FCr","FCi","FBr","FBi","FDr","FDi","evenR","evenI","oddR","oddI","leftR","leftI","rightR","rightI","step2","step3","_singleRealTransform2","_singleRealTransform4","halfLen","hquarterLen","SFAr","SFAi","SFBr","SFBi","SA","SB","multiplyUint32","XSadd","createRandomArray","distribution","generator","gaussianGenerator","GaussianGenerator","generateGaussian","spare","hasSpare","val","xyCovariance","meanX","meanY","assert","message","assertUnreachable","getClamp","clamp255","clamp65535","getClampFromTo","getGaussianPoints","xSeed","ySeed","sigma","xCoordinates","getGaussianValues","yCoordinates","nbValues","clamp","rounded","extractSquareImage","patchSize","cropOffset","getKeypointPatch","radAngle","rawWidth","cropWidth","borderDistance","rotated","transformRotate","interpolationType","getBriefDescriptors","descriptorLength","smoothingOptions","pointsDistributionOptions","gaussianPoints","smoothed","gaussianBlur","descriptors","filteredKeypoints","patch","descriptor","getBrief","bestKptRadius","minScore","brief","getIntensityMoment","xDistance","yDistance","getIntensityCentroid","getHammingDistance","descriptor1","descriptor2","bruteForceOneMatch","nbBestMatches","matches","sourceIndex","minDistance","destinationIndex","sortBySourceDest","match1","match2","sortByDestSource","getCrosscheckMatches","crosscheck","srcDstMatches","dstSrcMatches","sortedSrcDst","sortedDstSrc","pointer1","pointer2","validateChannels","validateChannel","validateValues","validateValue","validateForComparison","validateColor","color","newImage","getOutputImage","newIntensity","setClampedValue","computeRmse","otherImage","globalMse","computeMse","absolute","getValueByIndex","computePsnr","rmsePixel","getDefaultColor","setBlendedPixel","Image","sourceAlpha","at","setPixel","targetAlpha","newAlpha","setValue","component","newComponent","setBlendedVisiblePixel","roundPoint","drawCircleOnImage","strokeColor","fillColor","prevRow","drawLine","drawLineOnImage","drawLineOnMask","newMask","maskToOutputMask","setVisiblePixel","drawPolylineOnImage","drawPolylineOnMask","twoProduct_1","twoProduct","SPLITTER","ahi","alo","bhi","blo","robustSum","linearExpansionSum","scalarScalar","bv","ne","nf","eptr","fptr","ei","ea","fi","_x","_bv","q0","q1","twoSum","fastTwoSum","br","ar","robustScale","scaleLinearExpansion","ts","pq","robustDiff","robustSubtract","require$$2","require$$3","orientation_3","prod","m0","orientation_4","orientation_5","orientation","orientation3Exact","orientation4Exact","CACHED","det","adx","bdx","cdx","ady","bdy","cdy","adz","bdz","cdz","bdxcdy","cdxbdy","cdxady","adxcdy","adxbdy","bdxady","slowOrient","args","proc","slow","o0","o1","o2","o3","o4","o5","a0","a1","a2","a3","a4","generateOrientationProc","robustPnp","robustPointInPolygon","orient","vs","inside","lim","yj","x0","x1","px","y0","y1","arrayPointsToObjects","drawPolygonOnImage","otherOptions","drawPolyline","arrayPoints","drawPolygonOnMask","filled","setBit","drawRectangle","rectangleWidth","rectangleHeight","currentColumn","currentRow","drawPoints","drawMarker","shape","markerSize","drawCircle","drawPolygon","drawMarkers","otherMask","getBitByIndex","setBitByIndex","checkSize","checkKernel","kernel","checkBorderType","borderType","checkInputLength","actual","expected","createArray","DirectConvolution","kernelOffset","outputSize","kernelSize","convolve","_convolutionBorder0","_convolutionBorderCut","interpolateInput","BorderType","CUT","CONSTANT","REPLICATE","REFLECT","WRAP","REFLECT_101","getBorderInterpolation","getInterpolateConstant","interpolateReplicate","interpolateReflect","interpolateReflect101","interpolateWrap","newColumn","interpolateConstantPoint","interpolateReplicatePoint","interpolateReflectPoint","interpolateWrapPoint","interpolateReflect101Point","extendBorders","horizontal","vertical","borderValue","interpolateBorder","createFrom","copyTo","newValue","integer","decimal","directConvolution","convolutedData","rawDirectConvolution","setValueByIndex","computeConvolutionValue","returnRawValue","separableConvolution","normalizeSeparatedKernel","extendedImage","rowConvolution","ConvolutionBorderType","columnConvolution","rowData","columnData","convolvedData","convolvedRow","convolvedColumn","kernelWidth","kernelHeight","kernelOffsetX","kernelOffsetY","kY","kX","reduce","prev","current","blur","DerivativeFilter","SOBEL","SCHARR","PREWITT","derivativeFilter","filter","kernels","ImageColorModel","GREY","GREYA","RGB","RGBA","BINARY","colorModels","increaseContrast","uniform","minMax","maxDiffIndex","previousDiff","level","inputMin","inputMax","outputMin","outputMax","getSize","getKernel","sigmaX","sigmaY","sizeX","sizeY","radiusX","radiusY","scale2X","gradientX","gradientY","gradient","convertColor","canConvert","Map","canConvertTo","newParameters","convertGreyToAny","convertRgbToRgb","convertRgbToGrey","fillAlpha","copyAlpha","maskToOutputImage","convertBinaryToGrey","img","convertBinaryToRgb","dest","black","white","setPixelByIndex","convertBitDepth","newBitDepth","convertToUint8","convertToUint16","targetImage","checkPointIsInteger","extract","resultWidth","resultHeight","imageStartRow","imageStartColumn","maskStartRow","maskStartColumn","resultRow","resultColumn","getBit","getPixel","merge","images","split","huang","histogram","firstBin","ih","lastBin","term","mu0","sumPix","numPix","mu1","minEnt","MAX_VALUE","it","muX","ent","intermodes","iHisto","bimodalTest","previous","next","tt","modes","isodata","toth","totl","li","total","sumBack","sumObj","numBack","numObj","oldThresh","newThresh","meanBack","meanObj","maxEntropy","normHisto","P1","P2","totEnt","entBack","entObj","maxEnt","minError","mu","sigma2","tau2","w0","w1","w2","sqterm","Tprev","sumA1","sumA","sumA2","sumB1","sumB","sumB2","sumC1","sumC","minimum","iterations","histogramCopy","auHistogram","isBimodal","peaks","moments","histogramLength","normalizedHistogram","cd","c0","z0","z1","p0","otsu","histogramCounts","wB","maximum","wF","mF","between","percentile","avec","partialSum","endIndex","renyiEntropy","threshold1","threshold2","threshold3","maxEnt1","maxEnt2","maxEnt3","entBack1","entBack2","entBack3","entObj1","entObj2","entObj3","totEnt1","totEnt2","totEnt3","tStars","omega","shanbhag","triangle","dmax","min2","nx","ny","inverted","left","right","splitDistance","newDistance","yen","P1Sq","P2Sq","crit","maxCrit","ThresholdAlgorithm","HUANG","INTERMODES","ISODATA","LI","MAX_ENTROPY","MEAN","MIN_ERROR","MINIMUM","MOMENTS","OTSU","PERCENTILE","RENYI_ENTROPY","SHANBHAG","TRIANGLE","YEN","computeThreshold","algorithm","slots","imageToOutputMask","luma709","red","green","blue","luma601","average","minmax","cyan","blackColor","magenta","yellow","hue","delta","saturation","lightness","GreyAlgorithm","LUMA_709","LUMA_601","MAX","MIN","AVERAGE","MINMAX","RED","GREEN","BLUE","BLACK","CYAN","MAGENTA","YELLOW","HUE","SATURATION","LIGHTNESS","algos","Set","algo","keys","greyAlgorithms","has","grey","keepAlpha","mergeAlpha","method","cropAlpha","findLeft","top","findTop","bottom","findBottom","findRight","InterpolationType","NEAREST","BILINEAR","BICUBIC","getInterpolationFunction","interpolateNearest","interpolateBilinear","interpolateBicubic","px0","py0","px1","py1","xNorm","yNorm","v0","cubic","v1","v2","v3","transformMatrix","fullImage","isValidMatrix","corners","transformedCorners","transformPoint","maxX","maxY","minX","minY","interpolate","perspective","transformationMatrix","resize","xFactor","yFactor","checkOptions","preserveAspectRatio","newWidth","newHeight","maybeWidth","maybeHeight","sizeOpt","sizeImg","centerCoordinates","getRotationMatrix","angleRadians","getPerspectiveWarp","pts","tl","tr","bl","order4Points","widthRect","heightRect","distance2Points","x2","y2","x3","y3","x4","y4","indexMinX","minX2","indexMinX2","rotatePoint","rotationCenter","angleCos","angleSin","cropRectangle","getSmallestAngle","rotatedPoints","p3","originalWidth","originalHeight","expandedTopLeft","angleHorizontal","paintMaskOnImage","blend","checkColorIsNumberArray","currentValue","paintMaskOnMask","maybeToPrecision","number","figures","toPrecision","checkArrayLength","BaseRegression2D","predict","inputs","isOnePoint","_predict","train","precision","toLaTeX","chi2","rmsd","xSquared","ySquared","xY","PolynomialRegression2D","order","coefficients","outputs","newInputs","_toFormula","isLaTeX","sup","closeSup","times","fn","coefficient","load","json","powColVector","examples","nbCoefficients","scaleX1","scaleX2","scaleY","qqs","qqs1","correctBackground","background","backgroundKind","invert","gamma","getValueArray","ratio","imageChannels","flipX","currentCol","oppositeCol","flipY","oppositeRow","flip","axis","medianFilter","cellSize","cellValues","Uint16Array","halfCellSize","cellRow","cellColumn","pixelate","getCellValue","getCellValueFunction","currentCellWidth","currentCellHeight","getCellCenter","getCellMean","getCellMedian","getBorderPoints","innerBorders","allowCorners","solidFill","borders","getLineLength","getPolygonPerimeter","perimeter","getPolygonArea","area","getExtendedBorderPoints","borderPoints","monotoneChainConvexHull","byXThenY","cw","getConvexHull","surface","mcch","getFeret","hull","hullPoints","minDiameter","calliperLines","maxDiameter","aspectRatio","minLines","minWidth","minWidthAngle","minLinePoints","currentWidth","currentMinLinePoints","absWidth","findPointIndexesOfExtremeColumns","getMinLines","maxLinePoints","maxSquaredWidth","maxLineIndex","currentSquaredWidth","maxAngle","rotatedMaxPoints","findPointsIndexesOfExtremeRows","maxLines","getMaxLines","feretPoints","minLine1","minLine2","maxLine1","maxLine2","leftFirst","mbrPoint1","mbrPoint2","topFirst","getMbrAngle","mbr","getMbrFromPoints","rotatedVertices","minSurface","minSurfaceAngle","aX","aY","bX","bY","tUndefined","tMin","tMax","maxWidth","minPoint","maxPoint","currentSurface","mbrRotated","sides","maxSide","minSide","getMbr","erode","defaultKernel","onlyOnes","bit","Mask","erodeMaskOnlyOnes","erodeMask","erodeGreyOnlyOnes","erodeGrey","kernelRow","kernelColumn","minList","dilate","dilatMaskOnlyOnes","dilateMask","dilateGreyOnlyOnes","dilateGrey","maxList","open","close","topHat","openImage","bottomHat","morphologicalGradient","dilatedImage","erodedImage","borderIterator","MAX_ARRAY","toProcess","multipleFloodFill","startPixels","startPixelValue","newPixelValue","alreadyConsidered","pixelIndex","currentPixel","topBorder","leftBorder","rightBorder","bottomBorder","addToProcess","pixel","clearBorder","cannyEdgeDetector","hysteresis","lowThreshold","highThreshold","gaussianBlurOptions","blurred","edges","finalImage","direction","getDirection","currentGradient","currentNms","currentEdge","currentPixels","hystColumn","hystRow","newPixels","floodFill","cleared","boolToNumber","colorModelDef","expectedLength","getPixelByIndex","fromPoints","getNbNonZeroPixels","datum","checkChannel","setValueByPoint","dataString","printData","paintMask","pixelSum","channelSum","hist","bitShift","bitSlots","quickMedian","getChannel","getExtrema","kind","maxEquals","searchingMinimum","maskExpectedValue","dx","dy","currentY","currentX","nbEquals","dir","currentAroundValue","MultivariateLinearRegression","intercept","statistics","weights","xt","invxx","beta","fittedValues","ri","stdError","stdErrorMatrix","stdErrors","tStats","summary","regressionStatistics","standardError","observations","variables","label","tStat","grad","turn","rad","string","exec","substr","object","trim","parsed","rgba","isValid","brightness","isDark","isLight","toHex","toRgb","toRgbString","toHsl","toHslString","toHsv","saturate","desaturate","grayscale","lighten","darken","isEqual","forEach","indexOf","labPlugin","toLab","formatReferenceForMlr","referenceColors","referenceData","formatInputForMlr","inputColors","inputData","getRegressionVariables","correctColor","measuredColors","mlrRed","MLR","mlrGreen","mlrBlue","newPixel","getMinMax","extend","ImageCoordinates","CENTER","TOP_LEFT","TOP_RIGHT","BOTTOM_LEFT","BOTTOM_RIGHT","originalResolution","meta","resolution","createPixelArray","normalizedResolution","unit","start","columnValues","channelValues","rowValues","setClampedValueByIndex","fillChannel","alphaIndex","changeEach","cb","coordinates","centerX","centerY","newDepth","otherwise","padding","padStart","copyData","thisImage","internalOptions","checkRequirements","requirements","property","prop","getColors","baseColor","nbShades","minValueFactor","colors","getKeypointColor","maxScore","drawKeypoints","showScore","showScoreOptions","maxNbKeypoints","keypointColor","absoluteOrigin","isOrientedFastKeypoint","showOrientation","kpt","getMatchColor","maxDistance","sortByDistance","scaleKeypoints","drawMatches","montage","sourceKeypoints","destinationKeypoints","circleDiameter","showDistance","showDistanceOptions","maxNbMatches","scaledSource","scaledDestination","matchesSortedByDistance","matchColor","relativeDestinationPoint","destinationPoint","destinationOrigin","MontageDisposition","HORIZONTAL","VERTICAL","Montage","sourceWidth","sourceHeight","destinationWidth","destinationHeight","disposition","scaledKeypoints","overlapImages","image1","image2","inverted1","inverted2","scaled","empty","filterEuclideanDistance","sameDestMatches","currentIndex","distanceSquared","decode","bytes","encoding","TextDecoder","encoder","TextEncoder","encode","defaultByteLength","hostBigEndian","buffer","typedArrays","int8","globalThis","Int8Array","uint8","int16","Int16Array","uint16","int32","Int32Array","uint32","uint64","BigUint64Array","int64","BigInt64Array","float32","Float32Array","float64","IOBuffer","byteLength","byteOffset","offset","lastWrittenByte","littleEndian","_mark","_marks","dataIsGiven","ArrayBuffer","dvOffset","isView","DataView","available","isLittleEndian","setLittleEndian","isBigEndian","setBigEndian","skip","back","seek","mark","reset","pushMark","popMark","pop","rewind","ensureAvailable","newLength","readBoolean","readUint8","readInt8","getInt8","getUint8","readByte","readBytes","readArray","BYTES_PER_ELEMENT","readInt16","getInt16","readUint16","getUint16","readInt32","getInt32","readUint32","readFloat32","getFloat32","readFloat64","getFloat64","readBigInt64","getBigInt64","readBigUint64","getBigUint64","readChar","fromCharCode","readChars","readUtf8","decodeText","writeBoolean","writeUint8","writeInt8","setInt8","_updateLastWrittenByte","setUint8","writeByte","writeBytes","writeInt16","setInt16","writeUint16","setUint16","writeInt32","setInt32","writeUint32","setUint32","writeFloat32","setFloat32","writeFloat64","setFloat64","writeBigInt64","setBigInt64","writeBigUint64","setBigUint64","writeChar","charCodeAt","writeChars","writeUtf8","toArray","getWrittenByteLength","BMPDecoder","bufferData","pixelDataOffset","bitsPerPixel","xPixelsPerMeter","yPixelsPerMeter","compression","colorMasks","formatCheck","decodePixelData","decodeBitDepth1Pixels","decodeStandardPixels","decodePixelsWithAlpha","currentNumber","bitIndex","calculatePadding","rowOffset","pixelBaseIndex","BITMAPV5HEADER","LogicalColorSpace","LCS_sRGB","GamutMappingIntent","LCS_GM_GRAPHICS","DEFAULT_PIXELS_PER_METER","BMPEncoder","encoded","writeBitmapV5Header","writeColorTable","writePixelArray","imageSize","writeBitmapFileHeader","writeBitDepth1Pixels","writeStandardPixels","writePixelsWithAlpha","byte","writePadding","imageOffset","fileSize","totalBytes","Encoder","Decoder","encodeBmp","bmp","JPEGEncoder","quality","YDC_HT","UVDC_HT","YAC_HT","UVAC_HT","currentQuality","ffloor","YTable","UVTable","fdtbl_Y","fdtbl_UV","bitcode","category","outputfDCTQuant","DU","byteout","bytenew","bytepos","YDU","UDU","VDU","clt","RGB_YUV_TABLE","ZigZag","std_dc_luminance_nrcodes","std_dc_luminance_values","std_ac_luminance_nrcodes","std_ac_luminance_values","std_dc_chrominance_nrcodes","std_dc_chrominance_values","std_ac_chrominance_nrcodes","std_ac_chrominance_values","computeHuffmanTbl","nrcodes","std_table","codevalue","pos_in_table","HT","writeBits","bs","posval","writeWord","processDU","CDU","fdtbl","DC","HTDC","HTAC","pos","EOB","M16zeroes","DU_DCT","d0","d1","d2","d3","d4","d5","d6","d7","fDCTQuant","dataOff","tmp0","tmp7","tmp1","tmp6","tmp2","tmp5","tmp3","tmp4","tmp10","tmp13","tmp11","tmp12","z5","z2","z4","z3","z11","z13","tmp0p2","tmp7p2","tmp1p2","tmp6p2","tmp2p2","tmp5p2","tmp3p2","tmp4p2","tmp10p2","tmp13p2","tmp11p2","tmp12p2","z1p2","z5p2","z2p2","z4p2","z3p2","z11p2","z13p2","Diff","end0pos","lng","startpos","nrzeroes","nrmarker","setQuality","sf","YQT","UVQT","aasf","initQuantTables","comments","getTime","exifBuffer","writeAPP1","writeDQT","writeSOF0","writeDHT","DCY","DCU","DCV","displayName","imageData","quadWidth","fillbits","Buffer","sfcc","initCharLookupTable","nrlower","nrupper","cat","nr","nrneg","initCategoryNumber","initRGBYUVTable","imgData","qu","JpegImage","dctZigZag","dctCos1","dctSin1","dctCos3","dctSin3","dctCos6","dctSin6","dctSqrt2","dctSqrt1d2","buildHuffmanTable","codeLengths","code","children","decodeScan","frame","resetInterval","spectralStart","spectralEnd","successivePrev","successive","opts","samplesPerLine","scanLines","mcusPerLine","progressive","maxH","maxV","startOffset","bitsData","bitsCount","readBit","nextByte","decodeHuffman","tree","node","receive","receiveAndExtend","eobrun","successiveACNextValue","successiveACState","decodeMcu","mcu","mcuCol","blockRow","blockCol","blocks","tolerantDecoding","decodeBlock","blocksPerLine","decodeFn","componentsLength","zz","huffmanTableDC","pred","rs","huffmanTableAC","marker","mcuExpected","blocksPerColumn","mcusPerColumn","buildComponentData","lines","quantizeAndInverse","dataOut","dataIn","v4","v5","v6","v7","qt","quantizationTable","sample","requestMemoryAllocation","scanLine","clampTo8bit","path","xhr","XMLHttpRequest","responseType","onload","response","mozResponseArrayBuffer","parse","send","maxResolutionInPixels","maxResolutionInMP","readDataBlock","subarray","prepareComponents","componentId","hasOwnProperty","blocksPerLineForMcu","blocksPerColumnForMcu","jfif","adobe","quantizationTables","frames","huffmanTablesAC","huffmanTablesDC","fileMarker","malformedDataOffset","appData","comment","version","major","minor","densityUnits","xDensity","yDensity","thumbWidth","thumbHeight","thumbData","flags0","flags1","transformCode","quantizationTablesEnd","quantizationTableSpec","tableData","extended","componentsOrder","pixelsInFrame","exceededAmount","componentsCount","qId","quantizationIdx","huffmanLength","huffmanTableSpec","codeLengthSum","huffmanValues","selectorsCount","tableSpec","successiveApproximation","processed","nextOffset","cp","scaleX","getData","component1","component2","component3","component4","component1Line","component2Line","component3Line","component4Line","Cb","Ye","colorTransform","dataLength","copyToImageData","formatAsRGBA","imageDataArray","totalBytesAllocated","maxMemoryUsageBytes","increaseAmount","totalMemoryImpactBytes","resetMaxMemoryUsage","maxMemoryUsageBytes_","getBytesAllocated","jpegData","userOpts","useTArray","maxMemoryUsageInMB","decoder","bytesNeeded","alloc","err","ReferenceError","jpegJs","encodeJpeg","Z_FIXED$1","Z_BINARY","Z_TEXT","Z_UNKNOWN$1","zero$1","buf","STORED_BLOCK","STATIC_TREES","DYN_TREES","MIN_MATCH$1","MAX_MATCH$1","LENGTH_CODES$1","LITERALS$1","L_CODES$1","D_CODES$1","BL_CODES$1","HEAP_SIZE$1","MAX_BITS$1","Buf_size","MAX_BL_BITS","END_BLOCK","REP_3_6","REPZ_3_10","REPZ_11_138","extra_lbits","extra_dbits","extra_blbits","bl_order","DIST_CODE_LEN","static_ltree","static_dtree","_dist_code","_length_code","base_length","base_dist","StaticTreeDesc","static_tree","extra_bits","extra_base","elems","max_length","has_stree","static_l_desc","static_d_desc","static_bl_desc","TreeDesc","dyn_tree","stat_desc","max_code","d_code","dist","put_short","pending_buf","pending","send_bits","bi_valid","bi_buf","send_code","bi_reverse","bi_flush","gen_bitlen","desc","stree","extra","base","bits","xbits","overflow","bl_count","heap","heap_max","opt_len","static_len","gen_codes","next_code","tr_static_init","init_block","dyn_ltree","dyn_dtree","bl_tree","sym_next","bi_windup","smaller","depth","_n2","_m2","pqdownheap","heap_len","compress_block","ltree","dtree","lc","sx","sym_buf","build_tree","scan_tree","curlen","prevlen","nextlen","max_count","min_count","send_tree","build_bl_tree","max_blindex","l_desc","d_desc","bl_desc","send_all_trees","lcodes","dcodes","blcodes","detect_data_type","block_mask","static_init_done","_tr_init$1","_tr_stored_block$1","stored_len","_tr_align$1","_tr_flush_block$1","opt_lenb","static_lenb","strm","data_type","strategy","_tr_tally$1","sym_end","_tr_init_1","_tr_stored_block_1","_tr_flush_block_1","_tr_tally_1","_tr_align_1","trees","_tr_init","_tr_stored_block","_tr_flush_block","_tr_tally","_tr_align","adler32","adler","s1","adler32_1","makeTable","crcTable","crc32","crc","end","crc32_1","messages","constants$2","Z_NO_FLUSH","Z_PARTIAL_FLUSH","Z_SYNC_FLUSH","Z_FULL_FLUSH","Z_FINISH","Z_BLOCK","Z_TREES","Z_OK","Z_STREAM_END","Z_NEED_DICT","Z_STREAM_ERROR","Z_DATA_ERROR","Z_MEM_ERROR","Z_BUF_ERROR","Z_DEFAULT_COMPRESSION","Z_FILTERED","Z_HUFFMAN_ONLY","Z_RLE","Z_FIXED","Z_DEFAULT_STRATEGY","Z_UNKNOWN","Z_DEFLATED","Z_NO_FLUSH$2","Z_FULL_FLUSH$1","Z_FINISH$3","Z_BLOCK$1","Z_OK$3","Z_STREAM_END$3","Z_STREAM_ERROR$2","Z_DATA_ERROR$2","Z_BUF_ERROR$1","Z_DEFAULT_COMPRESSION$1","Z_DEFAULT_STRATEGY$1","Z_DEFLATED$2","MAX_MEM_LEVEL","MAX_WBITS$1","DEF_MEM_LEVEL","LENGTH_CODES","LITERALS","L_CODES","D_CODES","BL_CODES","HEAP_SIZE","MAX_BITS","MIN_MATCH","MAX_MATCH","MIN_LOOKAHEAD","PRESET_DICT","INIT_STATE","GZIP_STATE","EXTRA_STATE","NAME_STATE","COMMENT_STATE","HCRC_STATE","BUSY_STATE","FINISH_STATE","BS_NEED_MORE","BS_BLOCK_DONE","BS_FINISH_STARTED","BS_FINISH_DONE","OS_CODE","errorCode","msg","zero","slide_hash","wsize","w_size","hash_size","head","HASH_ZLIB","hash_shift","hash_mask","HASH","flush_pending","avail_out","pending_out","next_out","total_out","flush_block_only","block_start","strstart","put_byte","putShortMSB","read_buf","avail_in","next_in","total_in","longest_match","cur_match","chain_length","max_chain_length","scan","best_len","prev_length","nice_match","_win","wmask","w_mask","strend","scan_end1","scan_end","good_match","lookahead","match_start","fill_window","_w_size","more","window_size","insert","ins_h","deflate_stored","flush","have","min_block","pending_buf_size","used","high_water","deflate_fast","hash_head","bflush","match_length","max_lazy_match","deflate_slow","max_insert","prev_match","match_available","deflate_rle","deflate_huff","Config","good_length","max_lazy","nice_length","max_chain","func","configuration_table","lm_init","DeflateState","status","gzhead","gzindex","last_flush","w_bits","hash_bits","lit_bufsize","deflateStateCheck","deflateResetKeep","deflateReset","ret","deflateSetHeader","deflateInit2","windowBits","memLevel","deflateInit","deflate$2","old_flush","header","level_flags","text","hcrc","time","os","beg","gzhead_extra","bstate","deflateEnd","deflateSetDictionary","dictionary","dictLength","tmpDict","avail","deflateInit_1","deflateInit2_1","deflateReset_1","deflateResetKeep_1","deflateSetHeader_1","deflate_2$1","deflateEnd_1","deflateSetDictionary_1","deflateInfo","deflate_1$2","deflate","_has","obj","key","assign","sources","flattenChunks","chunks","chunk","common","STR_APPLY_UIA_OK","__","_utf8len","string2buf","m_pos","str_len","buf_len","buf2binstring","buf2string","utf16buf","c_len","utf8border","strings","ZStream","zstream","toString$1","Z_NO_FLUSH$1","Z_FINISH$2","Z_OK$2","Z_STREAM_END$2","Z_DEFLATED$1","Deflate$1","chunkSize","opt","raw","gzip","ended","dict","_dict_set","deflate$1","deflator","flush_mode","_flush_mode","onData","onEnd","deflate_2","deflate_1$1","BAD$1","TYPE$1","inffast","_in","whave","wnext","s_window","hold","lcode","dcode","lmask","dmask","here","op","from_source","lencode","distcode","lenbits","distbits","dolen","mode","sane","MAXBITS","ENOUGH_LENS$1","ENOUGH_DISTS$1","CODES$1","LENS$1","DISTS$1","lbase","lext","dbase","dext","inflate_table","lens","lens_index","codes","table_index","incr","sym","root","curr","drop","huff","offs","here_bits","here_op","here_val","inftrees","CODES","LENS","DISTS","Z_FINISH$1","Z_OK$1","Z_STREAM_END$1","Z_NEED_DICT$1","Z_STREAM_ERROR$1","Z_DATA_ERROR$1","Z_MEM_ERROR$1","HEAD","FLAGS","TIME","OS","EXLEN","EXTRA","NAME","COMMENT","HCRC","DICTID","DICT","TYPE","TYPEDO","STORED","COPY_","COPY","TABLE","LENLENS","CODELENS","LEN_","LEN","LENEXT","DIST","DISTEXT","MATCH","LIT","CHECK","LENGTH","DONE","BAD","MEM","SYNC","ENOUGH_LENS","ENOUGH_DISTS","MAX_WBITS","DEF_WBITS","zswap32","InflateState","havedict","flags","check","wbits","ncode","nlen","ndist","lendyn","distdyn","was","inflateStateCheck","inflateResetKeep","inflateReset","inflateReset2","inflateInit2","inflateInit","virgin","lenfix","distfix","fixedtables","updatewindow","src","inflate$2","put","last_bits","last_op","last_val","hbuf","inf_leave","done","xflags","extra_len","inflateEnd","inflateGetHeader","inflateSetDictionary","dictid","inflateReset_1","inflateReset2_1","inflateResetKeep_1","inflateInit_1","inflateInit2_1","inflate_2$1","inflateEnd_1","inflateGetHeader_1","inflateSetDictionary_1","inflateInfo","inflate_1$2","inflate","GZheader","gzheader","Inflate$1","inflate$1","inflator","last_avail_out","next_out_utf8","tail","utf8str","Inflate_1$1","inflate_2","inflate_1$1","Inflate","deflate_1","Inflate_1","inflate_1","initialCrc","updateCrc","currentCrc","checkCrc","crcLength","chunkName","expectedCrc","actualCrc","writeCrc","unfilterNone","currentLine","newLine","bytesPerLine","unfilterSub","bytesPerPixel","unfilterUp","prevLine","unfilterAverage","unfilterPaeth","paethPredictor","pa","pb","pc","applyUnfilter","filterType","passLineBytes","osIsLittleEndian","decodeInterlaceAdam7","params","passes","xStep","yStep","resultData","passIndex","pass","passWidth","passHeight","outputX","outputY","uint16Data","swap16","decodeInterlaceNull","pngSignature","of","writeSignature","checkSignature","hasPngSignature","textChunkName","NULL","latin1Decoder","validateKeyword","keyword","validateLatin1","latin1Regex","test","decodetEXt","readKeyword","readLatin1","encodetEXt","ColorType","UNKNOWN","GREYSCALE","TRUECOLOUR","INDEXED_COLOUR","GREYSCALE_ALPHA","TRUECOLOUR_ALPHA","CompressionMethod","DEFLATE","FilterMethod","ADAPTIVE","InterlaceMethod","NO_INTERLACE","ADAM7","DisposeOpType","NONE","BACKGROUND","PREVIOUS","BlendOpType","SOURCE","OVER","PngDecoder","_checkCrc","_inflator","_png","_apng","_end","_hasPalette","_palette","_hasTransparency","_transparency","_compressionMethod","_filterMethod","_interlaceMethod","_colorType","_isAnimated","_numberOfFrames","_numberOfPlays","_frames","_writingDataChunks","Inflator","numberOfFrames","numberOfPlays","decodeChunk","decodeImage","decodeApng","decodeApngChunk","decodeApngImage","decodeIHDR","decodePLTE","decodeIDAT","decodetRNS","decodeiCCP","decodepHYs","pushDataToFrame","decodeACTL","decodeFCTL","decodeFDAT","checkBitDepth","colorType","sequenceNumber","xOffset","yOffset","delayNumber","delayDenominator","disposeOp","blendOp","palette","dataOffset","compressionMethod","compressedProfile","iccEmbeddedProfile","profile","ppuX","ppuY","unitSpecifier","newFrame","transparency","prevFrame","disposeFrame","addFrameDataToCanvas","imageFrame","calculatePixelIndices","frameIndex","foregroundValue","lastFrame","defaultZlibOptions","PngEncoder","_zlibOptions","zlib","_checkData","interlace","encodeIHDR","encodePLTE","encodeTRNS","encodeData","encodeIEND","paletteLength","el","encodeIDAT","slotsPerLine","writeDataUint16","writeDataBytes","writeDataInterlaced","compressed","getColorType","png","checkInteger","expectedSize","returnValue","pixelSize","imageY","rawScanline","rawOffset","imageX","srcPos","decodePng","encodePng","ImageFormat","PNG","JPG","JPEG","BMP","defaultPng","encoderOptions","union","getNodeApiOrThrow","methodName","isNode","fs","process","getBuiltinModule","url","CanvasCtorBrowser","CanvasCtorNode","requireFn","getCanvasContext","getRequireFn","Canvas","getContext","OffscreenCanvas","context","createRequire","import","async","write","nodeApi","fileURLToPath","toWrite","getDataToWrite","recursive","dirname","promises","mkdir","writeFile","writeSync","mkdirSync","writeFileSync","destinationPath","extension","extname","toLowerCase","writeCanvas","canvas","resizeCanvas","dirtyX","dirtyY","dirtyWidth","dirtyHeight","ctx","putImageData","ImageData","Uint8ClampedArray","base64codes","base64codes1","base64codes2","encodeFast","output32","encodeDataURL","base64","uint8encode","base64Data","getMatrixFromPoints","affineFitFunction","createAffineTransformModel","xTranslation","yTranslation","getEuclideanDistance","getSourceWithoutMargins","bestKeypointRadius","enhanceContrast","maxRansacNbIterations","debug","debugImagePath","sourceExtremums","destinationExtremums","sourceBrief","destinationBrief","nbSourceKeypoints","nbDestinationKeypoints","sourcePoints","destinationPoints","nbRansacIterations","ransacResult","newSrcPoints","newDstPoints","inlier","inlierMatches","drawKeypointsBaseOptions","affineTransform","matrixGetAffineTransform","stats","nbMatches","alignMinDifference","xSpan","ySpan","startStep","bestDifference","bestShiftX","bestShiftY","startX","startY","endX","endY","nbPixelsToCheck","shiftX","shiftY","currentDifference","similarity","removeClosePoints","isMax","getSort","isDescending","toBytes","xpiZipFilename","oxmlContentTypes","oxmlRels","readUInt64LE","fileType","isBuffer","checkString","ext","mime","findNextZipHeaderIndex","startAt","findIndex","zipHeaderIndex","oxmlFound","sliced","idPos","docTypePos","findDocType","objectSize","stream","readableStream","Promise","resolve","reject","eval","once","PassThrough","read","minimumBytes","unshift","pipeline","pipe","imageExts","imageType","imageTypeModule","decodeBmp","decodedData","tagsById","tagsByName","guessStripByteCounts","ifd","bytesPerStrip","rowsPerStrip","samplesPerPixel","bitsPerSample","stripOffsets","applyHorizontalDifferencing8Bit","applyHorizontalDifferencing16Bit","tags","standard","exif","gps","IFD","fields","_hasMap","_map","taglist","types","readASCII","readShort","readLong","readRational","readSByte","readSShort","readSLong","readSRational","readFloat","readDouble","getByteLength","readData","currentString","char","rationals","CLEAR_CODE","EOI_CODE","TABLE_START","MIN_BIT_LENGTH","stringTable","initializeStringTable","dummyString","andTable","bitJumps","LzwDecoder","stripArray","nextData","nextBits","bytePointer","tableLength","currentBitLength","outData","initializeTable","oldCode","getNextCode","writeString","stringFromCode","isInTable","addStringToTable","outString","outArray","decompressLzw","stripData","dateTimeRegex","TiffIfd","Ifd","imageWidth","imageLength","date","dateTime","setFullYear","setHours","newSubfileType","extraSamples","associatedAlpha","alwaysArray","fillOrder","documentName","imageDescription","stripByteCounts","minSampleValue","maxSampleValue","xResolution","yResolution","planarConfiguration","resolutionUnit","predictor","sampleFormat","sMinSampleValue","sMaxSampleValue","totalColors","colorMap","tileWidth","tileHeight","tileOffsets","tileByteCounts","tiled","decompressZlib","stripUint8","inflated","defaultOptions","ignoreImageData","TIFFDecoder","_nextIFD","isMultiPage","decodeHeader","decodeIFD","unsupported","pageCount","pages","checkPages","Infinity","tiff","numEntries","decodeIFDEntry","decodeImageData","numValues","currentOffset","readTileData","readStripData","applyPredictor","convertAlpha","split1BitData","bytesPerRow","dataIndex","rowStartByte","byteIndex","uncompress","createSampleReader","stripLength","readSamples","getDataArray","uncompressed","twidth","theight","nwidth","nheight","nind","tileData","tileBytesPerRow","ty","srcStart","dstStart","bytesToCopy","tx","ix","iy","alphaValue","page","decodeTIFF","getMetadata","decodeJpeg","jpeg","decodedExif","decodeExif","loadPalettePng","decodeBinary","pixels","pixelsPerByte","paletteValue","paletteChannel","totalPixels","pngData","decodeTiff","getImageFromIFD","getTiffResolution","hasAlpha","ptr","typedArray","readFile","readSync","readFileSync","readCanvas","getImageData","readImg","document","createElement","drawImage","fetchURL","dataUrl","fetch","arrayBuffer","hsvToRgb","hsv","rgb","rgbToNumber","getBinaryMap","nbNegative","nbPositive","whiteHue","blackHue","roiKind","getRainbowMap","getSaturationMap","negativeStep","positiveStep","getColorMap","RoisColorMode","RAINBOW","colorRois","roiMapManager","getMap","data32","roi","getMask","getMapValue","id","getEllipse","xCenter","yCenter","xCentered","relativePoints","yCentered","centeredXVariance","centeredYVariance","centeredCovariance","eigenvalues","vectors","radiusMajor","radiusMinor","vectorMajor","vectorMinor","majorAxisPoint1","majorAxisPoint2","minorAxisPoint1","minorAxisPoint2","majorLength","minorLength","ellipseSurface","scaleFactor","majorAxis","minorAxis","Roi","computed","getRatio","ped","internalIDs","getComputed","internal","roiMap","computeIndex","boxIDs","externalBorders","externalIDs","internals","border","connectedID","perimeterInfo","one","two","three","four","nbAround","info","absolutePoints","surroundingIDs","eqpc","holesInfo","surroudingIDs","surroundingBorders","visitedData","newX","newY","surroundingBorder","fillRatio","sphericity","filledSurface","solidity","convexHull","roundness","feret","sumColumn","sumRow","computeRois","whites","blacks","borderLengths","borderIDs","currentRoi","whiteRois","blackRois","blackRoi","whiteRoi","RoiKind","WHITE","BW","getRois","maxSurface","MAX_SAFE_INTEGER","RoiMapManager","getMapMatrix","getRoiById","roiID","foundRoi","find","fromMask","MAX_TODO_ARRAY_FILTER","MAX_NEGATIVE_ID","positiveId","negativeId","columnToProcess","rowToProcess","analyseSurface","targetState","require","_dereq_","AbstractPriorityQueue","ArrayStrategy","BHeapStrategy","BinaryHeapStrategy","PriorityQueue","child","parent","hasProp","ctor","__super__","superClass","comparator","ref","priv","initialValues","queue","dequeue","peek","clear","binarySearchForIndexReversed","mid","ref1","pageSize","_shift","_emptyMemoryPageTemplate","_memory","_mask","_write","_bubbleUp","_read","_bubbleDown","compare","indexInPage","parentIndex","parentValue","childIndex1","childIndex2","childValue1","childValue2","_heapify","waterShed","currentImage","fillMaxValue","dxs","dys","currentPoint","currentValueIndex","currentNeighbourIndex","stack","sameDimensions","getImage","maxImage","nbChannels","meanImage","dataSize","medianImage","currentValues","decodeStackFromApng","decodedApng","convertIndexedData","Stack","decodeStackFromTiff","decoded","decodeStack","minImage","checkImagesValid","verifySameDimensions","getImages","stackIndex","channelLabels","drawText","defaultFont","font","defaultColor","fontColor","drawTextElement","layerCanvas","normalizedColor","fillStyle","fillText","content","position","canvasData","numberOfChannels","config","CHANNEL_CONFIGS","pixelCount","imageIndex","canvasIndex","canvasAlpha","invAlpha","channelOffsets","targetIndex","alphaOffset"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,23,24,39,40,41,42,43,44,45,46,47,48,75,76,77,78,79,80,81,90,91,92,141,142,143,144,188,189,190,207,208,209,210,211,212,214,215,216,218,219,220,221,222,223,224,225,226,227,228,229,235,236,237,247,248,250,251,252,253,254,255,256,257,258,259,260,261,262,287]}